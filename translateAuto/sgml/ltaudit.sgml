<sect1 id="ltaudit">
  <title>ltaudit</title>
  <sect2 id="introduction-ltaudit">
    <title>Introduction</title>
    <para>
      The LightDB Audit Extension (ltaudit) provides detailed session
      and/or object audit logging via the standard LightDB logging
      facility.
    </para>
    <para>
      The goal of the ltaudit is to provide LightDB users with
      capability to produce audit logs often required to comply with
      government, financial, or ISO certifications.
    </para>
    <para>
      An audit is an official inspection of an individual’s or
      organization’s accounts, typically by an independent body. The
      information gathered by ltaudit is properly called an audit trail
      or audit log. The term audit log is used in this documentation.
    </para>
  </sect2>
  <sect2 id="why-ltaudit">
    <title>Why ltaudit?</title>
    <para>
      Basic statement logging can be provided by the standard logging
      facility with <literal>log_statement = all</literal>. This is
      acceptable for monitoring and other usages but does not provide
      the level of detail generally required for an audit. It is not
      enough to have a list of all the operations performed against the
      database. It must also be possible to find particular statements
      that are of interest to an auditor. The standard logging facility
      shows what the user requested, while ltaudit focuses on the
      details of what happened while the database was satisfying the
      request.
    </para>
    <para>
      For example, an auditor may want to verify that a particular table
      was created inside a documented maintenance window. This might
      seem like a simple job for grep, but what if you are presented
      with something like this (intentionally obfuscated) example:
    </para>
    <programlisting>
DO $$
BEGIN
    EXECUTE 'CREATE TABLE import' || 'ant_table (id INT)';
END $$;
</programlisting>
    <para>
      Standard logging will give you this:
    </para>
    <programlisting>
LOG:  statement: DO $$
BEGIN
    EXECUTE 'CREATE TABLE import' || 'ant_table (id INT)';
END $$;
</programlisting>
    <para>
      It appears that finding the table of interest may require some
      knowledge of the code in cases where tables are created
      dynamically. This is not ideal since it would be preferable to
      just search on the table name. This is where ltaudit comes in. For
      the same input, it will produce this output in the log:
    </para>
    <programlisting>
AUDIT: SESSION,33,1,FUNCTION,DO,,,&quot;DO $$
BEGIN
    EXECUTE 'CREATE TABLE import' || 'ant_table (id INT)';
END $$;&quot;
AUDIT: SESSION,33,2,DDL,CREATE TABLE,TABLE,public.important_table,CREATE TABLE important_table (id INT)
</programlisting>
    <para>
      Not only is the <literal>DO</literal> block logged, but
      substatement 2 contains the full text of the
      <literal>CREATE TABLE</literal> with the statement type, object
      type, and full-qualified name to make searches easy.
    </para>
    <para>
      When logging <literal>SELECT</literal> and <literal>DML</literal>
      statements, ltaudit can be configured to log a separate entry for
      each relation referenced in a statement. No parsing is required to
      find all statements that touch a particular table. In fact, the
      goal is that the statement text is provided primarily for deep
      forensics and should not be required for an audit.
    </para>
  </sect2>
  <sect2 id="usage-considerations">
    <title>Usage Considerations</title>
    <para>
      Depending on settings, it is possible for ltaudit to generate an
      enormous volume of logging. Be careful to determine exactly what
      needs to be audit logged in your environment to avoid logging too
      much.
    </para>
    <para>
      For example, when working in an OLAP environment it would probably
      not be wise to audit log inserts into a large fact table. The size
      of the log file will likely be many times the actual data size of
      the inserts because the log file is expressed as text. Since logs
      are generally stored with the OS this may lead to disk space being
      exhausted very quickly. In cases where it is not possible to limit
      audit logging to certain tables, be sure to assess the performance
      impact while testing and allocate plenty of space on the log
      volume. This may also be true for OLTP environments. Even if the
      insert volume is not as high, the performance impact of audit
      logging may still noticeably affect latency.
    </para>
    <para>
      To limit the number of relations audit logged for
      <literal>SELECT</literal> and <literal>DML</literal> statements,
      consider using object audit logging (see
      <link linkend="object-audit-logging">Object Auditing</link>).
      Object audit logging allows selection of the relations to be
      logged allowing for reduction of the overall log volume. However,
      when new relations are added they must be explicitly added to
      object audit logging. A programmatic solution where specified
      tables are excluded from logging and all others are included may
      be a good option in this case.
    </para>
  </sect2>
  <sect2 id="settings">
    <title>Settings</title>
    <para>
      Settings may be modified only by a superuser. Allowing normal
      users to change their settings would defeat the point of an audit
      log.
    </para>
    <para>
      Settings can be specified globally (in
      <literal>lightdb.conf</literal> or using
      <literal>ALTER SYSTEM ... SET</literal>), at the database level
      (using <literal>ALTER DATABASE ... SET</literal>), or at the role
      level (using <literal>ALTER ROLE ... SET</literal>). Note that
      settings are not inherited through normal role inheritance and
      <literal>SET ROLE</literal> will not alter a user’s ltaudit
      settings. This is a limitation of the roles system and not
      inherent to ltaudit.
    </para>
    <para>
      The ltaudit extension must be loaded in
      <xref linkend="guc-shared-preload-libraries"/>.
      Otherwise, an error will be raised at load time and no audit
      logging will occur. In addition,
      <literal>CREATE EXTENSION ltaudit</literal> must be called before
      <literal>ltaudit.log</literal> is set. If the
      <literal>ltaudit</literal> extension is dropped and needs to be
      recreated then <literal>ltaudit.log</literal> must be unset first
      otherwise an error will be raised.
    </para>
    <sect3 id="pgauditlog">
      <title>ltaudit.log</title>
      <para>
        Specifies which classes of statements will be logged by session
        audit logging. Possible values are:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="strong">READ</emphasis>:
            <literal>SELECT</literal> and <literal>COPY</literal> when
            the source is a relation or a query.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">WRITE</emphasis>:
            <literal>INSERT</literal>, <literal>UPDATE</literal>,
            <literal>DELETE</literal>, <literal>TRUNCATE</literal>, and
            <literal>COPY</literal> when the destination is a relation.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">FUNCTION</emphasis>: Function calls
            and <literal>DO</literal> blocks.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">ROLE</emphasis>: Statements related
            to roles and privileges: <literal>GRANT</literal>,
            <literal>REVOKE</literal>,
            <literal>CREATE/ALTER/DROP ROLE</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">DDL</emphasis>: All
            <literal>DDL</literal> that is not included in the
            <literal>ROLE</literal> class.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">MISC</emphasis>: Miscellaneous
            commands, e.g. <literal>DISCARD</literal>,
            <literal>FETCH</literal>, <literal>CHECKPOINT</literal>,
            <literal>VACUUM</literal>, <literal>SET</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">MISC_SET</emphasis>: Miscellaneous
            <literal>SET</literal> commands,
            e.g. <literal>SET ROLE</literal>.
          </para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="strong">ALL</emphasis>: Include all of the
            above.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Multiple classes can be provided using a comma-separated list
        and classes can be subtracted by prefacing the class with a
        <literal>-</literal> sign (see
        <link linkend="session-audit-logging">Session Audit
        Logging</link>).
      </para>
      <para>
        The default is <literal>none</literal>.
      </para>
    </sect3>
    <sect3 id="ltaudit.log_catalog">
      <title>ltaudit.log_catalog</title>
      <para>
        Specifies that session logging should be enabled in the case
        where all relations in a statement are in pg_catalog. Disabling
        this setting will reduce noise in the log from tools like psql
        and PgAdmin that query the catalog heavily.
      </para>
      <para>
        The default is <literal>on</literal>.
      </para>
    </sect3>
    <sect3 id="ltaudit.log_client">
      <title>ltaudit.log_client</title>
      <para>
        Specifies whether log messages will be visible to a client
        process such as psql. This setting should generally be left
        disabled but may be useful for debugging or other purposes.
      </para>
      <para>
        Note that <literal>ltaudit.log_level</literal> is only enabled
        when <literal>ltaudit.log_client</literal> is
        <literal>on</literal>.
      </para>
      <para>
        The default is <literal>off</literal>.
      </para>
    </sect3>
    <sect3 id="ltaudit.log_level">
      <title>ltaudit.log_level</title>
      <para>
        Specifies the log level that will be used for log entries (see
        <link linkend="runtime-config-severity-levels">message levels</link> for valid levels) but note that
        <literal>ERROR</literal>, <literal>FATAL</literal>, and
        <literal>PANIC</literal> are not allowed). This setting is used
        for regression testing and may also be useful to end users for
        testing or other purposes.
      </para>
      <para>
        Note that <literal>ltaudit.log_level</literal> is only enabled
        when <literal>ltaudit.log_client</literal> is
        <literal>on</literal>; otherwise the default will be used.
      </para>
      <para>
        The default is <literal>log</literal>.
      </para>
    </sect3>
    <sect3 id="ltaudit.log_parameter">
      <title>ltaudit.log_parameter</title>
      <para>
        Specifies that audit logging should include the parameters that
        were passed with the statement. When parameters are present they
        will be included in <literal>CSV</literal> format after the
        statement text.
      </para>
      <para>
        The default is <literal>off</literal>.
      </para>
    </sect3>
    <sect3 id="ltaudit.log_relation">
      <title>ltaudit.log_relation</title>
      <para>
        Specifies whether session audit logging should create a separate
        log entry for each relation (<literal>TABLE</literal>,
        <literal>VIEW</literal>, etc.) referenced in a
        <literal>SELECT</literal> or <literal>DML</literal> statement.
        This is a useful shortcut for exhaustive logging without using
        object audit logging.
      </para>
      <para>
        The default is <literal>off</literal>.
      </para>
    </sect3>
    <sect3 id="ltaudit.log_statement_once">
      <title>ltaudit.log_statement_once</title>
      <para>
        Specifies whether logging will include the statement text and
        parameters with the first log entry for a statement/substatement
        combination or with every entry. Disabling this setting will
        result in less verbose logging but may make it more difficult to
        determine the statement that generated a log entry, though the
        statement/substatement pair along with the process id should
        suffice to identify the statement text logged with a previous
        entry.
      </para>
      <para>
        The default is <literal>off</literal>.
      </para>
    </sect3>
    <sect3 id="pgauditrole">
      <title>ltaudit.role</title>
      <para>
        Specifies the master role to use for object audit logging.
        Multiple audit roles can be defined by granting them to the
        master role. This allows multiple groups to be in charge of
        different aspects of audit logging.
      </para>
      <para>
        There is no default.
      </para>
    </sect3>
  </sect2>
  <sect2 id="session-audit-logging">
    <title>Session Audit Logging</title>
    <para>
      Session audit logging provides detailed logs of all statements
      executed by a user in the backend.
    </para>
    <sect3 id="configuration">
      <title>Configuration</title>
      <para>
        Session logging is enabled with the
        <link linkend="pgauditlog">ltaudit.log</link> setting.
      </para>
      <para>
        Enable session logging for all <literal>DML</literal> and
        <literal>DDL</literal> and log all relations in
        <literal>DML</literal> statements:
      </para>
      <programlisting>
set ltaudit.log = 'write, ddl';
set ltaudit.log_relation = on;
</programlisting>
      <para>
        Enable session logging for all commands except
        <literal>MISC</literal> and raise audit log messages as
        <literal>NOTICE</literal>:
      </para>
      <programlisting>
set ltaudit.log = 'all, -misc';
set ltaudit.log_level = notice;
</programlisting>
    </sect3>
    <sect3 id="example">
      <title>Example</title>
      <para>
        In this example session audit logging is used for logging
        <literal>DDL</literal> and <literal>SELECT</literal> statements.
        Note that the insert statement is not logged since the
        <literal>WRITE</literal> class is not enabled
      </para>
      <para>
        <emphasis>SQL</emphasis>:
      </para>
      <programlisting>
set ltaudit.log = 'read, ddl';

create table account
(
    id int,
    name text,
    password text,
    description text
);

insert into account (id, name, password, description)
             values (1, 'user1', 'HASH1', 'blah, blah');

select *
    from account;
</programlisting>
      <para>
        <emphasis>Log Output</emphasis>:
      </para>
      <programlisting>
AUDIT: SESSION,1,1,DDL,CREATE TABLE,TABLE,public.account,create table account
(
    id int,
    name text,
    password text,
    description text
);,&lt;not logged&gt;
AUDIT: SESSION,2,1,READ,SELECT,,,select *
    from account,,&lt;not logged&gt;
</programlisting>
    </sect3>
  </sect2>
  <sect2 id="object-audit-logging">
    <title>Object Audit Logging</title>
    <para>
      Object audit logging logs statements that affect a particular
      relation. Only <literal>SELECT</literal>,
      <literal>INSERT</literal>, <literal>UPDATE</literal> and
      <literal>DELETE</literal> commands are supported.
      <literal>TRUNCATE</literal> is not included in object audit
      logging.
    </para>
    <para>
      Object audit logging is intended to be a finer-grained replacement
      for <literal>ltaudit.log = 'read, write'</literal>. As such, it
      may not make sense to use them in conjunction but one possible
      scenario would be to use session logging to capture each statement
      and then supplement that with object logging to get more detail
      about specific relations.
    </para>
    <sect3 id="configuration-1">
      <title>Configuration</title>
      <para>
        Object-level audit logging is implemented via the roles system.
        The <link linkend="pgauditrole">ltaudit.role</link> setting
        defines the role that will be used for audit logging. A relation
        (<literal>TABLE</literal>, <literal>VIEW</literal>, etc.) will
        be audit logged when the audit role has permissions for the
        command executed or inherits the permissions from another role.
        This allows you to effectively have multiple audit roles even
        though there is a single master role in any context.
      </para>
      <para>
        Set <link linkend="pgauditrole">ltaudit.role</link> to
        <literal>auditor</literal> and grant <literal>SELECT</literal>
        and <literal>DELETE</literal> privileges on the
        <literal>account</literal> table. Any <literal>SELECT</literal>
        or <literal>DELETE</literal> statements on the
        <literal>account</literal> table will now be logged:
      </para>
      <programlisting>
set ltaudit.role = 'auditor';

grant select, delete
   on public.account
   to auditor;
</programlisting>
    </sect3>
    <sect3 id="example-1">
      <title>Example</title>
      <para>
        In this example object audit logging is used to illustrate how a
        granular approach may be taken towards logging of
        <literal>SELECT</literal> and <literal>DML</literal> statements.
        Note that logging on the <literal>account</literal> table is
        controlled by column-level permissions, while logging on the
        <literal>account_role_map</literal> table is table-level.
      </para>
      <para>
        <emphasis>SQL</emphasis>:
      </para>
      <programlisting>
set ltaudit.role = 'auditor';

create table account
(
    id int,
    name text,
    password text,
    description text
);

grant select (password)
   on public.account
   to auditor;

select id, name
  from account;

select password
  from account;

grant update (name, password)
   on public.account
   to auditor;

update account
   set description = 'yada, yada';

update account
   set password = 'HASH2';

create table account_role_map
(
    account_id int,
    role_id int
);

grant select
   on public.account_role_map
   to auditor;

select account.password,
       account_role_map.role_id
  from account
       inner join account_role_map
            on account.id = account_role_map.account_id
</programlisting>
      <para>
        <emphasis>Log Output</emphasis>:
      </para>
      <programlisting>
AUDIT: OBJECT,1,1,READ,SELECT,TABLE,public.account,select password
  from account,&lt;not logged&gt;
AUDIT: OBJECT,2,1,WRITE,UPDATE,TABLE,public.account,update account
   set password = 'HASH2',&lt;not logged&gt;
AUDIT: OBJECT,3,1,READ,SELECT,TABLE,public.account,select account.password,
       account_role_map.role_id
  from account
       inner join account_role_map
            on account.id = account_role_map.account_id,&lt;not logged&gt;
AUDIT: OBJECT,3,1,READ,SELECT,TABLE,public.account_role_map,select account.password,
       account_role_map.role_id
  from account
       inner join account_role_map
            on account.id = account_role_map.account_id,&lt;not logged&gt;
</programlisting>
    </sect3>
  </sect2>
  <sect2 id="format">
    <title>Format</title>
    <para>
      Audit entries are written to the standard logging facility and
      contain the following columns in comma-separated format. Output is
      compliant CSV format only if the log line prefix portion of each
      log entry is removed.
    </para>
    <itemizedlist>
      <listitem>
        <para>
          <emphasis role="strong">AUDIT_TYPE</emphasis> -
          <literal>SESSION</literal> or <literal>OBJECT</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong">STATEMENT_ID</emphasis> - Unique
          statement ID for this session. Each statement ID represents a
          backend call. Statement IDs are sequential even if some
          statements are not logged. There may be multiple entries for a
          statement ID when more than one relation is logged.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong">SUBSTATEMENT_ID</emphasis> -
          Sequential ID for each sub-statement within the main
          statement. For example, calling a function from a query.
          Sub-statement IDs are continuous even if some sub-statements
          are not logged. There may be multiple entries for a
          sub-statement ID when more than one relation is logged.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong">CLASS</emphasis> -
          e.g. <literal>READ</literal>, <literal>ROLE</literal> (see
          <link linkend="pgauditlog">ltaudit.log</link>).
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong">COMMAND</emphasis> -
          e.g. <literal>ALTER TABLE</literal>,
          <literal>SELECT</literal>.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong">OBJECT_TYPE</emphasis> -
          <literal>TABLE</literal>, <literal>INDEX</literal>,
          <literal>VIEW</literal>, etc. Available for
          <literal>SELECT</literal>, <literal>DML</literal> and most
          <literal>DDL</literal> statements.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong">OBJECT_NAME</emphasis> - The
          fully-qualified object name (e.g. public.account). Available
          for <literal>SELECT</literal>, <literal>DML</literal> and most
          <literal>DDL</literal> statements.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong">STATEMENT</emphasis> - Statement
          executed on the backend.
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong">PARAMETER</emphasis> - If
          <literal>ltaudit.log_parameter</literal> is set then this
          field will contain the statement parameters as quoted CSV or
          <literal>&lt;none&gt;</literal> if there are no parameters.
          Otherwise, the field is <literal>&lt;not logged&gt;</literal>.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Use <xref linkend="guc-log-line-prefix"/> 
      to add any other fields that are needed to satisfy your audit log
      requirements. A typical log line prefix might be
      <literal>'%m %u %d [%p]: '</literal> which would provide the
      date/time, user name, database name, and process id for each audit
      log.
    </para>
  </sect2>
  <sect2 id="caveats">
    <title>Caveats</title>
    <para>
      Object renames are logged under the name they were renamed to. For
      example, renaming a table will produce the following result:
    </para>
    <programlisting>
ALTER TABLE test RENAME TO test2;

AUDIT: SESSION,36,1,DDL,ALTER TABLE,TABLE,public.test2,ALTER TABLE test RENAME TO test2,&lt;not logged&gt;
</programlisting>
    <para>
      It is possible to have a command logged more than once. For
      example, when a table is created with a primary key specified at
      creation time the index for the primary key will be logged
      independently and another audit log will be made for the index
      under the create entry. The multiple entries will however be
      contained within one statement ID.
    </para>
    <para>
      Autovacuum and Autoanalyze are not logged.
    </para>
    <para>
      Statements that are executed after a transaction enters an aborted
      state will not be audit logged. However, the statement that caused
      the error and any subsequent statements executed in the aborted
      transaction will be logged as ERRORs by the standard logging
      facility.
    </para>
  </sect2>
</sect1>
