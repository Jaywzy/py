<!-- doc/src/sgml/plorasql.sgml -->

<chapter id="plorasql">
  <title><application>PL/oraSQL</application> &mdash; <acronym>SQL</acronym> Procedural Language</title>

 <indexterm zone="plorasql">
  <primary>PL/oraSQL</primary>
 </indexterm>

 <sect1 id="plorasql-overview">
  <title>Overview</title>

 <para>
  <application>PL/oraSQL</application> is a loadable procedural
  language for the <productname>LightDB</productname> database
  system. It is used to be compatible with <productname>Oracle</productname> <application>PL/SQL</application> applications.
  The design goals of <application>PL/oraSQL</application> were to create
  a loadable procedural language that

    <itemizedlist>
     <listitem>
      <para>
       can be used to create functions, procedures, and triggers,
      </para>
     </listitem>
     <listitem>
      <para>
       adds control structures to the <acronym>SQL</acronym> language,
      </para>
     </listitem>
     <listitem>
      <para>
       can perform complex computations,
      </para>
     </listitem>
     <listitem>
      <para>
       inherits all user-defined types, functions, procedures, and operators,
      </para>
     </listitem>
     <listitem>
      <para>
       can be defined to be trusted by the server,
      </para>
     </listitem>
     <listitem>
      <para>
       is easy to use.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Functions created with <application>PL/oraSQL</application> can be
    used anywhere that built-in functions could be used.
    For example, it is possible to
    create complex conditional computation functions and later use
    them to define operators or use them in index expressions.
   </para>

   <para>
    In <productname>LightDB</productname> 22.2 and later,
    <application>PL/oraSQL</application> is installed by default.
    However it is still a loadable module, so especially security-conscious
    administrators could choose to remove it.
   </para>

   <para>
   Althrough most feature is enabled by default, some feature such as call Oracle-specific function or Oracle-builtin package also need LightDB run under Oracle mode.
   </para>
  
  <sect2 id="plorasql-advantages">
   <title>Advantages of Using <application>PL/oraSQL</application></title>

    <para>
     <acronym>SQL</acronym> is the language <productname>LightDB</productname>
     and most other relational databases use as query language. It's
     portable and easy to learn. But every <acronym>SQL</acronym>
     statement must be executed individually by the database server.
    </para>

    <para>
     That means that your client application must send each query to
     the database server, wait for it to be processed, receive and
     process the results, do some computation, then send further
     queries to the server.  All this incurs interprocess
     communication and will also incur network overhead if your client
     is on a different machine than the database server.
    </para>

    <para>
     With <application>PL/oraSQL</application> you can group a block of
     computation and a series of queries <emphasis>inside</emphasis>
     the database server, thus having the power of a procedural
     language and the ease of use of SQL, but with considerable
     savings of client/server communication overhead.
    </para>
    <itemizedlist>
	
     <listitem><para> Compatible with <productname>Oracle</productname> 
	 <application>PL/SQL</application> stored procedure language </para></listitem>

     <listitem><para> Extra round trips between
     client and server are eliminated </para></listitem>

     <listitem><para> Intermediate results that the client does not
     need do not have to be marshaled or transferred between server
     and client </para></listitem>

     <listitem><para> Multiple rounds of query
     parsing can be avoided </para></listitem>

    </itemizedlist>
    <para> This can result in a considerable performance increase as
    compared to an application that does not use stored functions.
    </para>

    <para>
     Also, with <application>PL/oraSQL</application> you can use all
     the data types, operators and functions of SQL.
    </para>
  </sect2>

  <sect2 id="plorasql-args-results">
   <title>Supported Argument and Result Data Types</title>

    <para>
     Functions written in <application>PL/oraSQL</application> can accept
     as arguments any scalar or array data type supported by the server,
     and they can return a result of any of these types.  They can also
     accept or return any composite type (row type) specified by name.
     It is also possible to declare a <application>PL/oraSQL</application>
     function as accepting <type>record</type>, which means that any
     composite type will do as input, or
     as returning <type>record</type>, which means that the result
     is a row type whose columns are determined by specification in the
     calling query.
    </para>
  </sect2>
 </sect1>

 <sect1 id="plorasql-structure">
  <title>Structure of <application>PL/oraSQL</application></title>

  <para>
   <application>PL/oraSQL</application> is a block-structured language.A function,
   procedure, package, trigger or anonymous block contains a block structure, 
   and we call all the parts contained in the <firstterm>anonymous block</firstterm>
   a <firstterm>block</firstterm> structure.
  </para>

  <sect2 id="plorasql-anonymous-block">
   <title>Anonymous Block</title>

  <para>
   An anonymous block is defined as:

<synopsis>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
<optional> EXCEPTION 
    <replaceable>Exception-handling part</replaceable> </optional>
END;
/
</synopsis>
    </para>

    <para>
     Each declaration and each statement within a block is terminated
     by a semicolon.  A block that appears within another block must
     have a semicolon after <literal>END</literal>, as shown above;
     however the final <literal>END</literal> that
     concludes a function body does too require a semicolon.
     where <literal>/</literal> is the end character of plorasql lower block structure.
    </para>

    <tip>
     <para>
      A common mistake is to write a semicolon immediately after
      <literal>BEGIN</literal>.  This is incorrect and will result in a syntax error.
      Anonymous blocks currently do not support the use of <literal>&lt;&lt;label&gt;&gt;</literal>.
     </para>
    </tip>

    <para>
     For example, use an anonymous block to output a value of 'quantity':
<programlisting>
DECLARE
  quantity integer := 80;
BEGIN
  DBMS_OUTPUT.PUT_LINE('Quantity here is '||quantity);  -- Prints 80
END;
/
</programlisting>
    </para>

    <para>
     Before using the <application>DBMS_OUTPUT.PUT_LINE</application> function, you need to turn on the print permission.
<programlisting>
 select dbms_output.serveroutput(true);
</programlisting>
     Of course, this function can only be used in Oracle compatibility mode.
    </para>
  </sect2>

  <sect2 id="plorasql-comments">
   <title>Comments</title>

    <para>
     The <application>PL/oraSQL</application> compiler ignores comments.
     Their purpose is to help other application developers understand your source text.
     Typically, you use comments to describe the purpose and use of each code segment.
     You can also disable obsolete or unfinished pieces of code by turning them into comments.
    </para>

   <sect3 id="plorasql-single-line-comments">
    <title>Single-Line Comments</title>
  
    <para>
     A single-line comment begins with <literal>--</literal> and extends to the end of the line.
     This example has three single-line comments.

<programlisting>
DECLARE
  howmany     NUMBER;
  num_tables  NUMBER;
BEGIN
  -- Begin processing
  SELECT COUNT(*) INTO howmany
  FROM USER_OBJECTS
  WHERE OBJECT_TYPE = 'TABLE'; -- Check number of tables
  num_tables := howmany;       -- Compute another value
END;
/
</programlisting>
    </para>
   </sect3>

   <sect3 id="plorasql-multiline-comments">
     <title>Multiline Comments</title>
  
    <para>
     A multiline comment begins with <literal>/*</literal>,
     ends with <literal>*/</literal>, and can span multiple lines.

<programlisting>
BEGIN
  /*
  IF 2 + 2 = 4 THEN
    some_condition := TRUE;
  END IF;
  */
  NULL;
END;
/
</programlisting>
    </para>
   </sect3>
  </sect2>
 </sect1>

 <sect1 id="plorasql-declarations">
  <title>Declarations</title>

    <para>
     All variables used in a block must be declared in the
     declarations section of the block.
     (The only exceptions are that the loop variable of a <literal>FOR</literal> loop
     iterating over a range of integer values is automatically declared as an
     integer variable, and likewise the loop variable of a <literal>FOR</literal> loop
     iterating over a cursor's result is automatically declared as a
     record variable.)
    </para>

    <para>
     <application>PL/oraSQL</application> variables can have any SQL data type, such as
     <type>integer</type>, <type>varchar</type>, and
     <type>char</type>.
    </para>

    <para>
     Here are some examples of variable declarations:
<programlisting>
user_id integer;
quantity numeric(5);
url varchar(64);
myrow tablename%ROWTYPE;
myfield tablename.columnname%TYPE;
arow RECORD;
</programlisting>
    </para>

    <para>
     The general syntax of a variable declaration is:
<synopsis>
<replaceable>name</replaceable> <optional> CONSTANT </optional> <replaceable>type</replaceable> <optional> NOT NULL </optional> { DEFAULT | := } <replaceable>expression</replaceable>;
</synopsis>
      The <literal>DEFAULT</literal> clause, if given, specifies the initial value assigned
      to the variable when the block is entered.  If the <literal>DEFAULT</literal> clause
      is not given then the variable is initialized to the
      <acronym>SQL</acronym> null value.
      The <literal>CONSTANT</literal> option prevents the variable from being
      assigned to after initialization, so that its value will remain constant
      for the duration of the block.
      If <literal>NOT NULL</literal>
      is specified, an assignment of a null value results in a run-time
      error. All variables declared as <literal>NOT NULL</literal>
      must have a nonnull default value specified.
     </para>

     <para>
      Examples:
<programlisting>
quantity integer DEFAULT 32;
url varchar(64) := 'http://mysite.com';
user_id CONSTANT integer := 10;
</programlisting>
     </para>

    <sect2 id="plorasql-declaration-parameters">
     <title>Declaring Function Parameters</title>

     <para>
      The data type of the declared function parameter name can be either the <application>SQL</application> parameter type
      or the <application>PLoraSQL</application> parameter type.
      And you can use in and out to modify the parameters.
      For example:

<programlisting>
CREATE FUNCTION sales_tax(subtotal in real) RETURN real IS
BEGIN
    RETURN subtotal * 0.06;
END;
/
</programlisting>
     </para>
    </sect2>

  <sect2 id="plorasql-declaration-type">
   <title>Copying Types</title>

<synopsis>
<replaceable>variable</replaceable>%TYPE
</synopsis>

   <para>
    <literal>%TYPE</literal> provides the data type of a variable or
    table column. You can use this to declare variables that will hold
    database values. For example, let's say you have a column named
    <literal>user_id</literal> in your <literal>users</literal>
    table. To declare a variable with the same data type as
    <literal>users.user_id</literal> you write:
<programlisting>
user_id users.user_id%TYPE;
</programlisting>
   </para>

   <para>
    By using <literal>%TYPE</literal> you don't need to know the data
    type of the structure you are referencing, and most importantly,
    if the data type of the referenced item changes in the future (for
    instance: you change the type of <literal>user_id</literal>
    from <type>integer</type> to <type>real</type>), you might not need
    to change your function definition.
   </para>

   <para>
    <literal>%TYPE</literal> is particularly valuable in polymorphic
    functions, since the data types needed for internal variables can
    change from one call to the next.  Appropriate variables can be
    created by applying <literal>%TYPE</literal> to the function's
    arguments or result placeholders.
   </para>

  </sect2>

    <sect2 id="plorasql-declaration-rowtypes">
     <title>Row Types</title>

<synopsis>
<replaceable>name</replaceable> <replaceable>table_name</replaceable><literal>%ROWTYPE</literal>;
</synopsis>

   <para>
    A variable of a composite type is called a <firstterm>row</firstterm>
    variable (or <firstterm>row-type</firstterm> variable).  Such a variable
    can hold a whole row of a <command>SELECT</command> or <command>FOR</command>
    query result, so long as that query's column set matches the
    declared type of the variable.
    The individual fields of the row value
    are accessed using the usual dot notation, for example
    <literal>rowvar.field</literal>.
   </para>

   <para>
    A row variable can be declared to have the same type as the rows of
    an existing table or view, by using the
    <replaceable>table_name</replaceable><literal>%ROWTYPE</literal>
    notation; or it can be declared by giving a composite type's name.
    (Since every table has an associated composite type of the same name,
    it actually does not matter in <productname>LightDB</productname> whether you
    write <literal>%ROWTYPE</literal> or not.  But the form with
    <literal>%ROWTYPE</literal> is more portable.)
   </para>
  </sect2>

  <sect2 id="plorasql-declaration-records">
   <title>Record Types</title>

<synopsis>
<replaceable>name</replaceable> RECORD;
</synopsis>

   <para>
    Record variables are similar to row-type variables, but they have no
    predefined structure.  They take on the actual row structure of the
    row they are assigned during a <command>SELECT</command> or <command>FOR</command> command.  The substructure
    of a record variable can change each time it is assigned to.
    A consequence of this is that until a record variable is first assigned
    to, it has no substructure, and any attempt to access a
    field in it will draw a run-time error.
   </para>

   <para>
    Note that <literal>RECORD</literal> is not a true data type, only a placeholder.
    One should also realize that when a <application>PL/oraSQL</application>
    function is declared to return type <type>record</type>, this is not quite the
    same concept as a record variable, even though such a function might
    use a record variable to hold its result.  In both cases the actual row
    structure is unknown when the function is written, but for a function
    returning <type>record</type> the actual structure is determined when the
    calling query is parsed, whereas a record variable can change its row
    structure on-the-fly.
   </para>
  </sect2>
 </sect1>

  <sect1 id="plorasql-expressions">
  <title>Expressions</title>

    <para>
     All expressions used in <application>PL/oraSQL</application>
     statements are processed using the server's main
     <acronym>SQL</acronym> executor.  For example, when you write
     a <application>PL/oraSQL</application> statement like
<synopsis>
IF <replaceable>expression</replaceable> THEN ...
</synopsis>
     For example, if we have declared two integer variables <literal>x</literal>
    and <literal>y</literal>, and we write
<programlisting>
IF x &lt; y THEN ...
</programlisting>
    </para>
  </sect1>

  <sect1 id="plorasql-statements">
  <title>Basic Statements</title>

   <para>
    In this section and the following ones, we describe all the statement
    types that are explicitly understood by
    <application>PL/oraSQL</application>.
    Anything not recognized as one of these statement types is presumed
    to be an SQL command and is sent to the main database engine to execute.
   </para>

   <sect2 id="plorasql-statements-assignment">
    <title>Assignment</title>

    <para>
     An assignment of a value to a <application>PL/oraSQL</application>
     variable is written as:
<synopsis>
<replaceable>variable</replaceable> := <replaceable>expression</replaceable>;
</synopsis>
     As explained previously, the expression in such a statement is evaluated
     by means of an SQL <command>SELECT</command> command sent to the main
     database engine.  The expression must yield a single value (possibly
     a row value, if the variable is a row or record variable).  The target
     variable can be a simple variable (optionally qualified with a block
     name), a field of a row or record variable, or an element of an array
     that is a simple variable or field. 
    </para>

    <para>
     Examples:
<programlisting>
tax := subtotal * 0.06;
my_record.user_id := 20;
</programlisting>
    </para>
   </sect2>

   <sect2 id="plorasql-statements-sql-onerow">
    <title>Executing a Query with a Single-Row Result</title>

    <indexterm zone="plorasql-statements-sql-onerow">
     <primary>SELECT INTO</primary>
     <secondary>in PL/oraSQL</secondary>
    </indexterm>

    <indexterm zone="plorasql-statements-sql-onerow">
     <primary>RETURNING INTO</primary>
     <secondary>in PL/oraSQL</secondary>
    </indexterm>

    <para>
     The result of a SQL command yielding a single row (possibly of multiple
     columns) can be assigned to a record variable, row-type variable, or list
     of scalar variables.  This is done by writing the base SQL command and
     adding an <literal>INTO</literal> clause.  For example,

<synopsis>
SELECT <replaceable>select_expressions</replaceable> INTO <replaceable>target</replaceable> FROM ...;
INSERT ... RETURNING <replaceable>expressions</replaceable> INTO <replaceable>target</replaceable>;
UPDATE ... RETURNING <replaceable>expressions</replaceable> INTO <replaceable>target</replaceable>;
DELETE ... RETURNING <replaceable>expressions</replaceable> INTO <replaceable>target</replaceable>;
</synopsis>

     where <replaceable>target</replaceable> can be a record variable, a row
     variable, or a comma-separated list of simple variables and
     record/row fields.
     <application>PL/oraSQL</application> variables will be
     substituted into the rest of the query, and the plan is cached,
     just as described above for commands that do not return rows.
     This works for <command>SELECT</command>,
     <command>INSERT</command>/<command>UPDATE</command>/<command>DELETE</command> with
     <literal>RETURNING</literal>, and utility commands that return row-set
     results (such as <command>EXPLAIN</command>).
     Except for the <literal>INTO</literal> clause, the SQL command is the same
     as it would be written outside <application>PL/oraSQL</application>.
    </para>

   <tip>
    <para>
     Note that this interpretation of <command>SELECT</command> with <literal>INTO</literal>
     is quite different from <productname>LightDB</productname>'s regular
     <command>SELECT INTO</command> command, wherein the <literal>INTO</literal>
     target is a newly created table.  If you want to create a table from a
     <command>SELECT</command> result inside a
     <application>PL/oraSQL</application> function, use the syntax
     <command>CREATE TABLE ... AS SELECT</command>.
    </para>
   </tip>

    <para>
     If a row or a variable list is used as target, the query's result columns
     must exactly match the structure of the target as to number and data
     types, or else a run-time error
     occurs.  When a record variable is the target, it automatically
     configures itself to the row type of the query result columns.
    </para>

    <para>
     The <literal>INTO</literal> clause can appear almost anywhere in the SQL
     command.  Customarily it is written either just before or just after
     the list of <replaceable>select_expressions</replaceable> in a
     <command>SELECT</command> command, or at the end of the command for other
     command types.  It is recommended that you follow this convention
     in case the <application>PL/oraSQL</application> parser becomes
     stricter in future versions.
    </para>

    <para>
     If <literal>STRICT</literal> is not specified in the <literal>INTO</literal>
     clause, then <replaceable>target</replaceable> will be set to the first
     row returned by the query, or to nulls if the query returned no rows.
     (Note that <quote>the first row</quote> is not
     well-defined unless you've used <literal>ORDER BY</literal>.)  Any result rows
     after the first row are discarded.
     You can check the special <literal>SQL%FOUND</literal> variable to
     determine whether a row was returned:

<programlisting>
DROP TABLE t1;
DROP SEQUENCE t1_seq;

CREATE TABLE t1 (
  id NUMBER(10),
  description VARCHAR2(50),
  CONSTRAINT t1_pk PRIMARY KEY (id)
);

CREATE SEQUENCE t1_seq;

INSERT INTO t1 VALUES (t1_seq.nextval, 'ONE');
INSERT INTO t1 VALUES (t1_seq.nextval, 'TWO');
INSERT INTO t1 VALUES (t1_seq.nextval, 'THREE');

The RETURNING INTO clause allows us to return column values for rows affected by DML statements.
The returned data could be a single column. For example, When we insert data using a sequence to
generate our primary key value, we can return the primary key value as follows.

DECLARE
  l_id t1.id%TYPE;
BEGIN
  INSERT INTO t1 VALUES (t1_seq.nextval, 'FOUR')
  RETURNING id INTO l_id;
  COMMIT;

  DBMS_OUTPUT.put_line('ID=' || l_id);
END;
/

For example, The syntax is also available for update and delete statements.
DECLARE
  l_id t1.id%TYPE;
BEGIN
  UPDATE t1
  SET    description = description
  WHERE  description = 'FOUR'
  RETURNING id INTO l_id;

  DBMS_OUTPUT.put_line('UPDATE ID=' || l_id);

  DELETE FROM t1
  WHERE  description = 'FOUR'
  RETURNING id INTO l_id;

  DBMS_OUTPUT.put_line('DELETE ID=' || l_id);

  COMMIT;
END;
/
</programlisting>
    </para>
   </sect2>

   <sect2 id="plorasql-statements-executing-dyn">
    <title>Executing Dynamic Commands</title>

    <para>
     Oftentimes you will want to generate dynamic commands inside your
     <application>PL/oraSQL</application> functions, that is, commands
     that will involve different tables or different data types each
     time they are executed.  <application>PL/oraSQL</application>'s
     normal attempts to cache plans for commands will not work in such
     scenarios.  To handle this sort of problem, the
     <command>EXECUTE IMMEDIATE</command> statement is provided:

<synopsis>
EXECUTE IMMEDIATE <replaceable class="command">command-string</replaceable> <optional> INTO <replaceable>target</replaceable> </optional> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

     where <replaceable>command-string</replaceable> is an expression
     yielding a string (of type <type>varchar</type>) containing the
     command to be executed.  The optional <replaceable>target</replaceable>
     is a record variable, a row variable, or a comma-separated list of
     simple variables and record/row fields, into which the results of
     the command will be stored.  The optional <literal>USING</literal> expressions
     supply values to be inserted into the command.
    </para>

    <para>
     No substitution of <application>PL/oraSQL</application> variables is done on the
     computed command string.  Any required variable values must be inserted
     in the command string as it is constructed; or you can use parameters
     as described below.
    </para>

    <para>
     Also, there is no plan caching for commands executed via
     <command>EXECUTE IMMEDIATE </command>.  Instead, the command is always planned
     each time the statement is run. Thus the command
     string can be dynamically created within the function to perform
     actions on different tables and columns.
    </para>

    <para>
     The <literal>INTO</literal> clause specifies where the results of
     a SQL command returning rows should be assigned. If a row
     or variable list is provided, it must exactly match the structure
     of the query's results (when a
     record variable is used, it will configure itself to match the
     result structure automatically). If multiple rows are returned,
     only the first will be assigned to the <literal>INTO</literal>
     variable. If no rows are returned, NULL is assigned to the
     <literal>INTO</literal> variable(s). If no <literal>INTO</literal>
     clause is specified, the query results are discarded.
    </para>

    <para>
     If the <literal>STRICT</literal> option is given, an error is reported
     unless the query produces exactly one row.
    </para>

    <para>
     The command string can use parameter values, which are referenced
     in the command as <literal>:inserted_by</literal>, <literal>:inserted</literal>, etc.
     These symbols refer to values supplied in the <literal>USING</literal>
     clause.  This method is often preferable to inserting data values
     into the command string as varchar: it avoids run-time overhead of
     converting the values to varchar and back, and it is much less prone
     to SQL-injection attacks since there is no need for quoting or escaping.
     An example is:
<programlisting>
EXECUTE IMMEDIATE 'SELECT count(*) FROM mytable WHERE inserted_by = :inserted_by AND inserted &lt;= :inserted'
   INTO c
   USING checked_user, checked_date;
</programlisting>
    </para>

    <para>
     An <command>EXECUTE IMMEDIATE</command> with a simple constant command string and some
     <literal>USING</literal> parameters, as in the first example above, is
     functionally equivalent to just writing the command directly in
     <application>PL/oraSQL</application> and allowing replacement of
     <application>PL/oraSQL</application> variables to happen automatically.
     The important difference is that <command>EXECUTE IMMEDIATE</command> will re-plan
     the command on each execution, generating a plan that is specific
     to the current parameter values; whereas
     <application>PL/oraSQL</application> may otherwise create a generic plan
     and cache it for re-use.  In situations where the best plan depends
     strongly on the parameter values, it can be helpful to use
     <command>EXECUTE IMMEDIATE</command> to positively ensure that a generic plan is not
     selected.
    </para>

    <para>
     <command>SELECT INTO</command> is not currently supported within
     <command>EXECUTE IMMEDIATE</command>; instead, execute a plain <command>SELECT</command>
     command and specify <literal>INTO</literal> as part of the <command>EXECUTE IMMEDIATE</command>
     itself.
    </para>
   </sect2>

   <sect2 id="plorasql-statements-null">
    <title>Doing Nothing At All</title>

    <para>
     Sometimes a placeholder statement that does nothing is useful.
     For example, it can indicate that one arm of an if/then/else
     chain is deliberately empty.  For this purpose, use the
     <command>NULL</command> statement:

<synopsis>
NULL;
</synopsis>
    </para>

    <para>
     For example, the following two fragments of code are equivalent:
<programlisting>
declare
y int := 10;
x int := 10;
BEGIN
  NULL;
END;
/
</programlisting>
    </para>
   </sect2>
  </sect1>

  <sect1 id="plorasql-control-structures">
   <title>Control Structures</title>

   <para>
    Control structures are probably the most useful (and
    important) part of <application>PL/oraSQL</application>. With
    <application>PL/oraSQL</application>'s control structures,
    you can manipulate <productname>LightDB</productname> data in a very
    flexible and powerful way.
   </para>

   <sect2 id="plorasql-statements-returning">
    <title>Returning from a Function</title>

    <para>
     There is one command available that allow you to return data
     from a function: <command>RETURN</command>.
    </para>

    <sect3>
     <title><command>RETURN</command></title>

<synopsis>
RETURN <replaceable>expression</replaceable>;
</synopsis>

     <para>
      <command>RETURN</command> with an expression terminates the
      function and returns the value of
      <replaceable>expression</replaceable> to the caller.  This form
      is used for <application>PL/oraSQL</application> functions that do
      not return a set.
     </para>

     <para>
      If you declared the function with output parameters, write just
      <command>RETURN</command> with no expression.  The current values
      of the output parameter variables will be returned. Currently,
      mixed use of oracle output parameters and return clauses is not supported.
     </para>

     <para>
      The return value of a function cannot be left undefined. If
      control reaches the end of the top-level block of the function
      without hitting a <command>RETURN</command> statement, a run-time
      error will occur. In those cases a <command>RETURN</command> statement is
      automatically executed if the top-level block finishes.
     </para>

     <para>
      Some examples:

<programlisting>
-- functions returning a scalar type
RETURN 1 + 2;
RETURN scalar_var;
</programlisting>
     </para>
    </sect3>
   </sect2>

   <sect2 id="plorasql-statements-returning-procedure">
    <title>Returning from a Procedure</title>

    <para>
     A procedure does not have a return value.  A procedure can therefore end
     without a <command>RETURN</command> statement.  If you wish to use
     a <command>RETURN</command> statement to exit the code early, write
     just <command>RETURN</command> with no expression.
    </para>

    <para>
     Stored procedure parameters are decorated with out,
     and you can end the stored procedure with only return without a return value.
    </para>

    <para>
     If the procedure has output parameters, the final values of the output
     parameter variables will be returned to the caller.
    </para>
   </sect2>

   <sect2 id="plorasql-statements-calling-procedure">
    <title>Calling a Procedure</title>

    <para>
     A <application>PL/oraSQL</application> function, procedure,
     or <command>Anonymous</command> block can call a procedure. For example:
<programlisting>
CREATE PROCEDURE triple(x in int, y out int)
AS
BEGIN
    y := x * 3;
END;
/

DECLARE
  myvar int := 5;
  myresult int := 10;
BEGIN
  triple(myvar, myresult);
  DBMS_OUTPUT.PUT_LINE('myresult = '||myresult);  -- prints 15
END;
/
</programlisting>
    </para>
   </sect2>

   <sect2 id="plorasql-conditionals">
    <title>Conditionals</title>

    <para>
     <command>IF</command> and <command>CASE</command> statements let you execute
     alternative commands based on certain conditions.
     <application>PL/oraSQL</application> has three forms of <command>IF</command>:
    <itemizedlist>
     <listitem>
      <para><literal>IF ... THEN ... END IF</literal></para>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSE ... END IF</literal></para>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSIF ... THEN ... ELSE ... END IF</literal></para>
     </listitem>
    </itemizedlist>

    and two forms of <command>CASE</command>:
    <itemizedlist>
     <listitem>
      <para><literal>CASE ... WHEN ... THEN ... ELSE ... END CASE</literal></para>
     </listitem>
     <listitem>
      <para><literal>CASE WHEN ... THEN ... ELSE ... END CASE</literal></para>
     </listitem>
    </itemizedlist>
    </para>

    <sect3>
     <title><literal>IF-THEN</literal></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
END IF;
</synopsis>

       <para>
        <literal>IF-THEN</literal> statements are the simplest form of
        <literal>IF</literal>. The statements between
        <literal>THEN</literal> and <literal>END IF</literal> will be
        executed if the condition is true. Otherwise, they are
        skipped.
       </para>

       <para>
        Example:
<programlisting>
IF v_user_id &lt;&gt; 0 THEN
    UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;
</programlisting>
       </para>
     </sect3>

     <sect3>
      <title><literal>IF-THEN-ELSE</literal></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
ELSE
    <replaceable>statements</replaceable>
END IF;
</synopsis>

       <para>
        <literal>IF-THEN-ELSE</literal> statements add to
        <literal>IF-THEN</literal> by letting you specify an
        alternative set of statements that should be executed if the
        condition is not true.  (Note this includes the case where the
        condition evaluates to NULL.)
       </para>

       <para>
        Examples:
<programlisting>
IF parentid IS NULL OR parentid = ''
THEN
    RETURN fullname;
ELSE
    RETURN hp_true_filename(parentid) || '/' || fullname;
END IF;
</programlisting>

<programlisting>
IF v_count &gt; 0 THEN
    INSERT INTO users_count (count) VALUES (v_count);
    RETURN 't';
ELSE
    RETURN 'f';
END IF;
</programlisting>
     </para>
    </sect3>

     <sect3>
      <title><literal>IF-THEN-ELSIF</literal></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
</optional>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
    ...
</optional>
<optional> ELSE
    <replaceable>statements</replaceable> </optional>
END IF;
</synopsis>

       <para>
        Sometimes there are more than just two alternatives.
        <literal>IF-THEN-ELSIF</literal> provides a convenient
        method of checking several alternatives in turn.
        The <literal>IF</literal> conditions are tested successively
        until the first one that is true is found.  Then the
        associated statement(s) are executed, after which control
        passes to the next statement after <literal>END IF</literal>.
        (Any subsequent <literal>IF</literal> conditions are <emphasis>not</emphasis>
        tested.)  If none of the <literal>IF</literal> conditions is true,
        then the <literal>ELSE</literal> block (if any) is executed.
       </para>

       <para>
        Here is an example:

<programlisting>
IF number = 0 THEN
    result := 'zero';
ELSIF number &gt; 0 THEN
    result := 'positive';
ELSIF number &lt; 0 THEN
    result := 'negative';
ELSE
    -- hmm, the only other possibility is that number is null
    result := 'NULL';
END IF;
</programlisting>
       </para>

       <para>
        The key word <literal>ELSIF</literal> can also be spelled
        <literal>ELSEIF</literal>.
       </para>

       <para>
        An alternative way of accomplishing the same task is to nest
        <literal>IF-THEN-ELSE</literal> statements, as in the
        following example:

<programlisting>
IF demo_row.sex = 'm' THEN
    pretty_sex := 'man';
ELSE
    IF demo_row.sex = 'f' THEN
        pretty_sex := 'woman';
    END IF;
END IF;
</programlisting>
       </para>

       <para>
        However, this method requires writing a matching <literal>END IF</literal>
        for each <literal>IF</literal>, so it is much more cumbersome than
        using <literal>ELSIF</literal> when there are many alternatives.
       </para>
     </sect3>

     <sect3>
      <title>Simple <literal>CASE</literal></title>

<synopsis>
CASE <replaceable>search-expression</replaceable>
    WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>

      <para>
       The simple form of <command>CASE</command> provides conditional execution
       based on equality of operands.  The <replaceable>search-expression</replaceable>
       is evaluated (once) and successively compared to each
       <replaceable>expression</replaceable> in the <literal>WHEN</literal> clauses.
       If a match is found, then the corresponding
       <replaceable>statements</replaceable> are executed, and then control
       passes to the next statement after <literal>END CASE</literal>.  (Subsequent
       <literal>WHEN</literal> expressions are not evaluated.)  If no match is
       found, the <literal>ELSE</literal> <replaceable>statements</replaceable> are
       executed; but if <literal>ELSE</literal> is not present, then a
       <literal>CASE_NOT_FOUND</literal> exception is raised.
      </para>

      <para>
       Here is a simple example:

<programlisting>
CASE x
    WHEN 1, 2 THEN
        msg := 'one or two';
    ELSE
        msg := 'other value than one or two';
END CASE;
</programlisting>
      </para>
     </sect3>

     <sect3>
      <title>Searched <literal>CASE</literal></title>

<synopsis>
CASE
    WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>

      <para>
       The searched form of <command>CASE</command> provides conditional execution
       based on truth of Boolean expressions.  Each <literal>WHEN</literal> clause's
       <replaceable>boolean-expression</replaceable> is evaluated in turn,
       until one is found that yields <literal>true</literal>.  Then the
       corresponding <replaceable>statements</replaceable> are executed, and
       then control passes to the next statement after <literal>END CASE</literal>.
       (Subsequent <literal>WHEN</literal> expressions are not evaluated.)
       If no true result is found, the <literal>ELSE</literal>
       <replaceable>statements</replaceable> are executed;
       but if <literal>ELSE</literal> is not present, then a
       <literal>CASE_NOT_FOUND</literal> exception is raised.
      </para>

      <para>
       Here is an example:

<programlisting>
CASE
    WHEN x BETWEEN 0 AND 10 THEN
        msg := 'value is between zero and ten';
    WHEN x BETWEEN 11 AND 20 THEN
        msg := 'value is between eleven and twenty';
END CASE;
</programlisting>
      </para>

      <para>
       This form of <command>CASE</command> is entirely equivalent to
       <literal>IF-THEN-ELSIF</literal>, except for the rule that reaching
       an omitted <literal>ELSE</literal> clause results in an error rather
       than doing nothing.
      </para>

     </sect3>
   </sect2>

   <sect2 id="plorasql-control-structures-loops">
    <title>Simple Loops</title>

    <indexterm zone="plorasql-control-structures-loops">
     <primary>loop</primary>
     <secondary>in PL/oraSQL</secondary>
    </indexterm>

    <para>
     With the <literal>LOOP</literal>, <literal>EXIT</literal>,
     <literal>CONTINUE</literal>, <literal>WHILE</literal>, <literal>FOR</literal>,
     and <literal>FOREACH</literal> statements, you can arrange for your
     <application>PL/oraSQL</application> function to repeat a series of commands.
    </para>

    <sect3>
     <title><literal>LOOP</literal></title>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

     <para>
      <literal>LOOP</literal> defines an unconditional loop that is repeated
      indefinitely until terminated by an <literal>EXIT</literal> or
      <command>RETURN</command> statement.  The optional
      <replaceable>label</replaceable> can be used by <literal>EXIT</literal>
      and <literal>CONTINUE</literal> statements within nested loops to
      specify which loop those statements refer to.
     </para>

    <tip>
     <para>
      Label name cannot be the unreserved keyword <replaceable>label</replaceable>.
     </para>
    </tip>
    </sect3>

     <sect3>
      <title><literal>EXIT</literal></title>

     <indexterm>
      <primary>EXIT</primary>
      <secondary>in PL/oraSQL</secondary>
     </indexterm>

<synopsis>
EXIT <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>

       <para>
        If no <replaceable>label</replaceable> is given, the innermost
        loop is terminated and the statement following <literal>END
        LOOP</literal> is executed next.  If <replaceable>label</replaceable>
        is given, it must be the label of the current or some outer
        level of nested loop or block. Then the named loop or block is
        terminated and control continues with the statement after the
        loop's/block's corresponding <literal>END</literal>.
       </para>

       <para>
        If <literal>WHEN</literal> is specified, the loop exit occurs only if
        <replaceable>boolean-expression</replaceable> is true. Otherwise, control passes
        to the statement after <literal>EXIT</literal>.
       </para>

       <para>
        <literal>EXIT</literal> can be used with all types of loops; it is
        not limited to use with unconditional loops.
       </para>

       <para>
        Examples:
<programlisting>
LOOP
    -- some computations
    IF count &gt; 0 THEN
        EXIT;  -- exit loop
    END IF;
END LOOP;

LOOP
    -- some computations
    EXIT WHEN count &gt; 0;  -- same result as previous example
END LOOP;

</programlisting>
       </para>
     </sect3>

     <sect3>
      <title><literal>CONTINUE</literal></title>

     <indexterm>
      <primary>CONTINUE</primary>
      <secondary>in PL/oraSQL</secondary>
     </indexterm>

<synopsis>
CONTINUE <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>

       <para>
        If no <replaceable>label</replaceable> is given, the next iteration of
        the innermost loop is begun. That is, all statements remaining
        in the loop body are skipped, and control returns
        to the loop control expression (if any) to determine whether
        another loop iteration is needed.
        If <replaceable>label</replaceable> is present, it
        specifies the label of the loop whose execution will be
        continued.
       </para>

       <para>
        If <literal>WHEN</literal> is specified, the next iteration of the
        loop is begun only if <replaceable>boolean-expression</replaceable> is
        true. Otherwise, control passes to the statement after
        <literal>CONTINUE</literal>.
       </para>

       <para>
        <literal>CONTINUE</literal> can be used with all types of loops; it
        is not limited to use with unconditional loops.
       </para>

       <para>
        Examples:
<programlisting>
LOOP
    -- some computations
    EXIT WHEN count &gt; 100;
    CONTINUE WHEN count &lt; 50;
    -- some computations for count IN [50 .. 100]
END LOOP;
</programlisting>
       </para>
     </sect3>

     <sect3>
      <title><literal>WHILE</literal></title>

     <indexterm>
      <primary>WHILE</primary>
      <secondary>in PL/oraSQL</secondary>
     </indexterm>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
WHILE <replaceable>boolean-expression</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

       <para>
        The <literal>WHILE</literal> statement repeats a
        sequence of statements so long as the
        <replaceable>boolean-expression</replaceable>
        evaluates to true.  The expression is checked just before
        each entry to the loop body.
       </para>

       <para>
        For example:
<programlisting>
WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
    -- some computations here
END LOOP;

WHILE NOT done LOOP
    -- some computations here
END LOOP;
</programlisting>
       </para>
     </sect3>

     <sect3 id="plorasql-integer-for">
      <title><literal>FOR</literal> (Integer Variant)</title>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>name</replaceable> IN <optional> REVERSE </optional> <replaceable>expression</replaceable> .. <replaceable>expression</replaceable> <optional> BY <replaceable>expression</replaceable> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

       <para>
        This form of <literal>FOR</literal> creates a loop that iterates over a range
        of integer values. The variable
        <replaceable>name</replaceable> is automatically defined as type
        <type>integer</type> and exists only inside the loop (any existing
        definition of the variable name is ignored within the loop).
        The two expressions giving
        the lower and upper bound of the range are evaluated once when entering
        the loop. If the <literal>BY</literal> clause isn't specified the iteration
        step is 1, otherwise it's the value specified in the <literal>BY</literal>
        clause, which again is evaluated once on loop entry.
        If <literal>REVERSE</literal> is specified then the step value is
        subtracted, rather than added, after each iteration.
       </para>

       <para>
        Some examples of integer <literal>FOR</literal> loops:
<programlisting>
FOR i IN 1..10 LOOP
    -- i will take on the values 1,2,3,4,5,6,7,8,9,10 within the loop
END LOOP;

FOR i IN REVERSE 10..1 LOOP
    -- i will take on the values 10,9,8,7,6,5,4,3,2,1 within the loop
END LOOP;

FOR i IN REVERSE 10..1 BY 2 LOOP
    -- i will take on the values 10,8,6,4,2 within the loop
END LOOP;
</programlisting>
       </para>

       <para>
        If the lower bound is greater than the upper bound (or less than,
        in the <literal>REVERSE</literal> case), the loop body is not
        executed at all.  No error is raised.
       </para>

       <para>
        If a <replaceable>label</replaceable> is attached to the
        <literal>FOR</literal> loop then the integer loop variable can be
        referenced with a qualified name, using that
        <replaceable>label</replaceable>.
       </para>
     </sect3>
   </sect2>

   <sect2 id="plorasql-records-iterating">
    <title>Looping through Query Results</title>

    <para>
     Using a different type of <literal>FOR</literal> loop, you can iterate through
     the results of a query and manipulate that data
     accordingly. The syntax is:
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN <replaceable>query</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
     The <replaceable>target</replaceable> is a record variable, row variable,
     or comma-separated list of scalar variables.
     The <replaceable>target</replaceable> is successively assigned each row
     resulting from the <replaceable>query</replaceable> and the loop body is
     executed for each row. Here is an example:
<programlisting>
create table refresh_mview (mv_schema varchar(100), mv_name varchar(100), owner varchar(100));
insert into refresh_mview values ('asd', 'sdf', 'dfg');
CREATE OR REPLACE FUNCTION refresh_mviews(id int) RETURN integer IS
BEGIN
    DBMS_OUTPUT.PUT_LINE('Refreshing all materialized views...');

    FOR mviews IN (SELECT mv_schema, mv_name, owner FROM refresh_mview)
    LOOP
        -- Now "mviews" has one record with information about the materialized view
    DBMS_OUTPUT.PUT_LINE('Refreshing materialized view '|| mviews.mv_schema||'.'||
                         mviews.mv_name|| ' (owner: %)...'|| mviews.owner);
    END LOOP;
    DBMS_OUTPUT.PUT_LINE('Done refreshing materialized views.');
    RETURN id;
END;
/
</programlisting>

     If the loop is terminated by an <literal>EXIT</literal> statement, the last
     assigned row value is still accessible after the loop.
    </para>

    <para>
     The <replaceable>query</replaceable> used in this type of <literal>FOR</literal>
     statement can be any SQL command that returns rows to the caller:
     <command>SELECT</command> is the most common case,
     but you can also use <command>INSERT</command>, <command>UPDATE</command>, or
     <command>DELETE</command> with a <literal>RETURNING</literal> clause.  Some utility
     commands such as <command>EXPLAIN</command> will work too.
    </para>

    <para>
     <application>PL/oraSQL</application> variables are substituted into the query text,
     and the query plan is cached for possible re-use.
    </para>

    <para>
     The <literal>FOR-IN-EXECUTE-IMMEDIATE</literal> statement is another way to iterate over
     rows:
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN EXECUTE IMMEDIATE <replaceable>text_expression</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
     This is like the previous form, except that the source query
     is specified as a string expression, which is evaluated and replanned
     on each entry to the <literal>FOR</literal> loop.  This allows the programmer to
     choose the speed of a preplanned query or the flexibility of a dynamic
     query, just as with a plain <command>EXECUTE IMMEDIATE</command> statement.
     As with <command>EXECUTE IMMEDIATE</command>, parameter values can be inserted
     into the dynamic command via <literal>USING</literal>.
    </para>

    <para>
     Another way to specify the query whose results should be iterated
     through is to declare it as a cursor.  This is described in
     <xref linkend="plorasql-handling-result-sets-with-for-loop-statements"/>.
    </para>
   </sect2>

   <sect2 id="plorasql-error-trapping">
    <title>Trapping Errors</title>

    <indexterm>
     <primary>exceptions</primary>
     <secondary>in PL/oraSQL</secondary>
    </indexterm>

    <para>
     By default, any error occurring in a <application>PL/oraSQL</application>
     function aborts execution of the function and the
     surrounding transaction.  You can trap errors and recover
     from them by using a <command>BEGIN</command> block with an
     <literal>EXCEPTION</literal> clause.  The syntax is an extension of the
     normal syntax for a <command>BEGIN</command> block:

<synopsis>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
EXCEPTION
    WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
        <replaceable>handler_statements</replaceable>
    <optional> WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
          <replaceable>handler_statements</replaceable>
      ... </optional>
END;
/
</synopsis>
    </para>

    <para>
     If no error occurs, this form of block simply executes all the
     <replaceable>statements</replaceable>, and then control passes
     to the next statement after <literal>END</literal>.  But if an error
     occurs within the <replaceable>statements</replaceable>, further
     processing of the <replaceable>statements</replaceable> is
     abandoned, and control passes to the <literal>EXCEPTION</literal> list.
     The list is searched for the first <replaceable>condition</replaceable>
     matching the error that occurred.  If a match is found, the
     corresponding <replaceable>handler_statements</replaceable> are
     executed, and then control passes to the next statement after
     <literal>END</literal>.  If no match is found, the error propagates out
     as though the <literal>EXCEPTION</literal> clause were not there at all:
     the error can be caught by an enclosing block with
     <literal>EXCEPTION</literal>, or if there is none it aborts processing
     of the function.
    </para>

    <para>
     The special condition name <literal>OTHERS</literal> matches every error type.
     Condition names are not case-sensitive.
    </para>

    <tip>
     <para>
      A block containing an <literal>EXCEPTION</literal> clause is significantly
      more expensive to enter and exit than a block without one.  Therefore,
      don't use <literal>EXCEPTION</literal> without need.
     </para>
    </tip>
  </sect2>
 </sect1>

  <sect1 id="plorasql-cursors">
   <title>Cursors</title>

   <indexterm zone="plorasql-cursors">
    <primary>cursor</primary>
    <secondary>in PL/oraSQL</secondary>
   </indexterm>

   <para>
    Rather than executing a whole query at once, it is possible to set
    up a <firstterm>cursor</firstterm> that encapsulates the query, and then read
    the query result a few rows at a time. One reason for doing this is
    to avoid memory overrun when the result contains a large number of
    rows. (However, <application>PL/oraSQL</application> users do not normally need
    to worry about that, since <literal>FOR</literal> loops automatically use a cursor
    internally to avoid memory problems.) A more interesting usage is to
    return a reference to a cursor that a function has created, allowing the
    caller to read the rows. This provides an efficient way to return
    large row sets from functions.
   </para>

   <para>
    A <firstterm>cursor</firstterm> is a pointer to a private SQL area that stores
    information about processing a specific <command>SELECT</command> or DML statement.
   </para>

   <para>
    A <firstterm>cursor</firstterm> that is constructed and managed by
    <application>PL/oraSQL</application> is an implicit cursor. A cursor
    that you construct and manage is an explicit cursor. You can get information about
    any session cursor from its attributes (which you can reference in procedural statements,
    but not in SQL statements).
   </para>
  
   <sect2 id="plorasql-Implicit-Cursors">
    <title>Implicit cursors </title>

   <para>
    An <firstterm>implicit cursor</firstterm> is a session cursor that is constructed and 
    managed by <application>PL/oraSQL</application>. <application>PL/oraSQL</application> opens
    an <firstterm>implicit cursor</firstterm> every time you run a <command>SELECT</command> or
    DML statement.You cannot control an <firstterm>implicit cursor</firstterm>,
    but you can get information from its attributes.
   </para>

   <para>
    An <firstterm>implicit cursor</firstterm> closes after its associated statement runs; however,
    its attribute values remain available until another <command>SELECT</command> or DML statement runs.
   </para>

   <para>
    The most recently run <command>SELECT</command> or DML statement might be in a different scope.
    To save an attribute value for later use, assign it to a local variable immediately. Otherwise,
    other operations, such as subprogram invocations,
    might change the value of the attribute before you can test it.
   </para>
 
    <sect3>
     <title><literal>SQL%ISOPEN</literal> Attribute: Is the Cursor Open?</title>

     <para>
      <literal>SQL%ISOPEN</literal> always returns <literal>FALSE</literal>,because an
      <firstterm>implicit cursor</firstterm> always closes after its associated statement runs.
     </para>
    </sect3>

    <sect3>
     <title><literal>SQL%FOUND</literal> Attribute: Were Any Rows Affected?</title>

<para>
  <literal>SQL%FOUND</literal> returns:

    <itemizedlist>
     <listitem>
      <para>
       <literal>NULL</literal> if no <command>SELECT</command> or DML statement has run,
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>TRUE</literal> if a <command>SELECT</command> statement returned one or more rows or a DML statement affected one or more rows,
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>FALSE</literal> otherwise.
      </para>
     </listitem>
    </itemizedlist>
   </para>

    <para>
     uses <literal>SQL%FOUND</literal> to determine if a <command>DELETE</command>  statement affected any rows. For example:
<programlisting>
create table employees(salary int, job_id varchar(100), employee_id int, last_name varchar(100), first_name varchar(100), department_id int, hire_date date);
create table departments(department_id int, department_name varchar(100), location_id int, staff int);
create table locations(country_id varchar(100),city varchar(100),location_id int);
create table jobs(job_title varchar(100), job_id varchar(100));

insert into employees values (12308, 'SA_REP', 100, 'huaxiang', 'zhao', 2345, TO_DATE('31-DEC-2005', 'DD-MON-YYYY'));
insert into employees values (12301, 'AD_FG', 12301, 'huahai', 'zhao', 2345, TO_DATE('31-DEC-2004', 'DD-MON-YYYY'));
insert into employees values (12302, 'SA_REP', 12302, 'huaduo', 'zhao', 2345, TO_DATE('31-DEC-2004', 'DD-MON-YYYY'));
insert into employees values (12302, 'S[HT]_CLERK', 12302, 'huashuai', 'zhao', 2345, TO_DATE('31-DEC-2004', 'DD-MON-YYYY'));
insert into employees values (12302, 'AD_FG', 100, 'huashuai', 'zhao', 2345, TO_DATE('31-DEC-2004', 'DD-MON-YYYY'));
insert into employees values (12304, 'AD_FG', 100, 'huashuai', 'zhao', 2345, TO_DATE('31-DEC-2004', 'DD-MON-YYYY'));
insert into employees values (12305, 'AD_FG', 100, 'huashuai', 'zhao', 2345, TO_DATE('31-DEC-2004', 'DD-MON-YYYY'));
insert into employees values (12306, 'AD_FG', 100, 'huashuai', 'zhao', 2345, TO_DATE('31-DEC-2004', 'DD-MON-YYYY'));
insert into employees values (12307, 'AD_FG', 100, 'huashuai', 'zhao', 2345, TO_DATE('31-DEC-2004', 'DD-MON-YYYY'));
insert into employees values (12308, 'AD_MAN', 100, 'huaxiang', 'zhao', 2345, TO_DATE('31-DEC-2004', 'DD-MON-YYYY'));

insert into departments values (110, 'asd', 1700, 2345);
insert into departments values (2345, 'asd', 1800, 2345);
insert into departments values (110, 'asd', 1900, 2345);
insert into departments values (110, 'AD_FG', 12302, 2345);

insert into locations values ('JP', 'Japan', 1700);
insert into locations values ('Toronto', 'Canada', 1800);
insert into locations values ('WH', 'Whitehorse', 1900);

insert into jobs values ('sdadf', 'AD_FG');

DROP TABLE dept_temp;
CREATE TABLE dept_temp AS
  SELECT * FROM departments;
 
DECLARE
  dept_no NUMBER := 12;
BEGIN
  DELETE FROM dept_temp
  WHERE department_id = dept_no;
 
  IF SQL%FOUND THEN
    DBMS_OUTPUT.PUT_LINE ('Delete succeeded for department number ' || dept_no);
  ELSE
    DBMS_OUTPUT.PUT_LINE ('No department number ' || dept_no);
  END IF;
END;
/

</programlisting>
    </para>
    </sect3>

    <sect3>
     <title><literal>SQL%NOTFOUND</literal> Attribute: Were Any Rows Affected?</title>

<para>
  <literal>SQL%NOTFOUND</literal> (the logical opposite of <literal>SQL%FOUND</literal>) returns:

    <itemizedlist>
     <listitem>
      <para>
       <literal>NULL</literal> if no <command>SELECT</command> or DML statement has run,
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>FALSE </literal> if a <command>SELECT</command> statement returned one or more rows or a DML statement affected one or more rows.
      </para>
     </listitem>
    </itemizedlist>
   </para>
    </sect3>

    <sect3>
     <title><literal>SQL%ROWCOUNT</literal> Attribute: How Many Rows Were Affected?</title>

<para>
  <literal>SQL%ROWCOUNT </literal> returns:

    <itemizedlist>
     <listitem>
      <para>
       <literal>NULL</literal> if no <command>SELECT</command> or DML statement has run,
      </para>
     </listitem>
     <listitem>
      <para>
       Otherwise, the number of rows returned by a <command>SELECT</command> statement or affected by a DML statement (an <literal>INTEGER</literal>).
      </para>
     </listitem>
    </itemizedlist>
   </para>

    <para>
     uses <literal>SQL%ROWCOUNT</literal> to determine the number of rows that were deleted. For example:
<programlisting>
DROP TABLE employees_temp;
CREATE TABLE employees_temp AS
  SELECT * FROM employees;

DECLARE
  mgr_no int := 123005;
  rowcount int := 0;
BEGIN
  DELETE FROM employees_temp WHERE employee_id = mgr_no;
  rowcount := SQL%ROWCOUNT;
  DBMS_OUTPUT.PUT_LINE ('Number of employees deleted: ' || rowcount);
END;
/
</programlisting>
    </para>
   </sect3>
  </sect2>

   <sect2 id="plorasql-Explicit-Cursors">
    <title>Explicit cursors</title>

    <para>
     An <firstterm>explicit cursor</firstterm> is a session cursor that is constructed and 
     managed.You must declare and define an explicit cursor, giving it a name and associating
     it with a query (typically, the query returns multiple rows). Then you can process the query
     result set in either of these ways:

    <itemizedlist>
     <listitem>
      <para>
       <command>Open</command> the explicit cursor, <command>fetch</command> rows from the result set, and <command>close</command> the explicit cursor,
      </para>
     </listitem>
     <listitem>
      <para>
       Use the explicit cursor in a cursor <command>FOR LOOP</command> statement.
      </para>
     </listitem>
    </itemizedlist>
   </para>

    <para>
     Unlike an <firstterm>implicit cursor</firstterm>, you can reference an <firstterm>explicit cursor</firstterm>
     or cursor variable by its name. Therefore, an explicit cursor or cursor variable is called a named cursor.
    </para>

    <sect3>
     <title>Declaring and Defining <firstterm>Explicit Cursors</firstterm></title>

    <para>
     You can either declare an explicit cursor first and then define it later in the same block,
     subprogram, or package, or declare and define it at the same time.
    </para>

   <para>
    An <literal>explicit cursor declaration</literal>, which only declares a cursor, has this syntax:
   </para>

<synopsis>
CURSOR cursor_name <replaceable>parameter_list</replaceable> RETURN return_type;
</synopsis>

   <para>
   An <literal>explicit cursor definition</literal> has this syntax:
   </para>

<synopsis>
CURSOR cursor_name <replaceable>parameter_list</replaceable> <replaceable>RETURN return_type</replaceable> IS select_statement;
</synopsis>

   <para>
   To actually use the<literal>explicit cursor</literal>, you can define it directly without declaring it.
   </para>

<para>
     declares and defines three explicit cursors. For example:
<programlisting>
DECLARE
  CURSOR c1 RETURN departments%ROWTYPE;    -- Declare c1
 
  CURSOR c2 IS                             -- Declare and define c2
    SELECT employee_id, job_id, salary FROM employees
    WHERE salary > 2000; 
 
  CURSOR c1 RETURN departments%ROWTYPE IS  -- Define c1,
    SELECT * FROM departments              -- repeating return type
    WHERE department_id = 110;
 
  CURSOR c3 RETURN locations%ROWTYPE;      -- Declare c3

  CURSOR c3 IS                             -- Define c3,
    SELECT * FROM locations                -- omitting return type
    WHERE country_id = 'JP';
BEGIN
  NULL;
END;
/
</programlisting>
    </para>
     </sect3>

   <sect3 id="plorasql-cursor-opening-closing">
    <title>Opening and Closing Explicit Cursors</title>

    <para>
     After declaring and defining an explicit cursor, you can open it
     with the OPEN statement.
    </para>

    <para>
     You close an open explicit cursor with the <command>CLOSE</command> statement,
     thereby allowing its resources to be reused. After closing a cursor,
     you cannot fetch records from its result set or reference its attributes.
    </para>
   </sect3>

   <sect3 id="plorasql-cursor-Fetching">
    <title>Fetching Data with Explicit Cursors</title>

    <para>
     After opening an explicit cursor, you can fetch the rows of the query result set with
     the <command>FETCH</command> statement. The basic syntax of a <command>FETCH</command> statement that returns one row is:
    </para>

<synopsis>
FETCH cursor_name INTO into_clause;
</synopsis>

    <para>
     The <literal>into_clause</literal> is either a list of variables or a single record variable.
     For each column that the query returns, the variable list or record must have a corresponding
     type-compatible variable or field. The <literal>%TYPE</literal> and <literal>%ROWTYPE</literal>
     attributes are useful for declaring variables and records for use in <command>FETCH</command> statements.
    </para>

    <para>
     The <command>FETCH</command> statement retrieves the current row of the result set,
     stores the column values of that row into the variables or record,
     and advances the cursor to the next row.
    </para>

    <para>
     Typically, you use the <command>FETCH</command> statement inside a <command>LOOP</command> statement,
     which you exit when the <command>FETCH</command> statement runs out of rows. 
     To detect this exit condition, use the cursor attribute <literal>%NOTFOUND</literal>.
     PL/oraSQL does not raise an exception when a <command>FETCH</command> statement returns no rows.
    </para>

    <para>
     fetches the result sets of two explicit cursors one row at a time,
     using <command>FETCH</command> and %NOTFOUND inside <command>LOOP</command> statements.
     The first <command>FETCH</command> statement retrieves column values into variables.
     The second <command>FETCH</command> statement retrieves column values into a record.
     The variables and record are declared with <literal>%TYPE</literal> and <literal>%ROWTYPE</literal>,
     respectively. For example:
<programlisting>
DECLARE
  CURSOR c1 IS
    SELECT last_name, job_id FROM employees
    WHERE REGEXP_LIKE (job_id, 'S[HT]_CLERK')
    ORDER BY last_name;

  v_lastname  employees.last_name%TYPE;  -- variable for last_name
  v_jobid     employees.job_id%TYPE;     -- variable for job_id

  CURSOR c2 IS
    SELECT * FROM employees
    WHERE REGEXP_LIKE (job_id, '[ACADFIMKSA]_M[ANGR]')
    ORDER BY job_id;

  v_employees employees%ROWTYPE;  -- record variable for row of table

BEGIN
  OPEN c1;
  LOOP  -- Fetches 2 columns into variables
    FETCH c1 INTO v_lastname, v_jobid;
    EXIT WHEN c1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE (RPAD(v_lastname, 25, ' ') || v_jobid);
  END LOOP;
  CLOSE c1;
  DBMS_OUTPUT.PUT_LINE ('-------------------------------------');

  OPEN c2;
  LOOP  -- Fetches entire row into the v_employees record
    FETCH c2 INTO v_employees;
    EXIT WHEN c2%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE (RPAD(v_employees.last_name, 25, ' ') || v_employees.job_id);
  END LOOP;
  CLOSE c2;
END;
/
</programlisting>
    </para>

  <para>
    fetches the first five rows of a result set into five records,
    using five <command>FETCH</command> statements,
    each of which fetches into a different record variable.
    The record variables are declared with <literal>%ROWTYPE</literal>. For example:
<programlisting>
DECLARE
  CURSOR c IS
    SELECT e.job_id, j.job_title
    FROM employees e, jobs j
    WHERE e.job_id = j.job_id AND e.employee_id = 100
    ORDER BY last_name;
 
  -- Record variables for rows of cursor result set:
 
  job1 c%ROWTYPE;
  job2 c%ROWTYPE;
  job3 c%ROWTYPE;
  job4 c%ROWTYPE;
  job5 c%ROWTYPE;
 
BEGIN
  OPEN c;
  FETCH c INTO job1;  -- fetches first row
  FETCH c INTO job2;  -- fetches second row
  FETCH c INTO job3;  -- fetches third row
  FETCH c INTO job4;  -- fetches fourth row
  FETCH c INTO job5;  -- fetches fifth row
  CLOSE c;
 
  DBMS_OUTPUT.PUT_LINE (job1.job_title || ' (' || job1.job_id || ')');
  DBMS_OUTPUT.PUT_LINE (job2.job_title || ' (' || job2.job_id || ')');
  DBMS_OUTPUT.PUT_LINE (job3.job_title || ' (' || job3.job_id || ')');
  DBMS_OUTPUT.PUT_LINE (job4.job_title || ' (' || job4.job_id || ')');
  DBMS_OUTPUT.PUT_LINE (job5.job_title || ' (' || job5.job_id || ')');
END;
/
</programlisting>
    </para>
    </sect3>

   <sect3 id="plorasql-cursor-variables-explicit">
    <title> Variables in Explicit Cursor Queries</title>

    <para>
     An explicit cursor query can reference any variable in its scope.
     When you open an explicit cursor, PL/oraSQL evaluates any variables
     in the query and uses those values when identifying the result set.
     Changing the values of the variables later does not change the result set.
    </para>

    <para>
     the explicit cursor query references the variable <literal>factor</literal>.
     When the cursor opens, <literal>factor</literal> has the value 2. Therefore,
     <literal>sal_multiple</literal> is always 2 times <literal>sal</literal>,
     despite that <literal>factor</literal> is incremented after every fetch. For example:
<programlisting>
DECLARE
  sal           employees.salary%TYPE;
  sal_multiple  employees.salary%TYPE;
  factor        INTEGER := 2;
 
  CURSOR c1 IS
    SELECT salary, salary*factor FROM employees
    WHERE job_id LIKE 'AD_%';
 
BEGIN
  OPEN c1;  -- PL/SQL evaluates factor
 
  LOOP
    FETCH c1 INTO sal, sal_multiple;
    EXIT WHEN c1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE ('factor = ' || factor);
    DBMS_OUTPUT.PUT_LINE ('sal          =  ' || sal);
    DBMS_OUTPUT.PUT_LINE ('sal_multiple = ' || sal_multiple);
    factor := factor + 1;  -- Does not affect sal_multiple
  END LOOP;
 
  CLOSE c1;
END;
/
</programlisting>
    </para>

<para>
     Variable in Explicit Cursor Query—Result Set Change. For example:
<programlisting>
DECLARE
  sal           employees.salary%TYPE;
  sal_multiple  employees.salary%TYPE;
  factor        INTEGER := 2;
 
  CURSOR c1 IS
    SELECT salary, salary*factor FROM employees
    WHERE job_id LIKE 'AD_%';
 
BEGIN
  DBMS_OUTPUT.PUT_LINE ('factor = ' || factor);
  OPEN c1;  -- PL/SQL evaluates factor
  LOOP
    FETCH c1 INTO sal, sal_multiple;
    EXIT WHEN c1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE ('sal          =  ' || sal);
    DBMS_OUTPUT.PUT_LINE ('sal_multiple = ' || sal_multiple);
  END LOOP;
  CLOSE c1;
 
  factor := factor + 1;
 
  DBMS_OUTPUT.PUT_LINE ('factor = ' || factor);
  OPEN c1;  -- PL/SQL evaluates factor
  LOOP
    FETCH c1 INTO sal, sal_multiple;
    EXIT WHEN c1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE ('sal          =  ' || sal);
    DBMS_OUTPUT.PUT_LINE ('sal_multiple = ' || sal_multiple);
  END LOOP;
  CLOSE c1;
END;
/
</programlisting>
    </para>
   </sect3>

   <sect3 id="plorasql-cursor-column-aliases">
    <title>When Explicit Cursor Queries Need Column Aliases</title>

    <para>
     When an explicit cursor query includes a virtual column (an expression),
     that column must have an alias if either of the following is true:
    </para>

    <para>
     You close an open explicit cursor with the <command>CLOSE</command> statement,
     thereby allowing its resources to be reused. After closing a cursor,
     you cannot fetch records from its result set or reference its attributes.
     If you try, PL/oraSQL raises the predefined exception <literal>INVALID_CURSOR</literal>.

    <itemizedlist>
     <listitem>
      <para>
      You use the cursor to fetch into a record that was declared with  <literal>%ROWTYPE</literal>,
      </para>
     </listitem>
     <listitem>
      <para>
       You want to reference the virtual column in your program.
      </para>
     </listitem>
    </itemizedlist>
   </para>

    <para>
     The virtual column in the explicit cursor needs an alias for both of the preceding reasons. For example:
<programlisting>
DECLARE
  CURSOR c1 IS
    SELECT employee_id,
           (salary * .05) raise
    FROM employees
    WHERE job_id LIKE '%_MAN'
    ORDER BY employee_id;
  emp_rec c1%ROWTYPE;
BEGIN
  OPEN c1;
  LOOP
    FETCH c1 INTO emp_rec;
    EXIT WHEN c1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE ('Raise for employee #' ||  emp_rec.employee_id || ' is $' || emp_rec.raise); 
  END LOOP;
  CLOSE c1;
END;
/
</programlisting>
    </para>
    </sect3>

   <sect3 id="plorasql-cursor-accpet-parameter">
    <title>Explicit Cursors that Accept Parameters</title>

    <para>
     You can create an explicit cursor that has formal parameters,
     and then pass different actual parameters to the cursor each time you open it.
     In the cursor query, you can use a formal cursor parameter anywhere that you can use a constant.
     Outside the cursor query, you cannot reference formal cursor parameters.
    </para>

    <para>
     Creates an explicit cursor whose two formal parameters represent a job and its maximum salary.
     When opened with a specified job and maximum salary,
     the cursor query selects the employees with that job who are overpaid
     (for each such employee, the query selects the first and last name and amount overpaid).
     Next, the example creates a procedure that prints the cursor query result set
     (for information about procedures, see PL/SQL Subprograms).
     Finally, the example opens the cursor with one set of actual parameters,
     prints the result set, closes the cursor, opens the cursor with different actual parameters,
     prints the result set, and closes the cursor. For example:
<programlisting>
DECLARE
  CURSOR c (job VARCHAR2, max_sal NUMBER) IS
    SELECT last_name, first_name, (salary - max_sal) overpayment
    FROM employees
    WHERE job_id = job
    AND salary > max_sal
    ORDER BY salary;
 
    last_name_   employees.last_name%TYPE;
    first_name_  employees.first_name%TYPE;
    overpayment_      employees.salary%TYPE;
BEGIN
  DBMS_OUTPUT.PUT_LINE ('----------------------');
  DBMS_OUTPUT.PUT_LINE ('Overpaid Stock Clerks:');
  DBMS_OUTPUT.PUT_LINE ('----------------------');
  OPEN c('ST_CLERK', 5000);
  LOOP
    FETCH c INTO last_name_, first_name_, overpayment_;
    EXIT WHEN c%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE (last_name_ || ',' || first_name_ || ', (by' || overpayment_ || ')');
  END LOOP; 
  CLOSE c;
 
  DBMS_OUTPUT.PUT_LINE ('----------------------');
  DBMS_OUTPUT.PUT_LINE ('Overpaid Sales Representatives:');
  DBMS_OUTPUT.PUT_LINE ('----------------------');
  OPEN c('SA_REP', 10000);
  LOOP
    FETCH c INTO last_name_, first_name_, overpayment_;
    EXIT WHEN c%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE (last_name_ || ',' || first_name_ || ', (by' || overpayment_ || ')');
  END LOOP;
  CLOSE c;
END;
/
</programlisting>
    </para>
    </sect3>

   <sect3 id="plorasql-cursor-default-values">
    <title>Formal Cursor Parameters with Default Values</title>

    <para>
     When you create an explicit cursor with formal parameters,
     you can specify default values for them. When a formal parameter has a default value,
     its corresponding actual parameter is optional.
     If you open the cursor without specifying the actual parameter,
     then the formal parameter has its default value.
    </para>

<synopsis>
parameter_name <optional>IN</optional> data_type <optional><replaceable>:= | default expression</replaceable></optional>
</synopsis>

    <para>
     The application scenarios are stored procedures, functions, anonymous blocks and packages.
     Compared with Oracle, there are some differences. For example, for <literal>data_type</literal>,
     Oracle supports the declaration of char in the cursor parameter string,
     but the default value of lightdb's char length is 1, so for strings whose length exceeds 1,
     you need to specify the char length, char(100). But for variable-length character types,
     such as varchar, varchar2, etc., the usage is the same as oracle.
     And does not support oracle types: string, long, raw, long raw, rowid,
     timestamp with local time, etc. The constant type defined by constant is not supported in the package.
    </para>

<para>
  <literal>Expressions</literal> also have some differences compared to Oracle.

    <itemizedlist>
     <listitem>
      <para>
       Boolean Expressions
         <itemizedlist>
          <listitem>
           <para>
            The package supports functions that return boolean types, boolean expressions and boolean literals (NULL supported by oracle does not support)，
           </para>
          </listitem>
          <listitem>
           <para>
            Functions, stored procedures, and anonymous blocks support functions that return boolean types, boolean constants, Boolean variables, boolean expressions, and boolean literals (NULL supported by oracle does not support).
           </para>
          </listitem>
         </itemizedlist>
      </para>
     </listitem>
     <listitem>
      <para>
       Character Expressions
         <itemizedlist>
          <listitem>
           <para>
            The package supports functions that return values of type characer and characer literals,
           </para>
          </listitem>
          <listitem>
           <para>
            Functions, stored procedures, and anonymous blocks support functions that return values of type characer, characer constants, characer variables, characer expressions, and characer literals.
           </para>
          </listitem>
         </itemizedlist>
      </para>
     </listitem>
     <listitem>
      <para>
       Date Expressions
         <itemizedlist>
          <listitem>
           <para>
            The package supports functions that return values of type date and date literals,
           </para>
          </listitem>
          <listitem>
           <para>
            Functions, stored procedures, and anonymous blocks support functions that return values of type date, date constants, date variables, date expressions, and date literals.
           </para>
          </listitem>
         </itemizedlist>
      </para>
     </listitem>
     <listitem>
      <para>
       Numeric Expressions
         <itemizedlist>
          <listitem>
           <para>
            Not supported in package: collection, named_cursor, numberic_constant, numberic_variable, placeholder, SQL% cursor attribute, ** (operator not supported),
           </para>
          </listitem>
          <listitem>
           <para>
            Not supported in functions, stored procedures, anonymous blocks: collection, named_cursor, placeholder, SQL% cursor attribute, ** (operator not supported).
           </para>
          </listitem>
         </itemizedlist>
      </para>
     </listitem>
     <listitem>
      <para>
       Case Expressions
         <itemizedlist>
          <listitem>
           <para>
            search_case_expression and simple_case_expression are supported in packages, functions, stored procedures, anonymous blocks.
           </para>
          </listitem>
         </itemizedlist>
      </para>
     </listitem>
    </itemizedlist>
   </para>

    <para>
     Creates an explicit cursor whose formal parameter represents a location ID.
     The default value of the parameter is the location ID of company headquarters. For example:
<programlisting>
DECLARE
  CURSOR c (location NUMBER DEFAULT 1700) IS
    SELECT d.department_name,
           e.last_name manager,
           l.city
    FROM departments d, employees e, locations l
    WHERE l.location_id = location
      AND l.location_id = d.location_id
      AND d.department_id = e.department_id
    ORDER BY d.department_id;
    dept_name  departments.department_name%TYPE;
    mgr_name   employees.last_name%TYPE;
    city_name  locations.city%TYPE;
BEGIN
  DBMS_OUTPUT.PUT_LINE ('DEPARTMENTS AT HEADQUARTERS:');
  DBMS_OUTPUT.PUT_LINE ('--------------------------------');
  OPEN c;
  LOOP
    FETCH c INTO dept_name, mgr_name, city_name;
    EXIT WHEN c%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE (dept_name || ' (Manager: ' || mgr_name || ')');
  END LOOP;
  DBMS_OUTPUT.PUT_LINE ('--------------------------------');
  CLOSE c;
 
  DBMS_OUTPUT.PUT_LINE ('DEPARTMENTS IN CANADA:');
  DBMS_OUTPUT.PUT_LINE ('--------------------------------');
  OPEN c(1800); -- Toronto
  LOOP
    FETCH c INTO dept_name, mgr_name, city_name;
    EXIT WHEN c%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE (dept_name || ' (Manager: ' || mgr_name || ')');
  END LOOP; 
  CLOSE c;
  OPEN c(1900); -- Whitehorse
  LOOP
    FETCH c INTO dept_name, mgr_name, city_name;
    EXIT WHEN c%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE (dept_name || ' (Manager: ' || mgr_name || ')');
  END LOOP;
  CLOSE c;
END;
/
</programlisting>
    </para>

    <para>
     If you add formal parameters to a cursor, and you specify default values for the added parameters,
     then you need not change existing references to the cursor. For example:
<programlisting>
DECLARE
  CURSOR c (job VARCHAR2, max_sal NUMBER,
            hired DATE DEFAULT TO_DATE('31-DEC-1999', 'DD-MON-YYYY')) IS
    SELECT last_name, first_name, (salary - max_sal) overpayment
    FROM employees
    WHERE job_id = job
    AND salary > max_sal
    AND hire_date > hired
    ORDER BY salary;
    last_name_   employees.last_name%TYPE;
    first_name_  employees.first_name%TYPE;
    overpayment_      employees.salary%TYPE;
BEGIN
  DBMS_OUTPUT.PUT_LINE ('--------------------------------');
  DBMS_OUTPUT.PUT_LINE ('Overpaid Sales Representatives Hired After 2004:');
  DBMS_OUTPUT.PUT_LINE ('--------------------------------');
  OPEN c('SA_REP', 10000);
  LOOP
    FETCH c INTO last_name_, first_name_, overpayment_;
    EXIT WHEN c%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE (last_name_ || ', (by ' || overpayment_ || ')');
  END LOOP;  
  CLOSE c;
END;
/
</programlisting>
    </para>
    </sect3>

   <sect3 id="plorasql-cursor-attributes-explicit">
    <title>Explicit Cursor Attributes</title>

    <para>
     The syntax for the value of an explicit cursor attribute is <literal>cursor_name</literal>
     immediately followed by attribute (for example, <literal>c1%ISOPEN</literal>).
    </para>

    <para>
     You close an open explicit cursor with the <command>CLOSE</command> statement,
     thereby allowing its resources to be reused. After closing a cursor,
     you cannot fetch records from its result set or reference its attributes.
     If you try, PL/oraSQL raises the predefined exception <literal>INVALID_CURSOR</literal>.
    </para>

    <sect4>
     <title><literal>%ISOPEN</literal> Attribute: Is the Cursor Open?</title>

    <para>
     <literal>%ISOPEN</literal> returns <literal>true</literal>,if its explicit cursor is open.
     <literal>false</literal> oterwise.
    </para>

    <para>
     opens the explicit cursor <literal>c1</literal> only if it is not open and closes it only if it is open. For example:
<programlisting>
DECLARE
  CURSOR c1 IS
    SELECT last_name, salary FROM employees
    WHERE ROWNUM &lt; 11;

  the_name employees.last_name%TYPE;
  the_salary employees.salary%TYPE;
BEGIN
  IF NOT c1%ISOPEN THEN
    OPEN c1;
  END IF;

  FETCH c1 INTO the_name, the_salary;

  IF c1%ISOPEN THEN
    CLOSE c1;
  END IF;
END;
/
</programlisting>

     To use ROWNUM,the value of lightdb_dblevel_syntax_compatible_type must be oracle.
    </para>
    </sect4>

    <sect4>
     <title><literal>%FOUND</literal> Attribute: Were Any Rows Affected?</title>

<para>
  <literal>%FOUND</literal> returns:

    <itemizedlist>
     <listitem>
      <para>
       <literal>NULL</literal> after the explicit cursor is opened but before the first fetch,
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>TRUE</literal> f the most recent fetch from the explicit cursor returned a row,
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>FALSE</literal> otherwise.
      </para>
     </listitem>
    </itemizedlist>
   </para>

    <para>
     loops through a result set, printing each fetched row and exiting when there are no more rows to fetch. For example:
<programlisting>
DECLARE
  CURSOR c1 IS
    SELECT last_name, salary FROM employees
    WHERE ROWNUM &lt; 11
    ORDER BY last_name;

  my_ename   employees.last_name%TYPE;
  my_salary  employees.salary%TYPE;
BEGIN
  OPEN c1;
  LOOP
    FETCH c1 INTO my_ename, my_salary;
    IF c1%FOUND THEN  -- fetch succeeded
      DBMS_OUTPUT.PUT_LINE ('Name = ' || my_ename || ' salary = ' || my_salary);
    ELSE  -- fetch failed
      EXIT;
    END IF;
  END LOOP;
END;
/
</programlisting>
    </para>
    </sect4>

    <sect4>
     <title><literal>%NOTFOUND</literal> Attribute: Were Any Rows Affected?</title>

<para>
  <literal>%NOTFOUND</literal> (the logical opposite of <literal>%FOUND</literal>) returns:

    <itemizedlist>
     <listitem>
      <para>
       <literal>NULL</literal> after the explicit cursor is opened but before the first fetch,
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>FALSE </literal> if the most recent fetch from the explicit cursor returned a row,
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>TRUE</literal> otherwise.
      </para>
     </listitem>
    </itemizedlist>
   </para>

<para>
     <literal>%NOTFOUND</literal> is useful for exiting a loop when <command>FETCH</command> fails to return a row. For example:
<programlisting>
DECLARE
  CURSOR c1 IS
    SELECT last_name FROM employees
    WHERE ROWNUM &lt; 11
    ORDER BY last_name;
  rowcount int;
  name_1  employees.last_name%TYPE;
BEGIN
  OPEN c1;
  LOOP
    FETCH c1 INTO name_1;
    EXIT WHEN c1%NOTFOUND;
    rowcount := c1%ROWCOUNT;
    DBMS_OUTPUT.PUT_LINE (rowcount ||'. ' || name_1);
    IF c1%ROWCOUNT = 5 THEN
       DBMS_OUTPUT.PUT_LINE ('--- Fetched 5th row ---');
    END IF;
  END LOOP;
  CLOSE c1;
END;
/
</programlisting>
    </para>
    </sect4>

    <sect4>
     <title><literal>%ROWCOUNT</literal> Attribute: How Many Rows Were Affected?</title>

<para>
  <literal>%ROWCOUNT </literal> returns:

    <itemizedlist>
     <listitem>
      <para>
       Zero after the explicit cursor is opened but before the first fetch,
      </para>
     </listitem>
     <listitem>
      <para>
       Otherwise, the number of rows fetched (an <literal>INTEGER</literal>).
      </para>
     </listitem>
    </itemizedlist>
   </para>

<para>
     numbers and prints the rows that it fetches and prints a message after fetching the fifth row. For example:
<programlisting>
DECLARE
  CURSOR c1 IS
    SELECT last_name FROM employees
    WHERE ROWNUM &lt; 11
    ORDER BY last_name;

  name_1  employees.last_name%TYPE;
  rowcount int;
BEGIN
  OPEN c1;
  LOOP
    FETCH c1 INTO name_1;
    EXIT WHEN c1%NOTFOUND OR c1%NOTFOUND IS NULL;
    rowcount := c1%ROWCOUNT;
    DBMS_OUTPUT.PUT_LINE (rowcount || '. ' || name_1);
    IF c1%ROWCOUNT = 5 THEN
       DBMS_OUTPUT.PUT_LINE ('--- Fetched 5th row ---');
    END IF;
  END LOOP;
  CLOSE c1;
END;
/
</programlisting>
    </para>
    </sect4>
   </sect3>
  </sect2>
  
  <sect2 id="plorasql-processing-query-result-sets">
    <title>Processing Query Result Sets</title>

    <para>
     In PL/oraSQL, as in traditional database programming,
     you use cursors to process query result sets. However,
    in PL/oraSQL, you can use either implicit or explicit cursors.
    </para>

    <para>
     The former need less code, but the latter are more flexible.
     For example, explicit cursors can accept parameters.
    </para>
 
    <para>
     The following PL/oraSQL statements use implicit cursors that
     PL/oraSQL defines and manages for you:

    <itemizedlist>
     <listitem>
      <para>
      <command>SELECT INTO</command>,
      </para>
     </listitem>
     <listitem>
      <para>
       Implicit cursor <command>FOR LOOP</command>.
      </para>
     </listitem>
    </itemizedlist>
    </para>

    <para>
     The following PL/oraSQL statements use explicit cursors:

    <itemizedlist>
     <listitem>
      <para>
      Explicit cursor <command>FOR LOOP</command>,
      </para>
     </listitem>
     <listitem>
      <para>
       <command>OPEN</command>, <command>FETCH</command>, and <command>CLOSE</command>.
      </para>
     </listitem>
    </itemizedlist>
    </para>

  <sect3 id="plorasql-handling-result-sets-with-select-into">
    <title>Processing Query Result Sets With SELECT INTO Statements</title>

    <para>
     Using an implicit cursor, the <command>SELECT INTO</command> statement retrieves values from
     one or more database tables (as the SQL <command>SELECT</command> statement does) and
     stores them in variables (which the SQL <command>SELECT</command> statement does not do).
    </para>

   <sect4 id="plorasql-handling-single-row-result-sets">
    <title>Handling Single-Row Result Sets</title>

    <para>
     If you expect the query to return only one row,
     then use the <command>SELECT INTO</command> statement to store values from
     that row in either one or more scalar variables, or one record variable.
    </para>

    <para>
     If the query might return multiple rows,
     but you care about only the nth row,
     then restrict the result set to that row with the clause <literal>WHERE ROWNUM=n</literal>.
   </para>
   </sect4>

   <sect4 id="plorasql-handling-multiple-result-sets">
    <title>Handling Large Multiple-Row Result Sets</title>

    <para>
     If you must assign a large quantity of table data to variables,
     <productname>LightDB</productname> recommends using the <command>SELECT INTO</command> statement with
     the <command>BULK COLLECT</command> clause.
    </para>
  </sect4>
  </sect3>

   <sect3 id="plorasql-handling-result-sets-with-for-loop-statements">
    <title> Processing Query Result Sets With Cursor FOR LOOP Statements</title>

   <para>
    The cursor <command>FOR LOOP</command> statement lets you run a <command>SELECT</command> statement
    and then immediately loop through the rows of the result set.
   </para>

   <para>
    This statement can use either an implicit or explicit cursor (but not a cursor variable).
   </para>

<para>
     If you use the <command>SELECT</command> statement only in the cursor FOR LOOP statement,
     then specify the <command>SELECT</command> statement inside the cursor
     <command>FOR LOOP</command> statement. Implicit Cursor <command>FOR LOOP</command> Statement.
     For example:
<programlisting>
BEGIN
  FOR item IN (
    select last_name, job_id
    FROM employees
    WHERE job_id LIKE '%CLERK%'
    AND employee_id > 120
  )
  LOOP
    DBMS_OUTPUT.PUT_LINE ('Name = ' || item.last_name || ', Job = ' || item.job_id);
  END LOOP;
END;
/
</programlisting>
    </para>

    <para>
     Explicit Cursor <command>FOR LOOP</command> Statement. For example:
<programlisting>
DECLARE
  CURSOR c1 IS
    SELECT last_name, job_id FROM employees
    WHERE job_id LIKE '%CLERK%' AND employee_id > 120
    ORDER BY last_name;
BEGIN
  FOR item IN c1
  LOOP
    DBMS_OUTPUT.PUT_LINE ('Name = ' || item.last_name || ', Job = ' || item.job_id);
  END LOOP;
END;
/
</programlisting>
    </para>

    <para>
     Passing Parameters to Explicit Cursor <command>FOR LOOP</command> Statement. For example:
<programlisting>
DECLARE
  CURSOR c1 (job VARCHAR2, max_wage NUMBER) IS
    SELECT * FROM employees
    WHERE job_id = job
    AND salary > max_wage;
BEGIN
  FOR person IN c1('ST_CLERK', 3000)
  LOOP
     -- process data record
    DBMS_OUTPUT.PUT_LINE ('Name = ' || person.last_name || ', salary = ' || person.salary || ', Job id= ' || person.job_id);
  END LOOP;
END;
/
</programlisting>
    </para>

    <para>
     Cursor <command>FOR LOOP</command> References Virtual Columns. For example:
<programlisting>
BEGIN
  FOR item IN (
    SELECT first_name || ' ' || last_name AS full_name,
           salary * 10                    AS dream_salary 
    FROM employees
    WHERE ROWNUM &lt; 6
    ORDER BY dream_salary DESC, last_name ASC
  ) LOOP
    DBMS_OUTPUT.PUT_LINE (item.full_name || ' dreams of making ' || item.dream_salary);
  END LOOP;
END;
/
</programlisting>
    </para>
    </sect3>

  <sect3 id="plorasql-handling-result-sets-with-Subqueries">
   <title>Processing Query Result Sets with Subqueries</title>

   <para>
    If you process a query result set by looping through it and running another query for each row,
    then you can improve performance by removing the second query from inside the loop
    and making it a subquery of the first query.
   </para>

   <para>
    While an ordinary subquery is evaluated for each table,
    a <literal>correlated subquery</literal> is evaluated for each row.
   </para>

    <para>
     Subquery in <command>FROM</command> Clause of Parent Query. For example:
<programlisting>
DECLARE
  CURSOR c1 IS
    SELECT t1.department_id, t1.department_name, t2.staff
    FROM departments t1,
         ( SELECT department_id, COUNT(*) AS staff
           FROM employees
           GROUP BY department_id
         ) t2
    WHERE (t1.department_id = t2.department_id) AND t2.staff &gt; 5
    ORDER BY t2.staff;

BEGIN
   FOR dept IN c1
   LOOP
     DBMS_OUTPUT.PUT_LINE ('Department = ' || dept.department_name || ', staff = ' || dept.staff);
   END LOOP;
END;
/
</programlisting>
    </para>

    <para>
     Correlated Subquery. For example:
<programlisting>
DECLARE
  CURSOR c1 IS
    SELECT department_id, last_name, salary
    FROM employees t
    WHERE salary >= ( SELECT AVG(salary)
                     FROM employees
                     WHERE t.department_id = department_id
                   )
    ORDER BY department_id, last_name;
BEGIN
  FOR person IN c1
  LOOP
    DBMS_OUTPUT.PUT_LINE ('Making above-average salary =  ' || person.last_name);
  END LOOP;
END;
/
</programlisting>
    </para>
  </sect3>
  </sect2> 

  <sect2 id="plorasql-cursor-variables">
   <title>Cursor Variables</title>

    <para>
     A <literal>cursor</literal> variable is like an explicit cursor, except that:

    <itemizedlist>
     <listitem>
      <para>
       It is not limited to one query.
       You can open a cursor variable for a query, process the result set,
       and then use the cursor variable for another query.
      </para>
     </listitem>
     <listitem>
      <para>
       You can assign a value to it.
      </para>
     </listitem>
     <listitem>
      <para>
       You can use it in an expression.
      </para>
     </listitem>
     <listitem>
      <para>
       It can be a subprogram parameter.
       You can use cursor variables to pass query result sets between subprograms.
      </para>
     </listitem>
     <listitem>
      <para>
       It can be a host variable.
       You can use cursor variables to pass query result sets between PL/oraSQL stored subprograms
       and their clients.
      </para>
     </listitem>
     <listitem>
      <para>
       It cannot accept parameters.
       You cannot pass parameters to a cursor variable, but you can pass whole queries to it.
       The queries can include variables.
      </para>
     </listitem>
    </itemizedlist>
    </para>

   <sect3 id="plorasql-creating-cursor-variables">
    <title>Creating Cursor Variables</title>

    <para>
     To create a cursor variable, either declare a variable of the predefined type <literal>SYS_REFCURSOR</literal>
     or define a <literal>REF CURSOR</literal> type and then declare a variable of that type.
    </para>

    <para>
     The basic syntax of a <literal>REF CURSOR</literal> type definition is:
    </para>

<synopsis>
TYPE type_name IS REF CURSOR <replaceable>RETURN return_type</replaceable>%TYPE
</synopsis>

    <para>
     Cursor Variable Declarations. For example:
<programlisting>
DECLARE
  TYPE empcurtyp IS REF CURSOR RETURN employees%ROWTYPE;
  TYPE genericcurtyp IS REF CURSOR; 

  cursor1  empcurtyp;
  cursor2  genericcurtyp;
  my_cursor SYS_REFCURSOR;

  TYPE deptcurtyp IS REF CURSOR RETURN departments%ROWTYPE;
  dept_cv deptcurtyp;  -- strong cursor variable
BEGIN
  NULL;
END;
/
</programlisting>
    </para>

    <para>
     Cursor Variable with User-Defined Return Type. For example:
<programlisting>
DECLARE
  TYPE EmpRecTyp IS RECORD (
    employee_id NUMBER,
    last_name VARCHAR2(25),
    salary   NUMBER(8,2));

  TYPE EmpCurTyp IS REF CURSOR RETURN EmpRecTyp;
  emp_cv EmpCurTyp;
BEGIN
  NULL;
END;
/
</programlisting>
     </para>
    </sect3>

  <sect3 id="plorasql-open-and-close-cursor">
   <title>Opening and Closing Cursor Variables</title>

    <para>
     After declaring a cursor variable, you can open it with the <command>OPEN FOR</command> statement,
     which does the following:

    <itemizedlist>
     <listitem>
      <para>
      Associates the cursor variable with a query (typically, the query returns multiple rows).
      The query can include placeholders for bind variables,
      whose values you specify in the <command>USING</command> clause of the <command>OPEN FOR</command> statement.
      </para>
     </listitem>
     <listitem>
      <para>
       Allocates database resources to process the query.
      </para>
     </listitem>
     <listitem>
      <para>
       Processes the query; that is:

      <itemizedlist>
       <listitem>
        <para>
         Identifies the result set.
         If the query references variables, their values affect the result set. 
        </para>
       </listitem>
       <listitem>
        <para>
         If the query has a <command>FOR UPDATE</command> clause, locks the rows of the result set.
        </para>
       </listitem>
      </itemizedlist>
      </para>
     </listitem>
     <listitem>
      <para>
       Positions the cursor before the first row of the result set.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect3>

  <sect3 id="plorasql-fetching-cursor-variables">
   <title>Fetching Data with Cursor Variables</title>

    <para>
     After opening a cursor variable, you can fetch the rows of the query result set
     with the <command>FETCH</command> statement. The return type of the cursor variable
     must be compatible with the <command>into_clause</command> of the <command>FETCH</command> statement.
    </para>

    <para>
     The first <command>iOPEN FOR</command> statement includes the query itself.
     The second <command>OPEN FOR</command>i statement references a variable whose value is a query.
     For example:
<programlisting>
DECLARE
  cv SYS_REFCURSOR;  -- cursor variable
 
  v_lastname  employees.last_name%TYPE;  -- variable for last_name
  v_jobid     employees.job_id%TYPE;     -- variable for job_id
 
  query_2 VARCHAR2(200) :=
    'SELECT * FROM employees
    WHERE REGEXP_LIKE (job_id, ''[ACADFIMKSA]_M[ANGR]'')
    ORDER BY job_id';
 
  v_employees employees%ROWTYPE;  -- record variable row of table
 
BEGIN
  OPEN cv FOR
    SELECT last_name, job_id FROM employees
    WHERE REGEXP_LIKE (job_id, 'S[HT]_CLERK')
    ORDER BY last_name;
 
  LOOP  -- Fetches 2 columns into variables
    FETCH cv INTO v_lastname, v_jobid;
    EXIT WHEN cv%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE (RPAD(v_lastname, 25, ' ') || v_jobid);
  END LOOP;
 
  DBMS_OUTPUT.PUT_LINE ('-------------------------------------');
 
  CLOSE CV;
 
  OPEN cv FOR query_2;
 
  LOOP  -- Fetches entire row into the v_employees record
    FETCH cv INTO v_employees;
    EXIT WHEN cv%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE (RPAD(v_employees.last_name, 25, ' ') || v_employees.job_id);
  END LOOP;
 
  CLOSE cv;
END;
/
</programlisting>
    </para>
   </sect3>

  <sect3 id="plorasql-assigning-values">
   <title>Assigning Values to Cursor Variables</title>

    <para>
     You can assign to a PL/oraSQL cursor variable the value of another PL/oraSQL cursor variable or
     host cursor variable.
    </para>

<synopsis>
target_cursor_variable := source_cursor_variable;
</synopsis>

    <para>
     If <literal>source_cursor_variable</literal> is open, then after the assignment,
     <literal>target_cursor_variable</literal> is also open.
     The two cursor variables point to the same SQL work area.
    </para>

    <para>
     If <literal>source_cursor_variable</literal> is not open,
     opening <literal>target_cursor_variable</literal> after the assignment
     does not open <literal>source_cursor_variable</literal>.
    </para>

    <para>
     Fetching from Cursor Variable into Collections. For example:
<programlisting>
DECLARE
  TYPE empcurtyp IS REF CURSOR;
  emp_cv  empcurtyp;
  emp_cf empcurtyp;
  item employees%rowtype;
BEGIN
  OPEN emp_cv FOR SELECT * FROM employees WHERE job_id = 'SA_REP' ORDER BY salary DESC;
  OPEN emp_cf FOR SELECT * FROM employees;
  emp_cf := emp_cv;
  LOOP
  	FETCH emp_cf INTO item;
  	DBMS_OUTPUT.PUT_LINE ('Name = ' || item.last_name || ', salary = ' || item.salary);
    EXIT WHEN emp_cf%notfound;
  END LOOP;
  CLOSE emp_cf;
END;
/
</programlisting>
    </para>
  </sect3>

  <sect3 id="plorasql-variable-in-cursor-variable-queries">
   <title>Variables in Cursor Variable Queries</title>

   <para>
    The query associated with a cursor variable can reference any variable in its scope.
   </para>

    <para>
     When you open a cursor variable with the OPEN FOR statement,
     PL/oraSQL evaluates any variables in the query and uses those values when identifying the result set.
     Changing the values of the variables later does not change the result set.
    </para>

    <para>
     Fetching from Cursor Variable into Collections. For example:
<programlisting>
DECLARE
  sal           employees.salary%TYPE;
  sal_multiple  employees.salary%TYPE;
  factor        INTEGER := 2;
 
  cv SYS_REFCURSOR;
 
BEGIN
  OPEN cv FOR
    SELECT salary, salary*factor
    FROM employees
    WHERE job_id LIKE 'AD_%';   -- PL/SQL evaluates factor
 
  LOOP
    FETCH cv INTO sal, sal_multiple;
    EXIT WHEN cv%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE ('factor = ' || factor);
    DBMS_OUTPUT.PUT_LINE ('sal          = ' || sal);
    DBMS_OUTPUT.PUT_LINE ('sal_multiple = ' || sal_multiple);
    factor := factor + 1;  -- Does not affect sal_multiple
  END LOOP;
 
  CLOSE cv;
END;
/
</programlisting>
    </para>

    <para>
     Fetching from Cursor Variable into Collections. For example:
<programlisting>
DECLARE
  sal           employees.salary%TYPE;
  sal_multiple  employees.salary%TYPE;
  factor        INTEGER := 2;
 
  cv SYS_REFCURSOR;
 
BEGIN
  DBMS_OUTPUT.PUT_LINE ('factor = ' || factor);
 
  OPEN cv FOR
    SELECT salary, salary*factor
    FROM employees
    WHERE job_id LIKE 'AD_%';   -- PL/SQL evaluates factor
 
  LOOP
    FETCH cv INTO sal, sal_multiple;
    EXIT WHEN cv%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE ('sal          = ' || sal);
    DBMS_OUTPUT.PUT_LINE ('sal_multiple = ' || sal_multiple);
  END LOOP;
 
  factor := factor + 1;
 
  DBMS_OUTPUT.PUT_LINE ('factor = ' || factor);

  CLOSE cv;
  
  OPEN cv FOR
    SELECT salary, salary*factor
    FROM employees
    WHERE job_id LIKE 'AD_%';   -- PL/SQL evaluates factor
 
  LOOP
    FETCH cv INTO sal, sal_multiple;
    EXIT WHEN cv%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE ('sal          = ' || sal);
    DBMS_OUTPUT.PUT_LINE ('sal_multiple = ' || sal_multiple);
  END LOOP;
 
  CLOSE cv;
END;
/
</programlisting>
    </para>
   </sect3>

   <sect3 id="plorasql-cursor-variable-attributes">
    <title>Cursor Variable Attributes</title>

    <para>
     A cursor variable has the same attributes as an explicit cursor (see Explicit Cursor Attributes.).
     The syntax for the value of a cursor variable attribute is cursor_variable_name immediately
     followed by attribute (for example, cv%ISOPEN).If a cursor variable is not open,
     referencing any attribute except %ISOPEN raises the predefined exception INVALID_CURSOR.
    </para>
   </sect3>
  </sect2>
 </sect1>

  <sect1 id="plorasql-Collections">
   <title>Collections</title>
   <para>
    In a collection, the internal components always have the same data type, and
    are called elements. You can access each element of a collection variable by
    its unique index, with this syntax: <command>variable_name(index)</command>. To create a collection variable,
    you either define a collection type and then create a variable of that type or use <command>%TYPE</command>.
   </para>

   <para>
    A collection type defined in a PL/oraSQL block is a local type. It is available
    only in the block, and is stored in the database only if the block is in a standalone
    or package subprogram.
   </para>

  <para>
     A collection type defined at schema level is a standalone type. You create it
     with the "CREATE TYPE Statement". It is stored in the database until you drop it
     with the "DROP TYPE Statement".
   </para>

   <para>
    A collection type defined in a package specification is a public item. You can
    reference it from outside the package by qualifying it with the package name (package_name.type_name).
    It is stored in the database until you drop the package.
   </para>

   <sect2 id="plorasql-Associative-Arrays">
    <title>Associative Arrays </title>
    <para>
      An <firstterm>associative array</firstterm> is a set of key-value pairs. Each key is a unique index,
      used to locate the associated value with the syntax <command>variable_name(index)</command>.
    </para>

    <para>
      The data type of index can be either a string type (VARCHAR) or INTEGER.
      Indexes are stored in sort order, not creation order.
    </para>

    <para>
      For example, defines a type of <firstterm>associative array</firstterm> indexed by string,
      declares a variable of that type, populates the variable with three elements, changes the value of one element, and prints the values (in sort order, not creation order).
<programlisting>
DECLARE
  -- Associative array indexed by integer:
  TYPE population IS TABLE OF varchar  -- Associative array type
    INDEX BY integer;                  -- indexed by string

  city_population  population;        -- Associative array variable
  i                integer;
BEGIN
  -- Add elements (key-value pairs) to associative array:
  city_population('2')  := 'Smallville';
  city_population('5') := 'Midland';
  city_population('3')  := 'Megalopolis';

  FOR i IN 1..6 LOOP
      IF city_population.EXISTS(i) THEN
          dbms_output.put_line ('city_population(' || i || ')' || ' exists');
      ELSE
          dbms_output.put_line ('city_population(' || i || ')' || ' does not exist');
      END IF;
  END LOOP;

END;
/

</programlisting>
    </para>
   </sect2>

   <sect2 id="plorasql-Nested-Tables">
    <title>Nested Tables </title>
   <para>
    In the database, a nested table is a column type that stores an unspecified number of rows
    in no particular order.
    </para>

    <para>
     When you retrieve a nested table value from the database into a PL/oraSQL nested table variable,
     PL/oraSQL gives the rows consecutive indexes, starting at 1. Using these indexes,
     you can access the individual rows of the nested table variable.
     The syntax is <command>variable_name(index)</command>. The indexes and row order of a nested table
     might not remain stable as you store and retrieve the nested table from the database.
    </para>

    <para>
     The amount of memory that a nested table variable occupies can increase or decrease
     dynamically, as you add or delete elements.
   </para>

   <para>
     Example: Nested Table of Local Type
<programlisting>
DECLARE
TYPE Roster IS TABLE OF VARCHAR(15);  -- nested table type

-- nested table variable initialized with constructor: 
names2 Roster := Roster('D Caruso', 'J Hamil', 'D Piro', 'R Singh');

BEGIN
    DBMS_OUTPUT.PUT_LINE('Initial Values:');
    FOR i IN names2.FIRST .. names2.LAST LOOP  -- For first to last element
      DBMS_OUTPUT.PUT_LINE(names2(i));
    END LOOP;

    DBMS_OUTPUT.PUT_LINE('------------------');
    names2(5) := 'P Perez';  -- add one element
    FOR i IN names2.FIRST .. names2.LAST LOOP  -- For first to last element
      DBMS_OUTPUT.PUT_LINE(names2(i));
    END LOOP;
END;
/
</programlisting>
   </para>

   <para>
    Example: Nested Table of Standalone Type
<programlisting>
CREATE TYPE names2 IS TABLE OF VARCHAR(15);

DECLARE
  nt names2 ;
BEGIN
  nt(1) = 'D Caruso';
  nt(2) = 'J Hamil';
  nt(3) = 'R Singh';
  DBMS_OUTPUT.PUT_LINE(nt(2));
END;
/
</programlisting>
  </para>

   </sect2>

   <sect2 id="plorasql-Collection-Methods">
    <title>Collection Methods </title>
    <para>
      A collection method is a PL/oraSQL subprogram—either a function that returns
      information about a collection or a procedure that operates on a collection.
      Collection methods make collections easier to use and your applications easier to maintain.
    </para>

    <para>
      <xref linkend="Collection-Methods-Table"/> shows collection methods.
    </para>
  
      <table id="Collection-Methods-Table">
       <title>Collection methods</title>
       <tgroup cols="2">
        <thead>
         <row>
          <entry>Method</entry>
          <entry>Description</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry>DELETE</entry>
          <entry>Deletes elements from collection.</entry>
         </row>
         <row>
          <entry>EXTEND</entry>
          <entry>Adds elements to end of nested table.</entry>
         </row>
         <row>
          <entry>EXISTS</entry>
          <entry>Returns TRUE if and only if specified element of nested table exists.</entry>
         </row>
         <row>
          <entry>FIRST</entry>
          <entry>Returns first index in collection.</entry>
         </row>
         <row>
          <entry>LAST</entry>
          <entry>Returns last index in collection.</entry>
         </row>
         <row>
          <entry>COUNT</entry>
          <entry>Returns number of elements in collection.</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

    <para>
      The basic syntax of a collection method invocation is:
      <programlisting>collection_name.method</programlisting>
    </para>
   </sect2>
  </sect1>

  <sect1 id="plorasql-transactions">
   <title>Transaction Management</title>

   <para>
    In procedures invoked by the <command>CALL</command> command
    as well as in anonymous code blocks,
    it is possible to end transactions using the
    commands <command>COMMIT</command> and <command>ROLLBACK</command>.  A new
    transaction is started automatically after a transaction is ended using
    these commands, so there is no separate <command>START
    TRANSACTION</command> command.  (Note that <command>BEGIN</command> and
    <command>END</command> have different meanings in PL/oraSQL.)
   </para>

   <para>
    Here is a simple example:
<programlisting>
CREATE OR REPLACE PROCEDURE transaction_test1(b int) IS
BEGIN
    FOR i IN 0..9 LOOP
        INSERT INTO test1 (a) VALUES (i);
        IF i &lt; b THEN
            COMMIT;
        ELSE
            ROLLBACK;
        END IF;
    END LOOP;
END;
/

CALL transaction_test1(3);
</programlisting>
   </para>

    <sect2 id="plorasql-operations-cursor-with-transcations">
    <title>Operations Cursor With Transcations</title>

      <para>
      This summary mainly introduces the combination of cursor operations and transaction operations (commit and rollback).
      Specifically divided into the following five categories:

      <itemizedlist>
      <listitem>
        <para>
        Function
        <itemizedlist>
        <listitem>
          <para>
           Call function in function: not supported.
          </para>
        </listitem>
        <listitem>
          <para>
           Function call process: not supported.
          </para>
        </listitem>
        <listitem>
          <para>
           Functions and stored procedures in the function package:
            <itemizedlist>
            <listitem>
              <para>
               Transfer function: not supported;
              </para>
            </listitem>
            <listitem>
              <para>
               Package adjustment process: not supported.
              </para>
            </listitem>
            </itemizedlist>
           </para>
        </listitem>
        </itemizedlist>
        </para>
      </listitem>
      <listitem>
        <para>
        Stored procedure
        <itemizedlist>
        <listitem>
          <para>
           Calling a function in a stored procedure: not supported.
          </para>
        </listitem>
        <listitem>
          <para>
           Stored procedure call procedure: support.
          </para>
        </listitem>
        <listitem>
          <para>
           Functions and stored procedures in the package are called in the stored procedure:
            <itemizedlist>
            <listitem>
              <para>
               Transfer function: not supported;
              </para>
            </listitem>
            <listitem>
              <para>
               Package adjustment process: not supported.
              </para>
            </listitem>
            </itemizedlist>
           </para>
        </listitem>
        </itemizedlist>
        </para>
      </listitem> 
      <listitem>
        <para>
        Anonymous block
        <itemizedlist>
        <listitem>
          <para>
           Call function in anonymous block: not supported.
          </para>
        </listitem>
        <listitem>
          <para>
           Anonymous block mid-tuning process: support.
          </para>
        </listitem>
        <listitem>
          <para>
           Functions and stored procedures in the call package in the anonymous block:
            <itemizedlist>
            <listitem>
              <para>
               Transfer function: not supported;
              </para>
            </listitem>
            <listitem>
              <para>
               Package adjustment process: not supported.
              </para>
            </listitem>
            </itemizedlist>
           </para>
        </listitem>
        </itemizedlist>
        </para>
      </listitem>
      <listitem>
        <para>
        Functions in the package
        <itemizedlist>
        <listitem>
          <para>
           Package function call function: not supported.
          </para>
        </listitem>
        <listitem>
          <para>
           Package function call stored procedure: not supported.
          </para>
        </listitem>
        <listitem>
          <para>
           The package function calls the functions and stored procedures in the package:
            <itemizedlist>
            <listitem>
              <para>
               Transfer function: not supported;
              </para>
            </listitem>
            <listitem>
              <para>
               Package adjustment process: not supported.
              </para>
            </listitem>
            </itemizedlist>
           </para>
        </listitem>
        </itemizedlist>
        </para>
      </listitem>
      <listitem>
        <para>
        Stored Procedures in Packages
        <itemizedlist>
        <listitem>
          <para>
           Package stored procedure caller: not supported.
          </para>
        </listitem>
        <listitem>
          <para>
           Package stored procedure call stored procedure: support.
          </para>
        </listitem>
        <listitem>
          <para>
           Package stored procedures transfer functions and stored procedures in packages:
            <itemizedlist>
            <listitem>
              <para>
               Transfer function: not supported;
              </para>
            </listitem>
            <listitem>
              <para>
               Package adjustment process: not supported.
              </para>
            </listitem>
            </itemizedlist>
           </para>
        </listitem>
        </itemizedlist>
        </para>
      </listitem>
      </itemizedlist>
      </para>

    <tip>
     <para>
      Cursor operations and transaction operations (commit and rollback) are used in combination,
      and the value of lightdb_dblevel_syntax_compatible_type is oracle
      and search_path need to be set as follows:
      SET search_path TO public, oracle;
     </para>
    </tip>

    <tip>
     <para>
      Calling functions in the same way as stored procedures is not supported in anonymous blocks,
      such as:
     <programlisting>
create or replace function func return int as
begin
  dbms_output.put_line ('This is just a test');
end;
/

begin
  func();
  dbms_output.put_line ('This is just a test');
end;
/
     </programlisting>
     </para>
    </tip>

    <tip>
     <para>
      Package Notes on Cursor Declarations and Definitions:
      <itemizedlist>
       <listitem>
       <para>
        When declaring a package, the cursor cannot be declared directly in the package;
       </para>
       </listitem>
       <listitem>
       <para>
        When defining a package body, you cannot define a cursor variable directly in the global area of the package body.
      </para>
      </listitem>
      </itemizedlist>
     </para>
    </tip>

    <tip>
     <para>
      Currently stored procedures and plugin auto_explain cannot be used together.
     </para>
    </tip>
  
    <para>
    Example: Stored procedure call procedure
    <programlisting>

--preconditional
-- the value of lightdb_dblevel_syntax_compatible_type must be oracle
create extension IF NOT EXISTS orafce;
SET search_path TO public, oracle;

create table ltbench_accounts(id int, abalance int);

--insert
declare
  irevert int := 9999;
  icount int := 1000;
begin
  loop
    execute immediate 'insert into ltbench_accounts values(:er,:rt)' using irevert, icount;
    icount := icount - 1;
    irevert := irevert -1;
    exit when icount &lt; 1;
  end loop;
end;
/

--commit、rollback
create or replace procedure tt_try_proc as
  CURSOR c1 IS
      SELECT * FROM ltbench_accounts;

  CURSOR c2 IS
      SELECT * FROM ltbench_accounts;

  emp_rec  ltbench_accounts%ROWTYPE;
BEGIN
  OPEN c2;
  OPEN c1;
  UPDATE ltbench_accounts SET id = 25 WHERE abalance = 12;
  rollback;
  UPDATE ltbench_accounts SET id = 17 WHERE abalance = 13;
  commit;
  LOOP
    FETCH c1 INTO emp_rec;
    EXIT WHEN c1%NOTFOUND;
    dbms_output.put_line ('emp_rec.id = ' || emp_rec.id || 'emp_rec.abalance = ' || emp_rec.abalance);
    UPDATE ltbench_accounts SET id = 23 WHERE abalance = 12;
    rollback;
  END LOOP;
  LOOP
    FETCH c2 INTO emp_rec;
    EXIT WHEN c2%NOTFOUND;
    dbms_output.put_line ('emp_rec.id = ' || emp_rec.id || 'emp_rec.abalance = ' || emp_rec.abalance);
    UPDATE ltbench_accounts SET id = 18 WHERE abalance = 13;
    commit;
  END LOOP;
  commit;
  rollback;
END;
/

--call procedure in procedure
create or replace procedure tt_try_dproc as
begin
  tt_try_proc();
  dbms_output.put_line ('This is just a test');
end;
/

call tt_try_dproc();
    </programlisting>
    </para>

    <para>
    Example: stored procedures in the package are called in the stored procedure
    <programlisting>
--preconditional
create table test(x int, y varchar(100));
insert into test values(1, 'One');
insert into test values(2, 'Two');
insert into test values(3, 'Three');

--create package
create or replace package pkg is
  CURSOR c1 IS SELECT x,y FROM test;
  function c_open return int;
  function c_fetch return int;
  procedure c_open_fetch;
end;
/

--create package boby
create or replace package body pkg IS
  function c_open return int as
  begin
    OPEN c1;
    return 0;
  end;

--The fetch in the package, the cursor will not be cleared
  function c_fetch return int AS
    v_x  test.x%TYPE;
    v_y  test.y%TYPE;
  begin
    LOOP
      FETCH c1 INTO v_x, v_y;
      EXIT WHEN c1%NOTFOUND;
      dbms_output.put_line( v_x || '.' || v_y);
    END LOOP;
    --CLOSE c1;
    return 0;
  end;

  procedure c_open_fetch as
    v_x  test.x%TYPE;
    v_y  test.y%TYPE;
  BEGIN
    OPEN c1;
    COMMIT;
    LOOP
      FETCH c1 INTO v_x, v_y;
      EXIT WHEN c1%NOTFOUND;
      dbms_output.put_line( v_x || '.' || v_y);
      IF c1%FOUND THEN
        UPDATE test SET x = 4 WHERE y = 'Two';
        ROLLBACK;
      END IF;
    END LOOP;
    CLOSE c1;
  end;


begin
  dbms_output.put_line('initializer');
    --same as oracle, package not support dml, commit and roolback.
    --UPDATE test SET x = 5 WHERE y = 'Two';
    --COMMIT;
end;
/

--procedure of package callled by procedure
create or replace procedure tt_try_proc as
begin
  pkg.c_open_fetch();
  dbms_output.put_line ('This is just a test');
end;
/

call tt_try_proc();
    </programlisting>
    </para>

    <para>
    Example: Anonymous block mid-tuning process
    <programlisting>

begin
  tt_try_proc();
end;
/
    </programlisting>
    </para>

    <para>
    Example: stored procedures in the call package in the anonymous block
    <programlisting>

--procedure of package called by anonymous block
begin
  pkg.c_open_fetch();
  dbms_output.put_line ('This is just a test');
end;
/
    </programlisting>
    </para>

    <para>
    Example: Package stored procedure call stored procedure
    <programlisting>

--create package
create or replace package pkg_proc is
  CURSOR c1 IS SELECT x,y FROM test;
  procedure c_proc;
end;
/

--create package boby
create or replace package body pkg_proc IS
  procedure c_proc as
    v_x  test.x%TYPE;
    v_y  test.y%TYPE;
  BEGIN
    OPEN c1;
    COMMIT;
    LOOP
      tt_try_proc();
      FETCH c1 INTO v_x, v_y;
      EXIT WHEN c1%NOTFOUND;
      dbms_output.put_line( v_x || '.' || v_y);
      IF c1%FOUND THEN
        UPDATE test SET x = 4 WHERE y = 'Two';
        ROLLBACK;
      END IF;
    END LOOP;
    CLOSE c1;
  end;

begin
  dbms_output.put_line('initializer');
    --same as oracle, package not support dml, commit and roolback.
    --UPDATE test SET x = 5 WHERE y = 'Two';
    --COMMIT;
end;
/

call pkg_proc.c_proc();

    </programlisting>
    </para>

   <para>
    Example: Package stored procedures transfer stored procedures in packages
    <programlisting>

--procedure of package called by procedure of package
--create package of pkg_proc
create or replace package pkg_proc is
  CURSOR c1 IS SELECT x,y FROM test;
  procedure c_proc;
end;
/

--create package boby of pkg_proc
create or replace package body pkg_proc IS
  procedure c_proc as
    v_x  test.x%TYPE;
    v_y  test.y%TYPE;
  BEGIN
    OPEN c1;
    COMMIT;
    LOOP
      FETCH c1 INTO v_x, v_y;
      EXIT WHEN c1%NOTFOUND;
      dbms_output.put_line( v_x || '.' || v_y);
      IF c1%FOUND THEN
        UPDATE test SET x = 4 WHERE y = 'Two';
        ROLLBACK;
      END IF;
    END LOOP;
    CLOSE c1;
  end;


begin
  dbms_output.put_line('initializer');
    --same as oracle, package not support dml, commit and roolback.
    --UPDATE test SET x = 5 WHERE y = 'Two';
    --COMMIT;
end;
/

--create package of pkg_call_proc
create or replace package pkg_call_proc is
  CURSOR c1 IS SELECT x,y FROM test;
  procedure c_call_proc;
end;
/

--create package boby of pkg_call_proc
create or replace package body pkg_call_proc IS
   procedure c_call_proc as
    v_x  test.x%TYPE;
    v_y  test.y%TYPE;
  BEGIN
    OPEN c1;
    COMMIT;
    LOOP
      pkg_proc.c_proc();
      FETCH c1 INTO v_x, v_y;
      EXIT WHEN c1%NOTFOUND;
      dbms_output.put_line( v_x || '.' || v_y);
      IF c1%FOUND THEN
        UPDATE test SET x = 4 WHERE y = 'Two';
        ROLLBACK;
      END IF;
    END LOOP;
    CLOSE c1;
  end;


begin
  dbms_output.put_line('initializer');
    --same as oracle, package not support dml, commit and roolback.
    --UPDATE test SET x = 5 WHERE y = 'Two';
    --COMMIT;
end;
/

call pkg_call_proc.c_call_proc();
    </programlisting>
    </para>

   <para>
    Example: When declaring a package, the cursor cannot be declared directly in the package
    <programlisting>

--Declare cursors in packages using sys_refcursor
--error
create or replace package pkg is
  c1 sys_refcursor;
  function c_open return int;
  function c_fetch return int;
  procedure c_open_fetch;
end;
/
    </programlisting>
    </para>

   <para>
    Example: When defining a package body, you cannot define a cursor variable directly
    in the global area of the package body
    <programlisting>

--Declare the cursor in the package body  using sys_refcursor
create or replace package pkg is
	function c_open return int;
	function c_fetch return int;
	procedure c_open_fetch;
end;
/

--error
create or replace package body pkg IS
  c1 sys_refcursor;
  function c_open return int as
  begin
    OPEN c1 for SELECT x,y FROM test;
    return 0;
  end;


  function c_fetch return int AS
    v_x  test.x%TYPE;
    v_y  test.y%TYPE;
  begin
    LOOP
      FETCH c1 INTO v_x, v_y;
      EXIT WHEN c1%NOTFOUND;
      dbms_output.put_line( v_x || '.' || v_y);
    END LOOP;
    --CLOSE c1;
    return 0;
  end;

  procedure c_open_fetch as
    v_x  test.x%TYPE;
    v_y  test.y%TYPE;
  BEGIN
    OPEN c1 for SELECT x,y FROM test;
    COMMIT;
    LOOP
      FETCH c1 INTO v_x, v_y;
      EXIT WHEN c1%NOTFOUND;
      dbms_output.put_line( v_x || '.' || v_y);
      IF c1%FOUND THEN
        UPDATE test SET x = 4 WHERE y = 'Two';
        ROLLBACK;
      END IF;
      END LOOP;
    CLOSE c1;
  end;

begin
  dbms_output.put_line('initializer');
    --same as oracle, package not support dml, commit and roolback.
    --UPDATE test SET x = 5 WHERE y = 'Two';
    --COMMIT;
end;
/
    </programlisting>
    </para>
    </sect2>
   </sect1>

  <sect1 id="plorasql-packages">
   <title>Packages</title>
    <para>
    This section journeys into the “Oracle Style Package” for LightDB. A package, by very definition, 
    is an object or a group of objects packed together. In terms of databases, 
    this translates into a named schema object that packages within itself a logically grouped 
    collection of procedures, functions, variables, cursors, user-defined record types, 
    and reference records.
    </para>

    <sect2 id="plorasql-package-overview">
    <title>Package Overview</title>
      <sect3>
        <title>The Need for Packages</title>
        <para>
        Like similar constructs in various other programming languages, 
        there are good reasons for using packages with SQL. In this section, 
        we are going to cover a few.
        </para>

        <para>
        <itemizedlist>
      <listitem>
        <para>
        Reliability and Reusability of Code Packages provide the ability to create modular objects
         that encapsulate code. This makes the overall design and implementation simpler. 
         The ability to encapsulate variables, related types, stored procedures/functions, 
         and cursors, essentially allows creating a self-contained module that is simple 
         and easy to understand, maintain and use. Encapsulation comes into play through 
         the exposure of a package interface, rather than its implementation details, 
         i.e., package body. This, therefore, benefits in many ways. 
         Furthermore it allows applications and users to refer to a consistent interface 
         and not worry about the contents of its body. Also, it prevents users from making 
         any decisions based on code implementation as that’s never exposed to them.
        </para>
      </listitem>
      <listitem>
        <para>
        Ease of Use The ability to create a consistent functional interface in LightDB 
        helps simplify application development by allowing the compilation of packages
         without their bodies. Beyond the development phase, the package allows a 
         user to manage access control on the entire package rather than individual objects. 
         This is rather valuable especially if the package contains lots of schema objects.
        </para>
      </listitem>
      <listitem>
        <para>
        Performance Packages are loaded into memory for maintenance and therefore 
        utilize minimal I/O resources. Recompilation is simple and only limited to object(s) changed; 
        dependent objects are not recompiled.
        </para>
      </listitem>
      <listitem>
        <para>
        Additional Features In addition to performance and ease of use, 
        packages offer session-wide persistence for variables and cursors. 
        This means variables and cursors have the same lifetime as a database session 
        and are destroyed when the session is destroyed.
        </para>
      </listitem>
      </itemizedlist>
      </para>
      </sect3>

       <sect3>
        <title>Package Components</title>
        <para>
        Package consists of two components. Package specification and Package body.
        </para>

        <para>
        Package Specification Any object within the package that is to be 
        used from the outside is specified in the package specification section. 
        This is the publicly accessible interface we have been referring to 
        in earlier sections. It does not contain the definition or 
        implementation of them, i.e. the functions and the procedures. 
        It only has their headers defined without the body definitions. 
        The variables can be initialized. The following is the list of objects
         that can be listed in the package specification:
      <itemizedlist>
     <listitem>
      <para>
       Functions
      </para>
     </listitem>
     <listitem>
      <para>
       Procedures
      </para>
     </listitem>
     <listitem>
      <para>
       Cursors
      </para>
     </listitem>
     <listitem>
      <para>
       Types
      </para>
     </listitem>
     <listitem>
      <para>
       Variables
      </para>
     </listitem>
     <listitem>
      <para>
       Record types
      </para>
     </listitem>
     <listitem>
      <para>
       Associative Arrays
      </para>
     </listitem>
     <listitem>
      <para>
       Nested Tables
      </para>
     </listitem>
    </itemizedlist>
        </para>

        <para>
        Package Body the body contains all the implementation code of a package, 
        including the public interfaces and the private objects. 
        A package body is optional if the specification does not contain any 
        subprogram or cursor.
        </para>
        <para>
        It must contain the definition of the subprograms 
        declared in specification and the corresponding definitions must match.
        </para>
        <para>
        A package body can contain its own subprogram and type declarations of 
        any internal objects not specified in the specifications. 
        These objects are then considered private. Private objects 
        cannot be accessed from outside the package.
        </para>
        <para>
        In addition to subprogram definitions, it can optionally contain a 
        initializer block that initializes the variables declared in 
        specification and is executed only once when the first call to 
        the package is made in a session.
        </para>
      </sect3>
    </sect2>

    <sect2 id="plorasql-create-package">
    <title>Create Package</title>
      <sect3>
        <title>CREATE PACKAGE</title>
        <para>
        CREATE PACKAGE —— Define a new package specification.
        </para>
        <para>
        <literal>Syntax</literal>
        </para>
        <para>
        <screen>
CREATE [ OR REPLACE ] PACKAGE [schema.]package_name  [IS | AS] 
   item_list[, item_list ...]
END [package_name];
 

 
item_list: 
[
   function_declaration    | 
   procedure_declaration   | 
   type_definition         | 
   cursor_declaration      | 
   item_declaration
]
 
 
function_declaration:
     FUNCTION function_name [(parameter_declaration[, ...])] RETURN datatype;
 
procedure_declaration:
     PROCEDURE procedure_name [(parameter_declaration[, ...])]
 
type_definition:
     record_type_definition      |
     ref_cursor_type_definition
 
cursor_declaration:
   CURSOR name [(cur_param_decl[, ...])] RETURN rowtype;
 
item_declaration:
     cursor_declaration             |
     cursor_variable_declaration    |
     record_variable_declaration    |
     variable_declaration           |
 
record_type_definition:
   TYPE record_type IS RECORD  ( variable_declaration [, variable_declaration]... ) ;
 
ref_cursor_type_definition:
   TYPE type IS REF CURSOR [ RETURN type%ROWTYPE ];
 
cursor_variable_declaration:
   curvar curtype;
 
record_variable_declaration:
   recvar { record_type | rowtype_attribute | record_type%TYPE };
 
variable_declaration:
   varname datatype [ [ NOT NULL ] := expr ]
 
parameter_declaration:
   parameter_name [IN] datatype [[:= | DEFAULT] expr]
</screen>
</para>

        <para>
        <literal>Description</literal>
        </para>

        <para>
        Creates the package specification that contains public declarations. 
        The declared items in the package specification are accessible from 
        anywhere in the package and to any other subprograms in the same database.
        </para>
        <para>
        CREATE PACKAGE defines a new package. CREATE OR REPLACE PACKAGE 
        will either create a new package or replace an existing definition.
        </para>
        <para>
        If a schema name is included, then the package is created in the specified schema. 
        Otherwise, it is created in the current schema. The name of the new package 
        must be unique within the schema.
        </para>
        <para>
        When CREATE OR REPLACE PACKAGE is used to replace an existing package, 
        the ownership and permissions of the package do not change. All other package 
        properties are assigned the values specified or implied in the command. 
        Only the owner and member of the owning roles are allowed to replace the packages.
        </para>
        <para>
        The user that creates the package becomes the owner of the package.
        </para>
      </sect3>


      <sect3>
        <title>CREATE PACKAGE BODY</title>
        <para>
        CREATE PACKAGE BODY —— Define a new package definition.
        </para>
        <para>
        <literal>Syntax</literal>
        </para>

        <para>
        <screen>
CREATE [ OR REPLACE ] PACKAGE BODY [schema.]package_name [IS | AS]
   [item_list[, item_list ...]] | 
   item_list_2 [, item_list_2 ...]
   [initialize_section]
END [package_name];
 
 
initialize_section:
   BEGIN statement[, ...]
 
item_list: 
[
   function_declaration    | 
   procedure_declaration   | 
   type_definition         | 
   cursor_declaration      | 
   item_declaration
]
 
item_list_2:
[
   function_declaration
   function_definition
   procedure_declaration
   procedure_definition
   cursor_definition
]
 
function_definition:
   FUNCTION function_name [(parameter_declaration[, ...])] RETURN datatype  [IS | AS]
   [declare_section] body;
 
procedure_definition:
   PROCEDURE procedure_name [(parameter_declaration[, ...])] [IS | AS] 
   [declare_section] body;
 
cursor_definition:
   CURSOR name [(cur_param_decl[, ...])] RETURN rowtype IS select_statement;
 
body:
   BEGIN statement[, ...] END [name];
 
statement:
   [LABEL] pl_statments[, ...];

        </screen>
        </para>
        <para>
        <literal>Description</literal>
        </para>
        <para>
        CREATE PACKAGE BODY defines the package body for a package. 
        CREATE OR REPLACE PACKAGE body will either create a new package body 
        for the package or replace an existing package body definition. 
        Package specification must be created first to create the package body. 
        The package body contains the implementation of every cursor and 
        subprogram declared in the package specification created through “CREATE PACKAGE”. 
        objects defined in a package body are only accessible to outside the package 
        if their specification is listed in the package specification. 
        For all objects that are only defined in the package body and 
        are not included in the package specification, they become private members
         to the package and are not accessible outside of the package. 
         Both the package and its body must be created in the same schema.
        </para>
        </sect3>

        <sect3>
        <title>Parameters</title>
        <para>
        <varname>package_name</varname> The name (optionally schema-qualified) of the package to create.
        </para>
        <para>
        <varname>item_list</varname> This is the list of items that can be part of a package.
        </para>
        <para>
        <varname>procedure_declaration</varname> The procedure signature, i.e. procedure_name(argument_list ). 
        procedure_declaration can appear in both package specification and package body.
         Procedure declarations listed in the Package specification makes the procedure
          public and accessible from outside of the package. While the procedure declared
           in the package body is considered as a forward declaration and becomes 
           a private member to the package.
        </para>
        <para>
        <varname>procedure_definition</varname> Implementation/definition of the package procedure. 
        procedure_definition can only be provided in the package body. 
        Procedure access specifier is determined by procedure declaration 
        and the procedures defined in the package body without corresponding
         declaration automatically becomes private to the package.
        </para>
        <para>
        <varname>function_declaration</varname> The function signature and it’s return type, 
        i.e. function_name(argument_list) RETURN return_type;.
        </para>
        <para>
        function_declaration can appear in both package specification and package body. 
        Function declarations listed in the Package specification makes the function
         public and accessible from outside the package. While the function 
         declaration in the package body is considered as a forward declaration 
         and becomes a private member to the package.
        </para>
        <para>
        <varname>function_definition</varname> Implementation/definition of the package function.
         function_definition can only be provided in the package body. 
         Function access specifier is determined by function declaration 
         and the function defined in the package body without corresponding 
         declaration automatically becomes private to the package.
        </para>
        <para>
        <varname>type_definition</varname> Either a RECORD, or CURSOR type definition.
        </para>
        <para>
        <varname>cursor_declaration</varname> CURSOR declaration along with its arguments and return type as the desired ROWTYPE.
        </para>
        <para>
        <varname>item_declaration</varname> Allows declaration of: Cursors, Cursor variables, Record variable, Variables.
        </para>
        <para>
        <varname>parameter_declaration</varname> Defines the syntax for declaring a parameter. 
        The keyword “IN” if specified indicates that this is an input parameter.
         The DEFAULT keyword followed by an expression (or value) may only be specific 
         for an input parameter.
        </para>
        <para>
        <varname>declare_section</varname> This contains all the elements that are local to the function 
        or procedure and can be referenced within its body.
        </para>
        <para>
        <varname>body</varname> The body consists of the SQL statements or PL control structures 
        that are supported by plorasql language.
        </para>
        </sect3>
    </sect2>
    <sect2 id="plorasql-create-access-package">
    <title>Create and Access Packages</title>
    <sect3>
    <title>Create Packages</title>
        <para>
     In the previous sections, we have gone through the syntax 
     that dictates the structure of a package. In this section, 
     we are going to take this a step further by understanding the
      construction process of a package and how we can access its public elements.
    </para>
    <para>
    As a package is created, LightDB will compile it and report 
    any issues it may find. Once the package is successfully compiled, 
    it becomes ready for use.
    </para>
    </sect3>

    <sect3>
    <title>Accessing Package Elements</title>
    <para>
    A package is instantiated and initialized when it is referenced for the first time 
    in a session. The following actions are performed in the same order during this process:
    <itemizedlist>
     <listitem>
      <para>
       Assignment of initial values to public variables
      </para>
     </listitem>
     <listitem>
      <para>
       Execution of the initializer block of the package
      </para>
     </listitem>
     </itemizedlist>
    </para>

    <para>
    There are several ways to access package elements:
          <itemizedlist>
     <listitem>
      <para>
       Package functions can be utilized just as any other function in a SELECT statement 
       or from other PL blocks
      </para>
     </listitem>
     <listitem>
      <para>
       Package procedure can be invoked directly using CALL or from other PL blocks
      </para>
     </listitem>
          <listitem>
      <para>
       Package variables can be directly read and written using the package name qualification in a PL block.
      </para>
     </listitem>
     <listitem>
      <para>
       Direct Access Using Dot Notation: In the dot notation, 
       elements can be accessed in the following manner:
             <itemizedlist>
     <listitem>
      <para>
       package_name.func('foo');
      </para>
     </listitem>
     <listitem>
      <para>
       package_name.proc('foo');
      </para>
     </listitem>
          <listitem>
      <para>
       package_name.variable;
      </para>
     </listitem>
     </itemizedlist>
     These statements can be used from inside a PL block or 
     in a SELECT statement if the element is a function.
      </para>
     </listitem>
     <listitem>
     <para>
     SQL Call Statement: Another way is to use the CALL statement. 
     The CALL statement executes a standalone procedure in a type or package. 
      <itemizedlist>
      <listitem>
      <para>
      CALL package_name.proc('foo');
      </para>
      </listitem>
      </itemizedlist>
     </para>
     </listitem>
     </itemizedlist>

    </para>
    </sect3>

    <sect3>
    <title>Understanding Scope of Visibility</title>
    <para>
    The scope of variables declared in a PL/oraSQL block is limited to that block. 
    If it has nested blocks, then it will be a global variable to the nested blocks.
    </para>
    <para>
    Similarly, if both blocks declare the same name variable, 
    then inside of the nested block, its own declared variable is
     visible and the parent one becomes invisible. 
     To access the parent variable, that variable must be fully qualified.
    </para>
    <para>
    Consider the following code snippet.
    </para>
    <para>
    Example: Visibility and Qualifying Variable Names
    <programlisting>
    
-- blk_1
DECLARE
   x INT;
   y INT;
BEGIN
   -- both blk_1.x and blk_1.y are visible
   -- blk_2
   DECLARE
      x INT;
      z INT;
   BEGIN
      -- blk_2.x, y and z are visible
      -- to access blk_1.x it has to be a qualified name. blk_1.x := 0; NULL;
      NULL;
   END;
   -- both x and y are visible
END;
/
    </programlisting>
    </para>

    <para>
    The above example shows how you must fully qualify a variable name 
    in case a nested package contains a variable with the same name.
    </para>

    <para>
		Variable name qualification helps in resolving possible confusion 
		that gets introduced by scope precedence in the following scenarios:
		 <itemizedlist>
			  <listitem>
			  <para>
			  Package and nested packages variables: without qualification, nested takes precedence
			  </para>
			  </listitem>
			 <listitem>
			  <para>
			  Package variable and column names: without qualification, column name takes precedence
			  </para>
			  </listitem>
			  <listitem>
			  <para>
			  Function or procedure variable and package variable: 
			  without qualification, package variable takes precedence.
			  </para>
			  </listitem>
		 </itemizedlist>
    </para>

    </sect3>

    </sect2>

    <sect2 id="plorasql-package-examples">
    <title>Examples</title>
  <para>
   create package example.
<programlisting>
CREATE TABLE test(x INT, y VARCHAR2(100));
create table rectype(a int,b varchar2(100));
INSERT INTO test VALUES (1, 'One');
INSERT INTO test VALUES (2, 'Two');
INSERT INTO test VALUES (3, 'Three');

CREATE OR REPLACE PACKAGE example
AS
   -- Declare type, cursor:
   CURSOR curtype RETURN rectype%rowtype;
 
   rec rectype%rowtype;
 
   -- Declare subprograms:
   FUNCTION somefunc (v int) RETURN NUMBER;
 
   -- Overload preceding subprogram:
   PROCEDURE xfunc (emp_id NUMBER);
   PROCEDURE xfunc (emp_email VARCHAR2);
END;
/
</programlisting>
</para>
    <para>
    create package body example.
    <programlisting>
CREATE OR REPLACE PACKAGE BODY example
AS
   nelems NUMBER; -- variable in this package

   -- Define cursor declared in package specification:
   CURSOR curtype RETURN rectype%rowtype IS SELECT x, y FROM test ORDER BY x;
   -- Define subprograms declared in package specification: 
   FUNCTION somefunc (v int) RETURN NUMBER
   IS
       id NUMBER := 0;
	   BEGIN
	     OPEN curtype;
            FETCH curtype INTO rec;
         RETURN rec.a;
     END;
 
   PROCEDURE xfunc (emp_id NUMBER) IS
   BEGIN
      NULL;
   END;
 
   PROCEDURE xfunc (emp_email VARCHAR2) IS
   BEGIN
      NULL;
   END;
 
END;
/
    </programlisting>
    </para>

    </sect2>

    <sect2 id="plorasql-package-limitations">
    <title>Limitations</title>
    <para>
     Record types are supported as package variables, however they can only be used
      within package elements i.e., Package function/procedure can utilize them.
       They can not be accessed outside the package.
    </para>

    </sect2>

   </sect1>

  <sect1 id="plorasql-tablefunction">
   <title>Table function</title>
    <para>
    A table function is a function that can be invoked inside the FROM clause 
    of a SELECT statement. They return collections (usually nested tables or varrays, 
    current only support nested tables), which can then be transformed with the 
    TABLE clause into a dataset of rows and columns that can be processed 
    in a SQL statement. 
    </para>

    <para>
    Another explanation of table functions are functions that produce a collection of 
    rows (either a nested table or a varray, only support nested tables current) 
    that can be queried like a physical database table. You use a table function 
    like the name of a database table, in the FROM clause of a query. Example as follows:
<programlisting>
create table t1(a int, b int);
insert into t1 (values (1,1), (2,2), (3,3));

create or replace package pkg
as
	type nt is table of t1%rowtype;
	res nt;
	function myfunc() return nt;
end;
/

create or replace package body pkg
as
	function myfunc() return nt
	is
	begin
		res(1) := ROW(1,1);
		res(2) := ROW(2,2);
		res(3) := ROW(3,3);
		return res;
	end;
end;
/

select * from table(pkg.myfunc());

</programlisting>
    Notice, pipelined table function is not support.
    </para>


  </sect1>

 <sect1 id="plorasql-error-handling">
   <title>Error Handling</title>
    <para>
     This chapter explains how to handle <application>PLoraSQL</application> compile-time warnings
     and <application>PLoraSQL</application> runtime errors.
     The latter are called exceptions.
    </para>

  <sect2 id="plorasql-exception-handling">
   <title>Overview of Exception Handling</title>

    <para>
     Exceptions (<application>PLoraSQL</application> runtime errors) can arise from design faults,
     coding mistakes, hardware failures, and many other sources. You cannot anticipate all possible exceptions,
     but you can write exception handlers that let your program to continue to operate in their presence.
    </para>

    <para>
     Any <application>PLoraSQL</application> block can have an exception-handling part,
     which can have one or more exception handlers. For example,
     an exception-handling part could have this syntax:

<synopsis>
EXCEPTION
  WHEN ex_name_1 THEN statements_1                 -- Exception handler
  WHEN ex_name_2 OR ex_name_3 THEN statements_2    -- Exception handler
  WHEN OTHERS THEN statements_3                    -- Exception handler
END;
</synopsis>

     When an exception is raised in the executable part of the block,
     the executable part stops and control transfers to the exception-handling part.
     If ex_name_1 was raised, then statements_1 run. If either ex_name_2 or ex_name_3 was raised,
     then statements_2 run. If any other exception was raised, then statements_3 run.
    </para>

    <para>
     After an exception handler runs, control transfers to the next statement of the enclosing block.
     If there is no enclosing block, then:

    <itemizedlist>
     <listitem>
      <para>
       If the exception handler is in a subprogram, then control returns to the invoker,
       at the statement after the invocation
      </para>
     </listitem>
     <listitem>
      <para>
       If the exception handler is in an anonymous block,
       then control transfers to the host environment
      </para>
     </listitem>
    </itemizedlist>
    </para>

   <sect3>
    <title>Exception Categories</title>

    <para>
     The exception categories are:

    <itemizedlist>
     <listitem>
      <para>
       <literal>Internally defined</literal>
       The runtime system raises internally defined exceptions implicitly (automatically)
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>Predefined</literal>
       A predefined exception is an internally defined exception
       that <application>PLoraSQL</application> has given a name
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>User-defined</literal>
       You can declare your own exceptions in the declarative part of
       any <application>PLoraSQL</application> anonymous block, subprogram, or package
      </para>
     </listitem>
    </itemizedlist>
    </para>   
   </sect3>

   <sect3>
    <title>Advantages of Exception Handlers</title>

    <para>
     Using exception handlers for error-handling makes programs easier to write and understand,
     and reduces the likelihood of unhandled exceptions.
     Without exception handlers, you must check for every possible error,
     everywhere that it might occur, and then handle it.
     It is easy to overlook a possible error or a place where it might occur,
     especially if the error is not immediately detectable.
     Error-handling code is scattered throughout the program.
     With exception handlers, you need not know every possible error or everywhere that it might occur.
     You need only include an exception-handling part in each block where errors might occur.
     In the exception-handling part, you can include exception handlers for both specific and unknown errors.
     If an error occurs anywhere in the block (including inside a sub-block),
     then an exception handler handles it. Error-handling code is isolated in the exception-handling parts of the blocks.
    </para>


    <para>
     Currently <application>PLoraSQL</application> only supports predefined errors.
    </para>
   </sect3>
  </sect2>

  <sect2 id="plorasql-predefined-exception">
   <title>Predefined Exceptions</title>

    <para>
     Predefined exceptions are internally defined exceptions that have predefined names.
     The runtime system raises predefined exceptions implicitly (automatically).
     Because predefined exceptions have names, you can write exception handlers specifically for them.
    </para>

    <para>
     There are 7 predefined errors currently supported:

    <itemizedlist>
     <listitem>
      <para>
       <literal>INVALID_CURSOR</literal>
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>CASE_NOT_FOUND</literal>
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>DUP_VAL_ON_INDEX</literal>
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>NOT_DATA_FOUND</literal>
      </para>
     </listitem>
       <listitem>
      <para>
       <literal>TOO_MANY_ROWS</literal>
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>ZERO_DIVIDE</literal>
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>LOGIN_DENIED</literal>
      </para>
     </listitem>
    </itemizedlist>
    </para>
    <sect3>
    <title>INVALID_CURSOR</title>

    <para>
     INVALID_CURSOR mainly contend for two situations: explicit cursor and cursor variables.
    </para>

    <sect4>
     <title>Explicit Cursor</title>

    <para>
    <itemizedlist>
     <listitem>
      <para>
       You close an open explicit cursor with the CLOSE statement,
       thereby allowing its resources to be reused. After closing a cursor,
       you cannot fetch records from its result set or reference its attributes.
       If you try, <application>PLoraSQL</application> raises the predefined exception INVALID_CURSOR.
      </para>
     </listitem>
     <listitem>
      <para>
       If an explicit cursor is not open, referencing any attribute except %ISOPEN raises
       the predefined exception INVALID_CURSOR.
      </para>
     </listitem>
    </itemizedlist>
    </para>

    <para>
     for example. After closing a cursor variable,
     you cannot fetch records from its result set or reference its attributes.
    <programlisting>
--preconditional
create table employees(id int, name varchar2(100), job varchar2(100));
insert into employees values (22091401, 'sunli', 'actress');
insert into employees values (22091402, 'dengchao', 'actor');
insert into employees values (22091403, 'lishizhen', 'doctor');
insert into employees values (22091404, 'zhangsanfeng', 'martial artist');

create or replace function invalid_cursor_f return int as
   cursor c1 is select * from  employees;
   emp_cur employees%rowtype;
begin
    open c1;
    loop
      fetch c1 into emp_cur;
      exit when c1%notfound;
      close c1;
    end loop;
    close c1;
EXCEPTION
  WHEN invalid_cursor THEN
    DBMS_OUTPUT.PUT_LINE('invalid cursor');
    return 1;
end;
/

select invalid_cursor_f();
    </programlisting>
    </para>

    <para>
    for example, If an explicit cursor is not open,
    referencing any attribute except %ISOPEN raises
    the predefined exception INVALID_CURSOR.
    <programlisting>
create or replace function invalid_cursor_f return int as
   cursor c1 is select * from  employees;
   emp_cur employees%rowtype;
   ora_found boolean := false;
begin
   ora_found := c1%found;
EXCEPTION
  WHEN invalid_cursor THEN
    DBMS_OUTPUT.PUT_LINE('invalid cursor');
   return 1;
end;
/

select invalid_cursor_f();
    </programlisting>
    </para>

    <tip>
     <para>
      Error handling with <application>PLoraSQL</application>,
      and the value of lightdb_dblevel_syntax_compatible_type is oracle.
     </para>
    </tip>
    </sect4>

    <sect4>
     <title>Cursor Variables</title>

    <para>
    <itemizedlist>
     <listitem>
      <para>
       When you no longer need a cursor variable, close it with the CLOSE statement,
       thereby allowing its resources to be reused. After closing a cursor variable,
       you cannot fetch records from its result set or reference its attributes.
       If you try, <application>PLoraSQL</application> raises the predefined exception INVALID_CURSOR.
      </para>
     </listitem>
     <listitem>
      <para>
       A cursor variable has the same attributes as an explicit cursor.
       The syntax for the value of a cursor variable attribute is cursor_variable_name
       immediately followed by attribute (for example, cv%ISOPEN).
       If a cursor variable is not open, referencing any attribute except %ISOPEN raises
       the predefined exception INVALID_CURSOR
      </para>
     </listitem>
    </itemizedlist>
    </para>

    <para>
     for example, After closing a cursor variable,
     you cannot fetch records from its result set or reference its attributes.
    <programlisting>
create or replace function invalid_cursor_f return int as
   c1 sys_refcursor;
   emp_cur employees%rowtype;
begin
    open c1 for select * from  employees;
    loop
      fetch c1 into emp_cur;
      exit when c1%notfound;
      close c1;
    end loop;
    close c1;
EXCEPTION
  WHEN invalid_cursor THEN
    DBMS_OUTPUT.PUT_LINE('invalid cursor');
    return 1;
end;
/

select invalid_cursor_f();
    </programlisting>
    </para>

    <para>
     for example, If a cursor variable is not open, referencing any attribute except %ISOPEN raises
     the predefined exception INVALID_CURSOR.
    <programlisting>
create or replace function invalid_cursor_f return int as
   c1 sys_refcursor;
   emp_cur employees%rowtype;
   ora_isopen boolean := false;
begin
  ora_isopen := c1%isopen;
  return 1;
  exception 
    when INVALID_CURSOR then
      dbms_output.put_line('this is a normal error');
end;
/

select invalid_cursor_f();
    </programlisting>
    </para>
    </sect4>
   </sect3>

   <sect3>
   <title>CASE_NOT_FOUND</title>

    <para>
     case statement, if the necessary conditional branch is not included in the when clause,
     it will trigger. There are two cases of simple_case_statement and search_case_statment.
    </para>

    <para>
     for example, simple_case_statement.
    <programlisting>
create or replace function case_not_found_f return int as
  grade CHAR(1);
BEGIN
  grade := 'G';
  
  CASE grade
    WHEN 'A' THEN DBMS_OUTPUT.PUT_LINE('Excellent');
    WHEN 'B' THEN DBMS_OUTPUT.PUT_LINE('Very Good');
    WHEN 'C' THEN DBMS_OUTPUT.PUT_LINE('Good');
    WHEN 'D' THEN DBMS_OUTPUT.PUT_LINE('Fair');
    WHEN 'F' THEN DBMS_OUTPUT.PUT_LINE('Poor');
  END CASE;
EXCEPTION
  WHEN CASE_NOT_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('No such grade');
  return 1;
END;
/

select case_not_found_f();
    </programlisting>
    </para>

    <para>
     for example, search_case_statment.
    <programlisting>
create or replace function case_not_found_f return int as
  grade CHAR(1);
BEGIN
  grade := 'G';
  
  CASE
    WHEN grade = 'A' THEN DBMS_OUTPUT.PUT_LINE('Excellent');
    WHEN grade = 'B' THEN DBMS_OUTPUT.PUT_LINE('Very Good');
    WHEN grade = 'C' THEN DBMS_OUTPUT.PUT_LINE('Good');
    WHEN grade = 'D' THEN DBMS_OUTPUT.PUT_LINE('Fair');
    WHEN grade = 'F' THEN DBMS_OUTPUT.PUT_LINE('Poor');
  END CASE;
EXCEPTION
  WHEN CASE_NOT_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('No such grade');
  return 1;
END;
/

select case_not_found_f();
    </programlisting>
    </para>
    </sect3>

   <sect3>
   <title>DUP_VAL_ON_INDEX</title>

    <para>
     Triggered when a duplicate value is inserted into the column corresponding to the unique index.
    </para>

    <para>
     for example:
    <programlisting>
--preconditional
CREATE TABLE emp_name AS SELECT id, name FROM employees;

CREATE UNIQUE INDEX empname_ix ON emp_name (id);

create or replace procedure dup_val_on_index_p as
  emp_id        NUMBER(10);
  emp_name  VARCHAR2(100);
BEGIN
  SELECT id, name  INTO emp_id, emp_name FROM employees WHERE id = 22091401;
 
  INSERT INTO emp_name (id, name) VALUES (emp_id, emp_name);
 
EXCEPTION
  WHEN DUP_VAL_ON_INDEX THEN
    ROLLBACK;
    DBMS_OUTPUT.PUT_LINE('Inserts were rolled back');
END;
/

call dup_val_on_index_p();
    </programlisting>
    </para>
    </sect3>

   <sect3>
   <title>NOT_DATA_FOUND</title>

    <para>
     Triggered when no row is returned when select into is executed.
    </para>

    <para>
     for example:
    <programlisting>
-- no_data_found
-- select into
-- number of record selected is zero
create or replace function no_data_found_f return int as
  v_emp int;
begin
  select id into v_emp from employees where id = 22091501;
EXCEPTION
  WHEN no_data_found THEN
    DBMS_OUTPUT.PUT_LINE('No data found');
  return 1;
end;
/

select no_data_found_f();
    </programlisting>
    </para>
    </sect3>

   <sect3>
   <title>TOO_MANY_ROWS</title>

    <para>
     When a select into statement is executed,
     it will fire if more than one row is returned.
    </para>

    <para>
     for example:
    <programlisting>
create or replace function too_many_rows_f return int as
  v_emp int;
begin
  select id into v_emp from employees;

EXCEPTION
  WHEN no_data_found THEN
    DBMS_OUTPUT.PUT_LINE('No data found');
  WHEN too_many_rows THEN
    DBMS_OUTPUT.PUT_LINE('Too Many Rows');

  return 1;
end;
/

select too_many_rows_f();
    </programlisting>
    </para>
    </sect3>

   <sect3>
   <title>LOGIN_DENIED</title>

    <para>
     You can use raise to throw the predefined exception and handle the problem after the exception.
     (not triggered in plorasql, but in lightdb)
    </para>

    <para>
     for example:
    <programlisting>
create or replace function login_denied_f return int as
begin
  raise login_denied;
exception
  when login_denied then
    dbms_output.put_line('this is a login_denied message.. good luck the next time');
  return 1;
end;
/

select login_denied_f();
    </programlisting>
    </para>
    </sect3>

   <sect3>
   <title>ZERO_DIVIDE</title>

    <para>
     Triggered when a non-zero number divided by 0 event occurs.
    </para>

    <para>
     for example:
    <programlisting>
create or replace function zero_divide_f return int as
    a int := 10;
    b int := 0;
begin
    a := a / b;
    exception 
      when zero_divide then
        dbms_output.put_line('this is a normal error');
    return 1;
end;
/

select zero_divide_f();
    </programlisting>
    </para>

    <tip>
    <para>
     1.Error handling does not support handling problem summary:
    <itemizedlist>
     <listitem>
      <para>
       The dynamic SQL in the anonymous block contains the anonymous block of 
       commit and rollback, which is not supported;
      </para>
     </listitem>
     <listitem>
      <para>
       The dynamic SQL in the stored procedure contains anonymous blocks of
       commit and rollback, which is not supported;
      </para>
     </listitem>
     <listitem>
      <para>
       Stored procedures in the package and anonymous blocks containing
       commit and rollback in dynamic SQL in anonymous blocks are not supported.
      </para>
     </listitem>
    </itemizedlist>
    </para>
    <para>
     2.There is a problem with the execution order of functions, stored procedures,
     and anonymous blocks in the package;
    </para>
    <para>
     3.Currently plorasql does not support savepoint.
    </para>
    </tip>
    </sect3>
  </sect2>

  <sect2 id="plorasql-raising-exceptions-explicitly">
    <title>Raising Exceptions Explicitly</title>
    <para>
      To raise an exception explicitly, use either the <command>RAISE</command> statement or <command>RAISE_APPLICATION_ERROR</command> procedure.
    </para>

    <para>
      You can invoke the <command>RAISE_APPLICATION_ERROR</command> procedure only from a stored subprogram or method.
      Typically, you invoke this procedure to raise a user-defined exception and return its error code and error message to the invoker.
    </para>

    <para>
     To invoke <command>RAISE_APPLICATION_ERROR</command> , use this syntax:
    </para>

<programlisting>
RAISE_APPLICATION_ERROR (error_code, message[, {TRUE | FALSE}]);
</programlisting>
    
    <para>
      The error_code is an integer in the range -20000..-20999. If you specify <command>TRUE</command>,
      PL/oraSQL will not print message. Otherwise, PL/oraSQL will print message. The <command>FALSE</command> is default.
    </para>

  </sect2>

  <sect2 id="plorasql-format-error-backtrace">
    <title>support DBMS_UTILITY built-in package format_error_backtrace</title>
    <para>
      The DBMS_UTILITY.format_error_backtrace function is a critical subprogram to call when logging exceptions.
      It returns a string that traces the error back to the line on which it was raised! 
      The back trace function always only traces back to the most recently raised exception.
      The maximum length that the error allows to return is 10000.
    </para>

    <para>
     Use function of DBMS_UTILITY.format_error_backtrace, for example:
    <programlisting>
--preconditional
create table test_error_stack(id number primary key);
insert into test_error_stack values (1);
create table t_errlog(operate_error_msg varchar(1000));

create or replace procedure pr_error_code_test1 is
    v_backtrace    varchar(1000);
    v_error        varchar(1000); 
begin

    INSERT INTO test_error_stack values (2);
    INSERT INTO test_error_stack values (1);
    commit;
    exception when others then
    insert into t_errlog(operate_error_msg) select to_char(dbms_utility.format_error_backtrace);
    commit;
    rollback;
    end pr_error_code_test1;
/

call pr_error_code_test1();
select * from t_errlog;

--Use function calls alone
select select to_char(dbms_utility.format_error_backtrace)
    </programlisting>
    </para>
  </sect2>
  </sect1>

</chapter>
