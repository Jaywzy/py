<!-- doc/src/sgml/orafce.sgml -->

<sect1 id="orafce" xreflabel="orafce">
 <title>orafce</title>

 <indexterm zone="orafce">
  <primary>orafce</primary>
 </indexterm>

 <para>
  <filename>orafce</filename> - Oracle's compatibility functions and packages.
 </para>

 <sect2>
  <title>Features Compatible with Oracle Databases</title>

  <para>
   Features compatible with Oracle databases are provided.
   These features enable you to easily migrate to LightDB and reduce the costs of reconfiguring applications.

   The table below lists features compatible with Oracle databases.
  </para>

  <table>
   <title>Data type</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Item
       </para>
      </entry>
      <entry>
       <para>
        Overview
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        VARCHAR2
       </para>
      </entry>
      <entry>
       <para>
        Variable-length character data type
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        NVARCHAR2
       </para>
      </entry>
      <entry>
       <para>
        Variable-length national character data type
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DATE
       </para>
      </entry>
      <entry>
       <para>
        Data type that stores date and time
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        NUMBER
       </para>
      </entry>
      <entry>
       <para>
        NUMBER is an alias for NUMERIC
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        DATETIME
       </para>
      </entry>
      <entry>
       <para>
        DATETIME is an alias for timestamp without zone.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        CLOB
       </para>
      </entry>
      <entry>
       <para>
        CLOB is an alias for TEXT.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        BLOB
       </para>
      </entry>
      <entry>
       <para>
        BLOB is an alias for BYTEA.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        RAW
       </para>
      </entry>
      <entry>
       <para>
        Variable-length hex data type .
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        PLS_INTEGER 
       </para>
      </entry>
      <entry>
       <para>
        A PL/SQL data type used for storing signed integers.
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  <para>
    <type>varchar2</type> and <type>nvarchar2</type> is config in priority between <type>varchar</type> and <type>char</type>, after create orafce extensin,
    the priority is :
    <screen>
numeric > double precision > real > bigint > integer > smallint > text > varchar > varchar2 > nvarchar2 > char
</screen>
  </para>
  <table>
   <title>SQL Queries</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Item
       </para>
      </entry>
      <entry>
       <para>
        Overview
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        DUAL table
       </para>
      </entry>
      <entry>
       <para>
        Table provided by the system
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table>
   <title>Mathematical Functions</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Item
       </para>
      </entry>
      <entry>
       <para>
        Overview
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        BIN_TO_NUM
       </para>
      </entry>
      <entry>
       <para>
        Converts a bit vector to its equivalent number
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        BITAND
       </para>
      </entry>
      <entry>
       <para>
        Performs a bitwise AND operation
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        BITOR
       </para>
      </entry>
      <entry>
       <para>
        Performs a bitwise OR operation
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        BITXOR
       </para>
      </entry>
      <entry>
       <para>
        Performs a bitwise XOR operation
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        COSH
       </para>
      </entry>
      <entry>
       <para>
        Calculates the hyperbolic cosine of a number
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        REMAINDER
       </para>
      </entry>
      <entry>
       <para>
        Returns the remainder of n2 divided by n1
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        ROUND_TIES_TO_EVEN 
       </para>
      </entry>
      <entry>
       <para>
        Returns n rounded to integer places 
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SINH
       </para>
      </entry>
      <entry>
       <para>
        Calculates the hyperbolic sine of a number
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TANH
       </para>
      </entry>
      <entry>
       <para>
        Calculates the hyperbolic tangent of a number
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table>
   <title>String Functions</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Item
       </para>
      </entry>
      <entry>
       <para>
        Overview
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        INSTR
       </para>
      </entry>
      <entry>
       <para>
        Returns the position of a substring in a string
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        INSTRB
       </para>
      </entry>
      <entry>
       <para>
        Returns the position in the string that is the first byte of a specified occurrence of the substring
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        LENGTH
       </para>
      </entry>
      <entry>
       <para>
        Returns the length of a string in number of characters
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        LENGTHB
       </para>
      </entry>
      <entry>
       <para>
        Returns the length of a string in number of bytes
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        LPAD
       </para>
      </entry>
      <entry>
       <para>
        Left-pads a string to a specified length with a sequence of characters
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        LTRIM
       </para>
      </entry>
      <entry>
       <para>
        Removes the specified characters from the beginning of a string
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        NLSSORT
       </para>
      </entry>
      <entry>
       <para>
        Returns a byte string used to sort strings in linguistic sort sequence based on locale
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        REGEXP_COUNT
       </para>
      </entry>
      <entry>
       <para>
        searches a string for a regular expression, and returns a count of the matches
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        REGEXP_INSTR
       </para>
      </entry>
      <entry>
       <para>
        returns the beginning or ending position within the string where the match for a pattern was located
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        REGEXP_LIKE
       </para>
      </entry>
      <entry>
       <para>
        condition in the WHERE clause of a query, causing the query to return rows that match the given pattern
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        REGEXP_SUBSTR
       </para>
      </entry>
      <entry>
       <para>
        returns the string that matches the pattern specified in the call to the function
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        REGEXP_REPLACE
       </para>
      </entry>
      <entry>
       <para>
        returns the string that matches the pattern specified in the call to the function
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        REPLACE
       </para>
      </entry>
      <entry>
       <para>
        REPLACE returns string with every occurrence of search_string replaced with replacement_string
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        RPAD
       </para>
      </entry>
      <entry>
       <para>
        Right-pads a string to a specified length with a sequence of characters
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        RTRIM
       </para>
      </entry>
      <entry>
       <para>
        Removes the specified characters from the end of a string
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SOUNDEX
       </para>
      </entry>
      <entry>
       <para>
        Returns a character string containing the phonetic representation of char.
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SUBSTR
       </para>
      </entry>
      <entry>
       <para>
        Extracts part of a string using characters to specify position and length
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SUBSTRB
       </para>
      </entry>
      <entry>
       <para>
        Extracts part of a string using bytes to specify position and length
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        GUID
       </para>
      </entry>
      <entry>
       <para>
        Return UUID
       </para>
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <table>
   <title>Date/Time Functions</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Item
       </para>
      </entry>
      <entry>
       <para>
        Overview
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        ADD_MONTHS
       </para>
      </entry>
      <entry>
       <para>
        Adds months to a date
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DBTIMEZONE
       </para>
      </entry>
      <entry>
       <para>
        Returns the value of the database time zone
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        LENGTHB
       </para>
      </entry>
      <entry>
       <para>
        Returns the length of a string in number of bytes
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        LAST_DAY
       </para>
      </entry>
      <entry>
       <para>
        Returns the last day of the month in which the specified date falls
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        LTRIM
       </para>
      </entry>
      <entry>
       <para>
        Removes the specified characters from the beginning of a string
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        MONTHS_BETWEEN
       </para>
      </entry>
      <entry>
       <para>
        Returns the number of months between two dates
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        NEXT_DAY
       </para>
      </entry>
      <entry>
       <para>
        Returns the date of the first instance of a particular day of the week that follows the specified date
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        ROUND
       </para>
      </entry>
      <entry>
       <para>
        Rounds a date
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SESSIONTIMEZONE
       </para>
      </entry>
      <entry>
       <para>
        Returns the time zone of the session
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SYSDATE
       </para>
      </entry>
      <entry>
       <para>
        Returns the system date
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TRUNC
       </para>
      </entry>
      <entry>
       <para>
        Truncates a date
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TZ_OFFSET
       </para>
      </entry>
      <entry>
       <para>
        Returns the time zone offset
       </para>
      </entry>
     </row>    
    </tbody>
   </tgroup>
  </table>

  <table>
   <title>Data Type Formatting Functions</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Item
       </para>
      </entry>
      <entry>
       <para>
        Overview
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        CONVERT
       </para>
      </entry>
      <entry>
       <para>
        Converts a character string from one character set to another. 
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        NUMTOYMINTERVAL
       </para>
      </entry>
      <entry>
       <para>
        Converts number to an INTERVAL YEAR TO MONTH literal
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TO_BLOB(raw)
       </para>
      </entry>
      <entry>
       <para>
        Converts RAW values to BLOB values. 
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TO_CHAR
       </para>
      </entry>
      <entry>
       <para>
        Converts a value to a string
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TO_DATE
       </para>
      </entry>
      <entry>
       <para>
        Converts a string to a date in accordance with the specified format
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TO_MULTI_BYTE
       </para>
      </entry>
      <entry>
       <para>
        Converts a single-byte string to a multibyte string
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TO_NUMBER
       </para>
      </entry>
      <entry>
       <para>
        Converts a value to a number in accordance with the specified format
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TO_SINGLE_BYTE
       </para>
      </entry>
      <entry>
       <para>
        Converts a multibyte string to a single-byte string
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table>
   <title>Conditional Expressions</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Item
       </para>
      </entry>
      <entry>
       <para>
        Overview
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        DECODE
       </para>
      </entry>
      <entry>
       <para>
        Compares values, and if they match, returns a corresponding value
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        LNNVL
       </para>
      </entry>
      <entry>
       <para>
        Evaluates if a value is false or unknown
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        NANVL
       </para>
      </entry>
      <entry>
       <para>
        Returns a substitute value when a value is not a number (NaN)
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        NVL
       </para>
      </entry>
      <entry>
       <para>
        Returns a substitute value when a value is NULL
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        NVL2
       </para>
      </entry>
      <entry>
       <para>
        Returns a substitute value based on whether a value is NULL or not NULL
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table>
   <title>Aggregate Functions</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Item
       </para>
      </entry>
      <entry>
       <para>
        Overview
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        ANY_VALUE
       </para>
      </entry>
      <entry>
       <para>
        Returns a single non-deterministic value of expr.
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        BIT_AND_AGG
       </para>
      </entry>
      <entry>
       <para>
        Returns the result of a bitwise AND operation
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        BIT_OR_AGG
       </para>
      </entry>
      <entry>
       <para>
        Returns the result of a bitwise OR operation
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        BIT_XOR_AGG
       </para>
      </entry>
      <entry>
       <para>
        Returns the result of a bitwise XOR operation
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        KURTOSIS_POP
       </para>
      </entry>
      <entry>
       <para>
        Used to determine the characteristics of outliers in a given distribution
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        KURTOSIS_SAMP 
       </para>
      </entry>
      <entry>
       <para>
        Used to determine the characteristics of outliers in a given distribution
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        LISTAGG
       </para>
      </entry>
      <entry>
       <para>
        Returns a concatenated, delimited list of string values
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        MEDIAN
       </para>
      </entry>
      <entry>
       <para>
        Calculates the median of a set of values
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SKEWNESS_POP
       </para>
      </entry>
      <entry>
       <para>
        Used to determine symmetry in a given distribution
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SKEWNESS_SAMP
       </para>
      </entry>
      <entry>
       <para>
        Used to determine symmetry in a given distribution
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table>
   <title>Functions that return internal information</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Item
       </para>
      </entry>
      <entry>
       <para>
        Overview
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        DUMP
       </para>
      </entry>
      <entry>
       <para>
        Returns internal information of a value
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        NLS_CHARSET_ID 
       </para>
      </entry>
      <entry>
       <para>
        Returns the character set ID number corresponding to character set name string. 
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        NLS_CHARSET_NAME
       </para>
      </entry>
      <entry>
       <para>
        Returns the name of the character set corresponding to ID number number.
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SYS_CONTEXT
       </para>
      </entry>
      <entry>
       <para>
        Returns the value of parameter associated with the context namespace at the current instant
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        USERENV
       </para>
      </entry>
      <entry>
       <para>
        Returns the value of parameter associated with the context 'USERENV' at the current session
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table>
   <title>SQL Operators</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Item
       </para>
      </entry>
      <entry>
       <para>
        Overview
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        Datetime operator
       </para>
      </entry>
      <entry>
       <para>
        Datetime operator for the DATE type
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table>
   <title>Other functions</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Item
       </para>
      </entry>
      <entry>
       <para>
        Overview
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        EMPTY_CLOB
       </para>
      </entry>
      <entry>
       <para>
        Return an empty CLOB(actually '')
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        ORA_HASH
       </para>
      </entry>
      <entry>
       <para>
        ORA_HASH is a function that computes a hash value for a given expression
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        VSIZE
       </para>
      </entry>
      <entry>
       <para>
        Returns the number of bytes in the internal representation of expr
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        VSIZE
       </para>
      </entry>
      <entry>
       <para>
        Returns the number of bytes in the internal representation of expr
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DEPS_SAVE_AND_DROP_DEPENDENCIES
       </para>
      </entry>
      <entry>
       <para>
        Save and drop dependencies for table
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DEPS_RESTORE_DEPENDENCIES
       </para>
      </entry>
      <entry>
       <para>
        Restore dependencies for table
       </para>
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <table>
   <title>Packages</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Item
       </para>
      </entry>
      <entry>
       <para>
        Overview
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        DBMS_ALERT
       </para>
      </entry>
      <entry>
       <para>
        Sends alerts to multiple sessions
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DBMS_ASSERT
       </para>
      </entry>
      <entry>
       <para>
        Validates the properties of an input value
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DBMS_LOB
       </para>
      </entry>
      <entry>
       <para>
        Some functions compatible with DBMS_LOB package.
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DBMS_OUTPUT
       </para>
      </entry>
      <entry>
       <para>
        Sends messages to clients
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DBMS_PIPE
       </para>
      </entry>
      <entry>
       <para>
        Creates a pipe for inter-session communication
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DBMS_RANDOM
       </para>
      </entry>
      <entry>
       <para>
        Generates random numbers
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DBMS_UTILITY
       </para>
      </entry>
      <entry>
       <para>
        Provides various utilities
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DBMS_JOB
       </para>
      </entry>
      <entry>
       <para>
        Schedules and manages jobs in the lt_cron
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DBMS_LOCK
       </para>
      </entry>
      <entry>
       <para>
         Provides an interface to Lock Management services
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DBMS_METADATA
       </para>
      </entry>
      <entry>
       <para>
        Provides a way for you to retrieve metadata from the database dictionary
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DBMS_OBFUSCATION_TOOLKIT
       </para>
      </entry>
      <entry>
       <para>
        Enables an application to encrypt data using either the Data Encryption Standard (DES) or the Triple DES algorithms
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DBMS_SNAPSHOT
       </para>
      </entry>
      <entry>
       <para>
       Enables you to refresh snapshots(MVIEW)
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        UTL_FILE
       </para>
      </entry>
      <entry>
       <para>
        Enables text file operations
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        UTL_RAW
       </para>
      </entry>
      <entry>
       <para>
        Provides SQL functions for manipulating RAW datatypes
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        UTL_URL
       </para>
      </entry>
      <entry>
       <para>
        Has two functions that provide escape and unescape mechanisms for URL characters
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        UTL_ENCODE
       </para>
      </entry>
      <entry>
       <para>
        Provides functions that encode RAW data into a standard encoded format
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table>
   <title>System View</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Item
       </para>
      </entry>
      <entry>
       <para>
        Overview
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_SEQUENCES
       </para>
      </entry>
      <entry>
       <para>
        Describes sequences
        </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_SYNONYMS
       </para>
      </entry>
      <entry>
       <para>
        Describes the synonyms, empty now
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_TAB_COLS
       </para>
       <para>
        COLS
       </para>
       <para>
        [DBA/ALL/USER]_TAB_COLUMNS
       </para>
      </entry>
      <entry>
       <para>
        Describes the columns of tables, views
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_TAB_COL_STATISTICS
       </para>
      </entry>
      <entry>
       <para>
        Contains column statistics and histogram information extracted from "[DBA/ALL/USER]_TAB_COLUMNS"
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_OBJECTS
       </para>
       <para>
        OBJ
       </para>
      </entry>
      <entry>
       <para>
       Describes objects
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_CATALOG
       </para>
      </entry>
      <entry>
       <para>
        Lists tables, views, and sequences
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DICTIONARY/DICT
       </para>
      </entry>
      <entry>
       <para>
        Contains descriptions of data dictionary tables and views.
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_DEPENDENCIES
       </para>
      </entry>
      <entry>
       <para>
        Describes dependencies between objects
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_SOURCE
       </para>
      </entry>
      <entry>
       <para>
        Describes the text source of stored objects
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_PROCEDURES
       </para>
      </entry>
      <entry>
       <para>
        Lists functions and procedures
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_TRIGGERS
       </para>
      </entry>
      <entry>
       <para>
       Describes triggers
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_TRIGGER_COLS
       </para>
      </entry>
      <entry>
       <para>
       Describes the use of columns in triggers
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_TYPES
       </para>
      </entry>
      <entry>
       <para>
        Describes object types
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_CONSTRAINTS
       </para>
      </entry>
      <entry>
       <para>
        Describes constraint definitions
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_CONS_COLUMNS
       </para>
      </entry>
      <entry>
       <para>
        Dscribes columns that are specified in constraints
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_VIEWS
       </para>
      </entry>
      <entry>
       <para>
        Describes views
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_TABLES
       </para>
       <para>
        [DBA/ALL/USER]_ALL_TABLES
       </para>
       <para>
        TAB
       </para>
      </entry>
      <entry>
       <para>
        Describes object tables and relational tables
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_TAB_STATISTICS
       </para>
      </entry>
      <entry>
       <para>
        Displays optimizer statistics for tables
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_TAB_COMMENTS
       </para>
      </entry>
      <entry>
       <para>
        Displays comments on tables and views
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_COL_COMMENTS
       </para>
      </entry>
      <entry>
       <para>
        Displays comments on the columns of tables and views
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_TAB_MODIFICATIONS
       </para>
      </entry>
      <entry>
       <para>
        Describes modifications to all tables
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_INDEXES
        IND
       </para>
      </entry>
      <entry>
       <para>
        Describes indexes
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_INDEX_USAGE
       </para>
      </entry>
      <entry>
       <para>
        Displays cumulative statistics for each index.
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_IND_COLUMNS
       </para>
      </entry>
      <entry>
       <para>
        Describes the columns of indexes on tables
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_IND_EXPRESSIONS
       </para>
      </entry>
      <entry>
       <para>
        Describes the expressions of function-based indexes
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_IND_STATISTICS
       </para>
      </entry>
      <entry>
       <para>
        Displays optimizer statistics for indexes
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_USERS
       </para>
      </entry>
      <entry>
       <para>
        Describes users
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        DBA_ROLES
       </para>
      </entry>
      <entry>
       <para>
         Describes all roles in the database
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        [DBA/USER]_ROLE_PRIVS
       </para>
      </entry>
      <entry>
       <para>
        Describes the roles granted to users and roles
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        PRODUCT_COMPONENT_VERSION
       </para>
      </entry>
      <entry>
       <para>
        Contains version and status information for component products
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        PLAN_TABLE
       </para>
      </entry>
      <entry>
       <para>
        PLAN_TABLE is automatically created as a global temporary table to hold the output of an EXPLAIN PLAN statement for all users, empty now
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        DBA_DATA_FILES
       </para>
      </entry>
      <entry>
       <para>
        Describes database files
      </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_JOBS
       </para>
      </entry>
      <entry>
       <para>
        Describes jobs
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        DBA_JOBS_RUNNING
       </para>
      </entry>
      <entry>
       <para>
        Lists all jobs that are currently running in the instance
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_MVIEWS
       </para>
      </entry>
      <entry>
       <para>
        Describes materialized views
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_MVIEW_LOGS
       </para>
      </entry>
      <entry>
       <para>
        Describes all materialized view logs
        now it is empty
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        [DBA/ALL/USER]_MVIEW_COMMENTS
       </para>
      </entry>
      <entry>
       <para>
        Displays comments on the materialized views
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        [DBA/USER]_TABLESPACES
       </para>
      </entry>
      <entry>
       <para>
        Describes tablespaces
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        NLS_[DATABASE/INSTANCE/SESSION]_PARAMETERS
       </para>
      </entry>
      <entry>
       <para>
        Lists NLS parameters
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        [DBA/USER]_SEGMENTS
       </para>
      </entry>
      <entry>
       <para>
        Describes the storage allocated for segments
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        [DBA/USER/ALL]_PART_TABLES
       </para>
      </entry>
      <entry>
       <para>
        Displays the object-level partitioning information for the partitioned tables
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        [DBA/USER/ALL]_TAB_PARTITIONS
       </para>
      </entry>
      <entry>
       <para>
        Displays partition-level partitioning information, partition storage parameters, and partition statistics
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        [DBA/USER/ALL]_TAB_SUBPARTITIONS
       </para>
      </entry>
      <entry>
       <para>
        Displays information for all subpartitions 
       </para>
      </entry>
     </row>


     <row>
      <entry>
       <para>
        [DBA/USER/ALL]_PART_KEY_COLUMNS
       </para>
      </entry>
      <entry>
       <para>
        Describes the partitioning key columns for the partitioned objects
       </para>
      </entry>
     </row>


     <row>
      <entry>
       <para>
        [DBA/USER/ALL]_SUBPART_KEY_COLUMNS
       </para>
      </entry>
      <entry>
       <para>
        Displays subpartitioning key columns for composite-partitioned tables(and local indexes on composite-partitioned tables) 
       </para>
      </entry>
     </row>


     <row>
      <entry>
       <para>
        [DBA/USER/ALL]_IND_PARTITIONS
       </para>
      </entry>
      <entry>
       <para>
        Describes index partitions
       </para>
      </entry>
     </row>


     <row>
      <entry>
       <para>
        [DBA/USER/ALL]_PART_INDEXES
       </para>
      </entry>
      <entry>
       <para>
        Displays the object-level partitioning information for the partitioned indexes
       </para>
      </entry>
     </row>


    </tbody>
   </tgroup>
  </table>

  <para>
   Views starting with DBA show something in the database.
   Views starting with ALL is currently the same as Views starting with DBA, and no permission verification is done like oracle. now.
   Views starting with USER show something owned by the current user(actually is current schema. in oracle, User and schema are one-to-one correspondence).
  </para>
  
 </sect2>

 <sect2>
  <title>Notes on Using orafce</title>

  <para>
   Orafce is defined as user-defined functions in the "public" schema
   created by default when database clusters are created, so they can be
   available for all users without the need for special settings.
   For this reason, ensure that "public" (without the double quotation marks)
   is included in the list of schema search paths specified in the search_path parameter.
  </para>

  <para>
   The following features provided by orafce are implemented in LightDB and
   orafce using different external specifications. In the default configuration
   of LightDB, the standard features of LightDB take precedence.
  </para>

  <table>
   <title>Data type</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>
       <para>
        Item
       </para>
      </entry>
      <entry>
       <para>
        Standard feature of LightDB
       </para>
      </entry>
      <entry>
       <para>
        Compatibility feature added by orafce
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        DATE
       </para>
      </entry>
      <entry>
       <para>
        Stores date only.
       </para>
      </entry>
      <entry>
       <para>
        Stores date and time.
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table>
   <title>Function</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>
       <para>
        Item
       </para>
      </entry>
      <entry>
       <para>
        Standard feature of LightDB
       </para>
      </entry>
      <entry>
       <para>
        Compatibility feature added by orafce
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        LENGTH
       </para>
      </entry>
      <entry>
       <para>
        If the string is CHAR type, trailing spaces are not included in the length.
       </para>
      </entry>
      <entry>
       <para>
        If the string is CHAR type, trailing spaces are included in the length.
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SUBSTR
       </para>
      </entry>
      <entry>
       <para>
        If 0 or a negative value is specified for the start position,
        simply subtracting 1 from the start position, the position
        will be shifted to the left, from where extraction will start.
       </para>
      </entry>
      <entry>
       <para>
        - If 0 is specified for the start position, extraction will
        start from the beginning of the string.
       </para>
       <para>
        - If a negative value is specified for the start position,
        extraction will start from the position counted from the
        end of the string.
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>LPAD</para>
       <para>RPAD</para>
      </entry>
      <entry>
       <para>
        - If the string is CHAR type, trailing spaces are removed and then the value is padded.
       </para>
       <para>
        - The result length is handled as a number of characters.
       </para>
      </entry>
      <entry>
       <para>
        - If the string is CHAR type, the value is padded without removing trailing spaces.
       </para>
       <para>
        - The result length is based on the width of the displayed string.
        Therefore, fullwidth characters are handled using a width of 2,
        and halfwidth characters are handled using a width of 1.
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>LTRIM</para>
       <para>RTRIM</para>
       <para>BTRIM (*1)</para>
      </entry>
      <entry>
       <para>
        If the string is CHAR type, trailing spaces are removed and then the value is removed.
       </para>
      </entry>
      <entry>
       <para>
        If the string is CHAR type, the value is removed without removing trailing spaces.
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TO_DATE
       </para>
      </entry>
      <entry>
       <para>
        The data type of the return value is DATE.
       </para>
      </entry>
      <entry>
       <para>
        The data type of the return value is TIMESTAMP.
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   *1: BTRIM does not exist for Oracle databases, however, an external specification different
   to LightDB is implemented in orafce to align with the behavior of the TRIM functions.
  </para>

  <para>
   Also, the following features cannot be used in the default configuration of LightDB.
  </para>

  <table>
   <title>Function</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry>
       <para>
        Feature
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        SYSDATE
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DBTIMEZONE
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SESSIONTIMEZONE
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TO_CHAR (date/time value)
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table>
   <title>Operator</title>
   <tgroup cols="1">
    <thead>
     <row>
      <entry>
       <para>
        Feature
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        Datetime operator
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   To use these features, set "oracle" and "pg_catalog" in the "search_path"
   parameter of lightdb.conf. You must specify "oracle" before "pg_catalog"
   when doing this.
  </para>

  <programlisting>
   search_path = '"$user", public, oracle, pg_catalog'
  </programlisting>

  <para><emphasis role="bold">
   Information
  </emphasis></para>

  <itemizedlist>
   <listitem>
    <para>
     The search_path parameter specifies the order in which schemas are searched.
     Each feature compatible with Oracle databases is defined in the oracle schema.
    </para>
   </listitem>

   <listitem>
    <para>
     It is recommended to set search_path in lightdb.conf. In this case, it will
     be effective for each instance.
    </para>
   </listitem>

   <listitem>
    <para>
     The configuration of search_path can be done at the user level or at the database
     level. Setting examples are shown below.
    </para>
   </listitem>

   <listitem>
    <para>
     If the standard features of LightDB take precedence, and features that cannot
     be used with the default configuration of LightDB are not required, it is not
     necessary to change the settings of search_path.
    </para>
   </listitem>

   <listitem>
    <para>
     Example of setting at the user level. This can be set by executing an SQL command.
     In this example, user1 is used as the username.
    </para>
    <programlisting>
     ALTER USER user1 SET search_path = "$user",public,oracle,pg_catalog;
    </programlisting>
   </listitem>

   <listitem>
    <para>
     Example of setting at the database level. This can be set by executing an SQL command.
     In this example, db1 is used as the database name. You must specify "oracle" before "pg_catalog".
    </para>
    <programlisting>
     ALTER DATABASE db1 SET search_path = "$user",public,oracle,pg_catalog;
    </programlisting>
   </listitem>
  </itemizedlist>

  <para><emphasis role="bold">
   See
  </emphasis></para>

  <itemizedlist>
   <listitem>
    <para>
     Refer to "Server Administration" > "Client Connection Defaults" > "Statement Behavior"
     in the LightDB Documentation for information on search_path.
    </para>
   </listitem>
   <listitem>
    <para>
     Refer to "Reference" > "SQL Commands" in the LightDB Documentation for information on
     ALTER USER and ALTER DATABASE.
    </para>
   </listitem>
  </itemizedlist>
 </sect2>

 <sect2>
  <title>Data Types</title>

  <para>
   The following data types are supported:
  </para>

  <itemizedlist>
   <listitem>
    <para>VARCHAR2</para>
   </listitem>
   <listitem>
    <para>NVARCHAR2</para>
   </listitem>
   <listitem>
    <para>DATE</para>
   </listitem>
   <listitem>
    <para>RAW</para>
   </listitem>
   <listitem>
    <para>PLS_INTEGER</para>
   </listitem>
  </itemizedlist>

  <sect3>
   <title>VARCHAR2</title>

   <para><emphasis role="bold">
    Syntax
   </emphasis></para>

   <para>
    Specify the VARCHAR2 type as follows.
   </para>

   <table>
    <title>VARCHAR2 Syntax</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         Data type syntax
        </para>
       </entry>
       <entry>
        <para>
         Explanation
        </para>
       </entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <para>
         VARCHAR2(<emphasis>len</emphasis> [<emphasis>byte</emphasis>|<emphasis>char</emphasis>])
        </para>
       </entry>
       <entry>
        <para>
         String with a variable length up to <emphasis>len</emphasis> characters.
         For <emphasis>len</emphasis>, specify an integer greater than 0.
         If <emphasis>len</emphasis> is omitted, the string can be any length.
		 Since 23.1, LightDB implements this syntax-sugar for compatibility with oracle varchar2 types.
		 The keyword <emphasis>byte</emphasis> or <emphasis>char</emphasis> after <emphasis>len</emphasis> is optional, it is only compatitable for oracle syntax,
		 internal implementation is the same as only <emphasis>len</emphasis> without <emphasis>byte</emphasis> or <emphasis>char</emphasis> keyword.
       </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    General rules
   </emphasis></para>

   <itemizedlist>
    <listitem>
     <para>
      VARCHAR2 is a character data type. Specify the number of characters for the length.
     </para>
    </listitem>
    <listitem>
     <para>
      Strings are of variable length. The specified value will be stored as is.
      The upper limit for this data type is approximately one gigabyte.
     </para>
    </listitem>
   </itemizedlist>

   <para><emphasis role="bold">
    Note
   </emphasis></para>

   <para>
    The VARCHAR2 type does not support collating sequences. Therefore, the following
    error occurs when a collating sequence like that of an ORDER BY clause is required.
    At this time, the following HINT will prompt to use a COLLATE clause, however,
    because collating sequences are not supported, it is not possible to use this clause.
   </para>

   <programlisting>
    ERROR:   could not determine which collation to use for string comparison
    HINT:   Use the COLLATE clause to set the collation explicitly.
   </programlisting>

   <para>
    If the error shown above is displayed, explicitly cast the column to VARCHAR or TEXT type.
   </para>

   <para><emphasis role="bold">
    Example
   </emphasis></para>

   <programlisting>
lightdb@postgres=# create table t1(name varchar2(10));
CREATE TABLE
lightdb@postgres=# 
lightdb@postgres=# \d+ t1
                                       Table "public.t1"
 Column |     Type     | Collation | Nullable | Default | Storage | Stats target | Description 
--------+--------------+-----------+----------+---------+---------+--------------+-------------
 name   | varchar2(10) |           |          |         | plain   |              | 
Access method: heap

lightdb@postgres=# 
lightdb@postgres=# create table t2(name varchar2(10 byte));
CREATE TABLE
lightdb@postgres=# 
lightdb@postgres=# \d+ t2
                                       Table "public.t2"
 Column |     Type     | Collation | Nullable | Default | Storage | Stats target | Description 
--------+--------------+-----------+----------+---------+---------+--------------+-------------
 name   | varchar2(10) |           |          |         | plain   |              | 
Access method: heap

lightdb@postgres=# 
lightdb@postgres=# create table t3(name varchar2(10 char));
CREATE TABLE
lightdb@postgres=# 
lightdb@postgres=# \d+ t3
                                       Table "public.t3"
 Column |     Type     | Collation | Nullable | Default | Storage | Stats target | Description 
--------+--------------+-----------+----------+---------+---------+--------------+-------------
 name   | varchar2(10) |           |          |         | plain   |              | 
Access method: heap

lightdb@postgres=# 
   </programlisting>

  </sect3>

  <sect3>
   <title>NVARCHAR2</title>

   <para><emphasis role="bold">
    Syntax
   </emphasis></para>

   <para>
    Specify the NVARCHAR2 type as follows.
   </para>

   <table>
    <title>NVARCHAR2 Syntax</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         Data type syntax
        </para>
       </entry>
       <entry>
        <para>
         Explanation
        </para>
       </entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <para>
         NVARCHAR2(<emphasis>len</emphasis>)
        </para>
       </entry>
       <entry>
        <para>
         National character string with a variable length up to <emphasis>len</emphasis> characters.
         For <emphasis>len</emphasis>, specify an integer greater than 0.
         If <emphasis>len</emphasis> is omitted, the string can be any length.
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    General rules
   </emphasis></para>

   <itemizedlist>
    <listitem>
     <para>
      NVARCHAR2 is a national character data type. Specify the number of
      characters for the length.
     </para>
    </listitem>
    <listitem>
     <para>
      Strings are of variable length. The specified value will be stored as is.
      The upper limit for this data type is approximately one gigabyte.
     </para>
    </listitem>
   </itemizedlist>

   <para><emphasis role="bold">
    Note
   </emphasis></para>

   <para>
    The NVARCHAR2 type does not support collating sequences. Therefore, the following
    error occurs when a collating sequence like that of an ORDER BY clause is required.
    At this time, the following HINT will prompt to use a COLLATE clause, however,
    because collating sequences are not supported, it is not possible to use this clause.
   </para>

   <programlisting>
    ERROR:   could not determine which collation to use for string comparison
    HINT:   Use the COLLATE clause to set the collation explicitly.
   </programlisting>

   <para>
    If the error shown above is displayed, explicitly cast the column to NCHAR VARYING or TEXT type.
   </para>
  </sect3>

  <sect3>
   <title>DATE</title>

   <para><emphasis role="bold">
    Syntax
   </emphasis></para>

   <para>
    Specify the DATE type as follows.
   </para>

   <table>
    <title>DATE Syntax</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         Data type syntax
        </para>
       </entry>
       <entry>
        <para>
         Explanation
        </para>
       </entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <para>
         DATE
        </para>
       </entry>
       <entry>
        <para>
         Stores date and time
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    General rules
   </emphasis></para>

   <itemizedlist>
    <listitem>
     <para>
      DATE is a date/time data type.
     </para>
    </listitem>
    <listitem>
     <para>
      Date and time are stored in DATE. The time zone is not stored.
     </para>
    </listitem>
   </itemizedlist>

   <para><emphasis role="bold">
    Note
   </emphasis></para>

   <para>
    If the DATE type of orafce is used in DDL statements such as table definitions,
    always set search_path before executing a DDL statement. Even if search_path
    is changed after definition, the data type will be the DATE type of LightDB.
   </para>

   <para><emphasis role="bold">
    Information
   </emphasis></para>

   <para>
    The DATE type of orafce is equivalent to the TIMESTAMP type of LightDB.
    Therefore, of the existing functions of LightDB, functions for which
    the data type of the argument is TIMESTAMP can be used.
   </para>
  </sect3>
  <sect3>
   <title>RAW</title>

   <para><emphasis role="bold">
    Syntax
   </emphasis></para>

   <para>
    Specify the RAW type as follows.
   </para>

   <table>
    <title>RAW Syntax</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         RAW type syntax
        </para>
       </entry>
       <entry>
        <para>
         Explanation
        </para>
       </entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <para>
         RAW(len)
        </para>
       </entry>
       <entry>
        <para>
        Store variable-length Binary data. External representation is hexadecimal.
        The len is only used to be compatible with oracle, it has no effect.
        the binary data can be any length. 
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    General rules
   </emphasis></para>

   <itemizedlist>
    <listitem>
     <para>
      RAW is a variable-length hex data type.
     </para>
    </listitem>
    <listitem>
     <para>
      Hex strings are of variable length. The specified value will be stored as binary data. The upper limit for this data type is approximately one gigabyte. 
     </para>
    </listitem>
   </itemizedlist>

  </sect3>

  <sect3>
   <title>PLS_INTEGER</title>

   <para><emphasis role="bold">
    Syntax
   </emphasis></para>

   <para>
    Specify the PLS_INTEGER type as follows.
   </para>

   <table>
    <title>PLS_INTEGER Syntax</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>
        <para>
         PLS_INTEGER type syntax
        </para>
       </entry>
       <entry>
        <para>
         Explanation
        </para>
       </entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <para>
         PLS_INTEGER
        </para>
       </entry>
       <entry>
        <para>
        The PLS_INTEGER data type stores signed integers in the range -2,147,483,648 through 2,147,483,647, represented in 32 bits.
        </para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    General rules
   </emphasis></para>

   <itemizedlist>
    <listitem>
     <para>
        PLS_INTEGER behaves like int4. 
     </para>
    </listitem>
   </itemizedlist>
  </sect3>
 </sect2>

 <sect2>
  <title>Queries</title>

  <para>
   The following queries are supported:
  </para>

  <itemizedlist>
   <listitem>
    <para>DUAL Table</para>
   </listitem>
  </itemizedlist>

  <para>
   DUAL table is a virtual table provided by the system.
   Use when executing SQL where access to a base table is not required,
   such as when performing tests to get result expressions such as functions and operators.
  </para>

  <para><emphasis role="bold">
   Example
  </emphasis></para>

  <para>
   In the following example, the current system date is returned.
  </para>

  <programlisting>
   SELECT  CURRENT_DATE  "date" FROM DUAL;
       date
   ------------
    2013-05-14
   (1 row)
  </programlisting>
 </sect2>

 <sect2>
  <title>SQL Functions Reference</title>

  <sect3>
   <title>Mathematical Functions</title>

   <para>
    The following mathematical functions are supported:
   </para>

   <itemizedlist>
    <listitem>
     <para>BIN_TO_NUM</para>
    </listitem>
    <listitem>
     <para>BITAND</para>
    </listitem>
    <listitem>
     <para>BITOR</para>
    </listitem>
    <listitem>
     <para>BITXOR</para>
    </listitem>
    <listitem>
     <para>COSH</para>
    </listitem>
    <listitem>
     <para>REMAINDER</para>
    </listitem>
    <listitem>
     <para>ROUND_TIES_TO_EVEN </para>
    </listitem>
    <listitem>
     <para>SINH</para>
    </listitem>
    <listitem>
     <para>TANH</para>
    </listitem>
   </itemizedlist>

   <sect4>
    <title>BIN_TO_NUM</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     BIN_TO_NUM converts a bit vector to its equivalent number. 
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     BIN_TO_NUM(VARIADIC integer []) returns int
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Each argument to this function represents a bit in the bit vector.
      </para>
     </listitem>
     <listitem>
      <para>
       This function takes as arguments any integer data type, or any noninteger data type that can be implicitly converted to integer. 
      </para>
     </listitem>
     <listitem>
      <para>
       BIN_TO_NUM is useful in data warehousing applications for selecting groups of interest from a materialized view using grouping sets. 
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using BIN_TO_NUM for converting, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
SELECT BIN_TO_NUM(1,0,1,0) FROM DUAL;
 bin_to_num 
------------
         10
(1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>BITAND</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Performs a bitwise AND operation.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     BITAND(int1 integers, int2 integers) returns bigint
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       BITAND performs an AND operation on each bit of two integers,
       and returns the result.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify integer type values.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is BIGINT.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, the result of the AND operation on numeric
     literals 5 and 3 is returned.
    </para>

    <programlisting>
    SELECT BITAND(5,3) FROM DUAL;
     bitand
    -------
          1
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>BITOR</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Performs a bitwise OR operation.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     BITOR(int1 bigint, int2 bigint) returns bigint
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       BITOR performs an OR operation on each bit of two bigint,
       and returns the result.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify bigint type values.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is BIGINT.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using BITOR, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, the result of the OR operation on numeric
     literals 5 and 3 is returned.
    </para>

    <programlisting>
SELECT BITOR(5,3) FROM DUAL;
 bitor 
-------
     7
(1 row)
    </programlisting>
   </sect4>
   <sect4>
    <title>BITXOR</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Performs a bitwise XOR operation.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     BITXOR(int1 bigint, int2 bigint) returns bigint
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       BITXOR performs an XOR operation on each bit of two integers,
       and returns the result.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify bigint type values.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is BIGINT.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using BITXOR, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, the result of the XOR operation on numeric
     literals 5 and 3 is returned.
    </para>

    <programlisting>
SELECT BITXOR(5,3) FROM DUAL;
 bitxor 
--------
      6
(1 row
    </programlisting>
   </sect4>

   <sect4>
    <title>COSH</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Calculates the hyperbolic cosine of a number.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     COSH(num numeric) returns double precision
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       COSH returns the hyperbolic cosine of the specified number.
      </para>
     </listitem>
     <listitem>
      <para>
       The number must be a numeric data type.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is DOUBLE PRECISION.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, the hyperbolic cosine of the numeric
     literal 2.236 is returned.
    </para>

    <programlisting>
    SELECT COSH(2.236) FROM DUAL;
          cosh
    -----------------
    4.7313591000247
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>REMAINDER</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns the remainder of n2 divided by n1. 
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     REMAINDER(n2 numeric, n1 numeric) returns numeric
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function takes as arguments any numeric data type or any nonnumeric data type that can be implicitly converted to a numeric data type. 
      </para>
     </listitem>
     <listitem>
      <para>
       The MOD function is similar to REMAINDER except that it uses FLOOR in its formula, whereas REMAINDER uses ROUND. 
      </para>
     </listitem>
     <listitem>
      <para>
       If n1 != 0, then the remainder is n2 - (n1*N) where N is the integer nearest n2/n1. If n2/n1 equals x.5, then N is the nearest even integer. 
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using REMAINDER, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
SELECT REMAINDER(5.5,2) FROM DUAL;
 remainder 
-----------
      -0.5
(1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>ROUND_TIES_TO_EVEN </title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     The function returns n rounded to integer places.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     ROUND_TIES_TO_EVEN(n NUMERIC,integer int4 DEFAULT 0) returns numeric
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If integer is positive, n is rounded to integer places to the right of the decimal point. 
      </para>
     </listitem>
     <listitem>
      <para>
       If integer is not specified, then n is rounded to 0 places. 
      </para>
     </listitem>
     <listitem>
      <para>
       If integer is negative, then n is rounded to integer places to the left of the decimal point. 
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using ROUND_TIES_TO_EVEN, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     The following example rounds a number to one decimal point to the right:
    </para>

    <programlisting>
SELECT ROUND_TIES_TO_EVEN(45.177,1) "ROUND_EVEN" FROM DUAL;
 ROUND_EVEN 
------------
       45.2
(1 row)
    </programlisting>

    <para>
     The following example rounds a number to one decimal point to the left:
    </para>

    <programlisting>
SELECT ROUND_TIES_TO_EVEN(45.177,-1) "ROUND_EVEN" FROM DUAL;
 ROUND_EVEN 
------------
         50
(1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>SINH</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Calculates the hyperbolic sine of a number.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     SINH(num numeric) returns double precision
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       SINH returns the hyperbolic sine of the specified number.
      </para>
     </listitem>
     <listitem>
      <para>
       The number must be a numeric data type.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is DOUBLE PRECISION.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, the hyperbolic sine of the
     numeric literal 1.414 is returned.
    </para>

    <programlisting>
    SELECT SINH(1.414) FROM DUAL;
          sinh
    -----------------
    1.93460168824956
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>TANH</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Calculates the hyperbolic tangent of a number.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     TANH(num numeric) returns double precision
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       TANH returns the hyperbolic tangent of the specified number.
      </para>
     </listitem>
     <listitem>
      <para>
       The number must be a numeric data type.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is DOUBLE PRECISION.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, the hyperbolic tangent of the numeric
     literal 3 is returned.
    </para>

    <programlisting>
    SELECT TANH(3) FROM DUAL;
          tanh
    -----------------
    0.995054753686731
    (1 row)
    </programlisting>
   </sect4>
  </sect3>

  <sect3>
   <title>String Functions</title>

   <para>
    The following string functions are supported:
   </para>

   <itemizedlist>
    <listitem>
     <para>BTRIM</para>
    </listitem>
    <listitem>
     <para>INSTR</para>
    </listitem>
    <listitem>
     <para>INSTRB</para>
    </listitem>
    <listitem>
     <para>LENGTH</para>
    </listitem>
    <listitem>
     <para>LENGTHB</para>
    </listitem>
    <listitem>
     <para>LPAD</para>
    </listitem>
    <listitem>
     <para>LTRIM</para>
    </listitem>
    <listitem>
     <para>NLSSORT</para>
    </listitem>
    <listitem>
     <para>REGEXP_COUNT</para>
    </listitem>
    <listitem>
     <para>REGEXP_INSTR</para>
    </listitem>
    <listitem>
     <para>REGEXP_LIKE</para>
    </listitem>
    <listitem>
     <para>REGEXP_SUBSTR</para>
    </listitem>
    <listitem>
     <para>REGEXP_REPLACE</para>
    </listitem>
    <listitem>
     <para>REPLACE</para>
    </listitem>
    <listitem>
     <para>RPAD</para>
    </listitem>
    <listitem>
     <para>RTRIM</para>
    </listitem>
    <listitem>
     <para>SOUNDEX</para>
    </listitem>
    <listitem>
     <para>SUBSTR</para>
    </listitem>
    <listitem>
     <para>SUBSTRB</para>
    </listitem>
   </itemizedlist>

   <sect4>
    <title>BTRIM</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Removes the specified characters from the beginning and end of a string.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     BTRIM(str text) returns text
     BTRIM(str text, trimChars text) returns text
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       BTRIM returns a string with <emphasis>trimChars</emphasis> removed from the
       beginning and end of string <emphasis>str</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       If multiple trim characters are specified, all characters matching the trim characters
       are removed. If <emphasis>trimChars</emphasis> is omitted, all leading and trailing
       halfwidth spaces are removed.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is TEXT.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       BTRIM does not exist for Oracle databases.
      </para>
     </listitem>
     <listitem>
      <para>
       The CHAR type specification for BTRIM uses orafce for its behavior, which is different
       to that of BTRIM of LightDB. The search_path parameter must be modified for it to
       behave the same as the specification described above.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Information
    </emphasis></para>

    <para>
     The general rule for BTRIM of LightDB is as follows:
    </para>

    <itemizedlist>
     <listitem>
      <para>
       If the string is CHAR type, trailing spaces are removed
       and then the trim characters are removed.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "The SQL Language" > "Functions and Operators" > "String Functions and Operators"
       in the LightDB Documentation for information on BTRIM.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, a string that has had "a" removed
     from both ends of "aabcaba" is returned.
    </para>

    <programlisting>
    SELECT BTRIM('aabcaba','a') FROM DUAL;
     btrim
    -------
     bcab
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>INSTR</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns the position of a substring in a string.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     INSTR(str1 text, str2 text) returns integer
     INSTR(str1 text, str2 text, startPos integer) returns integer
     INSTR(str1 text, str2 text, startPos integer, occurrences integer) returns integer
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       INSTR searches for substring <emphasis>str2</emphasis> in string
       <emphasis>str1</emphasis> and returns the position (in characters)
       in <emphasis>str1</emphasis> of the first character of the occurrence.
      </para>
     </listitem>
     <listitem>
      <para>
       The search starts from the specified start position <emphasis>startPos</emphasis>
       in <emphasis>str1</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       When <emphasis>startPos</emphasis> is 0 or negative, the start position
       will be the specified number of characters from the left of the end of
       <emphasis>str1</emphasis>, and INSTR will search backward from that point.
      </para>
     </listitem>
     <listitem>
      <para>
       If the start position is not specified, the search will be performed
       from the beginning of <emphasis>str1</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       If <emphasis>occurrences</emphasis> is specified, the position in
       <emphasis>str1</emphasis> of the nth occurrence of <emphasis>str2</emphasis>
       is returned. Only positive numbers can be specified.
      </para>
     </listitem>
     <listitem>
      <para>
       If <emphasis>occurrences</emphasis> is not specified, the start position
       of the first occurrence that is found is returned.
      </para>
     </listitem>
     <listitem>
      <para>
       If <emphasis>str2</emphasis> is not found in <emphasis>str1</emphasis>,
       0 is returned.
      </para>
     </listitem>
     <listitem>
      <para>
       For <emphasis>startPos</emphasis> and <emphasis>occurrences</emphasis>,
       specify a SMALLINT or INTEGER type.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is INTEGER.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, characters "BC" are found in string "ABCACBCAAC",
     and the position of those characters is returned.
    </para>

    <programlisting>
    SELECT INSTR('ABCACBCAAC','BC') FROM DUAL;
     instr
    -------
         2
    (1 row)

    SELECT INSTR('ABCACBCAAC','BC',-1,2) FROM DUAL;
     instr
    -------
         2
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>INSTRB</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     The INSTRB function searches a string for a substring using bytes and returns the position in the string that is the first byte of a specified occurrence of the substring.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     INSTRB( p_source text, p_search text, p_position int4  default 1, p_occurrence  int4  default 1) RETURNS integer
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       INSTRB searches for substring <emphasis>p_search</emphasis> in string
       <emphasis>p_source</emphasis> and returns the position (in bytes)
       in <emphasis>p_source</emphasis> of the first byte of the occurrence.
      </para>
     </listitem>
     <listitem>
      <para>
       The search starts from the specified start position <emphasis>p_position</emphasis>
       in <emphasis>p_source</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       When <emphasis>p_position</emphasis> is 0 or negative, it will raise an error. 
       It is different from ORACLE, in oracle , p_position will be the specified number of bytes from the left of the end of
       <emphasis>p_source</emphasis>, and INSTRB will search backward from that point.
      </para>
     </listitem>
     <listitem>
      <para>
       If the start position is not specified, the search will be performed
       from the beginning of <emphasis>p_source</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       If <emphasis>p_occurrence</emphasis> is specified, the position in
       <emphasis>p_source</emphasis> of the nth occurrence of <emphasis>p_search</emphasis>
       is returned. Only positive numbers can be specified.
      </para>
     </listitem>
     <listitem>
      <para>
       If <emphasis>occurrences</emphasis> is not specified, the start position
       of the first occurrence that is found is returned.
      </para>
     </listitem>
     <listitem>
      <para>
       If <emphasis>p_search</emphasis> is not found in <emphasis>p_source</emphasis>,
       0 is returned.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is integer.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using INSTRB, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, characters "on" are found in string "hhh测试onhx",
     and the position of those bytes is returned.
    </para>

    <programlisting>
SELECT INSTRB('hhh测试onhx', 'on') FROM DUAL;
 instrb 
--------
     10
(1 row)

SELECT INSTRB('hhh测试onhx on xxxx', 'on', 7, 2) FROM DUAL;
 instrb 
--------
     15
(1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>LENGTH</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns the length of a string in number of characters.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     LENGTH(str text) returns integer
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       LENGTH returns the number of characters in string <emphasis>str</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       If the string is CHAR type, trailing spaces are included in the length.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is INTEGER.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     The LENGTH specification above uses orafce for its behavior, which is different
     to that of LENGTH of LightDB. The search_path parameter must be modified for
     it to behave according to the orafce specification.
    </para>

    <para><emphasis role="bold">
     Information
    </emphasis></para>

    <para>
     The general rule for LENGTH of LightDB is as follows:
    </para>

    <itemizedlist>
     <listitem>
      <para>
       If the string is CHAR type, trailing spaces are not included in the length.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "The SQL Language" > "Functions and Operators" > "String Functions and Operators"
       in the LightDB Documentation for information on LENGTH.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, the number of characters in column col2
     (defined using CHAR(10)) in table t1 is returned.
    </para>

    <programlisting>
    SELECT col2,LENGTH(col2) FROM t1 WHERE col1 = '1001';
        col2    | length
    ------------+--------
     AAAAA      |     10
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>LENGTHB</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns the length of a string in number of bytes.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     LENGTHB(str text) returns integer
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       LENGTHB returns the number of bytes  in string <emphasis>str</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       If the string is CHAR type, trailing spaces are included in the length.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is INTEGER.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, the number of bytes in column col2 (defined using CHAR(10))
     in table t1 is returned. Note that, in the second SELECT statement, each character in
     "*" has a length of 3 bytes, for a total of 9 bytes, and 7 bytes are added for the 7
     trailing spaces. This gives a result of 16 bytes.
    </para>

    <programlisting>
    SELECT col2,LENGTHB(col2) FROM t1 WHERE col1 = '1001';
         col2      | lengthb
    ---------------+---------
     AAAAA         |      10
    (1 row)

    SELECT col2,LENGTHB(col2) FROM t1 WHERE col1 = '1004';
         col2      | lengthb
    ---------------+---------
     ***           |      16
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>LPAD</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Left-pads a string to a specified length with a sequence of characters.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     LPAD(str text, len integer) returns text
     LPAD(str text, len integer, paddingStr text) returns text
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       LPAD returns the result after repeatedly padding the beginning of string
       <emphasis>str</emphasis> with padding characters <emphasis>paddingStr</emphasis>
       until the string reaches length <emphasis>len</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       If the string is CHAR type, the padding characters are added to
       the string without removing trailing spaces.
      </para>
     </listitem>
     <listitem>
      <para>
       In the resultant string, fullwidth characters are recognized as
       having a length of 2, and halfwidth characters having a length
       of 1. If a fullwidth character cannot be included in the resultant
       string because there is only space available for one halfwidth
       character, the string is padded with a single-byte space.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is TEXT.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     The LPAD specification above uses orafce for its behavior, which is different
     to that of LPAD of LightDB. The search_path parameter must be modified for it
     to behave according to the orafce specification.
    </para>

    <para><emphasis role="bold">
     Information
    </emphasis></para>

    <para>
     The general rules for LPAD of LightDB are as follows:
    </para>

    <itemizedlist>
     <listitem>
      <para>
       If the string is CHAR type, trailing spaces are removed and then the padding
       characters are added to the string.
      </para>
     </listitem>
     <listitem>
      <para>
       The result length is the number of characters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "The SQL Language" > "Functions and Operators" > "String Functions and Operators"
       in the LightDB Documentation for information on LPAD.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, a 10-character string that has been formed by
     left-padding the string "abc" with "a" is returned.
    </para>

    <programlisting>
    SELECT LPAD('abc',10,'a') FROM DUAL;
        lpad
    ------------
     aaaaaaaabc
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>LTRIM</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Removes the specified characters from the beginning of a string.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     LTRIM(str text) returns text
     LTRIM(str text, trimChars text) returns text
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       LTRIM returns a string with <emphasis>trimChars</emphasis> removed from
       the beginning of string <emphasis>str</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       If multiple trim characters are specified, all characters matching the
       trim characters are removed. If <emphasis>trimChars</emphasis> is omitted,
       all leading halfwidth spaces are removed.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is TEXT.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     The LTRIM specification above uses orafce for its behavior, which is different
     to that of LTRIM of LightDB. The search_path parameter must be modified for it
     to behave according to the orafce specification.
    </para>

    <para><emphasis role="bold">
     Information
    </emphasis></para>

    <para>
     The general rules for LTRIM of LightDB are as follows:
    </para>

    <itemizedlist>
     <listitem>
      <para>
       If the string is CHAR type, trailing spaces are removed and then
       the trim characters are removed.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "The SQL Language" > "Functions and Operators" > "String Functions and Operators"
       in the LightDB Documentation for information on LTRIM.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, a string that has had "ab" removed from
     the beginning of "aabcab" is returned.
    </para>

    <programlisting>
    SELECT LTRIM('aabcab','ab') FROM DUAL;
     ltrim
    -------
     cab
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>NLSSORT</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns a byte string that denotes the lexical order of the locale (COLLATE).
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     NLSSORT(str text) returns bytea
     NLSSORT(str text, locale text) returns bytea
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       NLSSORT is used for comparing and sorting in the collating sequence
       of a locale (COLLATE) that differs from the default locale.
      </para>
     </listitem>
     <listitem>
      <para>
       Values that can be specified for the locale differ according to the
       operating system of the database server.
      </para>
     </listitem>
     <listitem>
      <para>
       If the locale is omitted, it is necessary to use set_nls_sort to set the locale
       in advance. To set the locale using set_nls_sort, execute a SELECT statement.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is BYTEA.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example of setting set_nls_sort using a SELECT statement
    </emphasis></para>

    <programlisting>
     SELECT set_nls_sort('en_US.UTF8');
    </programlisting>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     If specifying locale encoding, ensure it matches the database encoding.
    </para>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "Server Administration" > "Localization" > "Locale Support" in the
     LightDB Documentation for information on the locales that can be specified.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <table>
     <title>Composition of table (t3)</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>
         <para>
          col1
         </para>
        </entry>
        <entry>
         <para>
          col2
         </para>
        </entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>
         <para>
          1001
         </para>
        </entry>
        <entry>
         <para>
          aabcababc
         </para>
        </entry>
       </row>

       <row>
        <entry>
         <para>
          2001
         </para>
        </entry>
        <entry>
         <para>
          abcdef
         </para>
        </entry>
       </row>

       <row>
        <entry>
         <para>
          3001
         </para>
        </entry>
        <entry>
         <para>
          aacbaab
         </para>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>
     In the following example, the result of sorting column col2 in table t3 by "da_DK.UTF8" is returned.
    </para>

    <programlisting>
    SELECT col1,col2 FROM t3 ORDER BY NLSSORT(col2,'da_DK.UTF8');
     col1 |    col2
    ------+------------
     2001 | abcdef
     1001 | aabcababc
     3001 | aacbaab
    (3 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>REGEXP_COUNT</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Searches a string for a regular expression, and returns a count of the matches.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     REGEXP_COUNT(string text, pattern text) returns integer
     REGEXP_COUNT(string text, pattern text, startPos integer) returns integer
     REGEXP_COUNT(string text, pattern text, startPos integer, flags text) returns integer
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       REGEXP_COUNT returns the number of times <emphasis>pattern</emphasis> occurs
       in a source <emphasis>string</emphasis>.
       It returns an integer indicating the number of occurrences of <emphasis>pattern</emphasis>.
       If no match is found, then the function returns 0.
      </para>
     </listitem>
     <listitem>
      <para>
       The search starts from the specified start position <emphasis>startPos</emphasis> in
       <emphasis>string</emphasis>, default starts from the beginning of <emphasis>string</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       <emphasis>startPos</emphasis> is a positive integer, negative values to search from
       the end of <emphasis>string</emphasis> are not allowed.
      </para>
     </listitem>
     <listitem>
      <para>
       <emphasis>flags</emphasis> is a character expression that lets you change
       the default matching behavior of the function.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     The value of <emphasis>flags</emphasis> can include one or more of the following characters:
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       'i': case-insensitive matching.
      </para>
     </listitem>
     <listitem>
      <para>
       'c': case-sensitive and accent-sensitive matching.
      </para>
     </listitem>
     <listitem>
      <para>
       'n': the period (.) match the newline character. By default the period
       does not match the newline character.
      </para>
     </listitem>
     <listitem>
      <para>
       'm': treats the source string as multiple lines.
      </para>
     </listitem>
     <listitem>
      <para>
       'x': ignores whitespace characters. By default, whitespace characters match themselves.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     If you omit <emphasis>flags</emphasis> then:
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       The default is case and accent sensitivity.
      </para>
     </listitem>
     <listitem>
      <para>
       A period (.) does not match the newline character.
      </para>
     </listitem>
     <listitem>
      <para>
       The source string is treated as a single line.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     If using the REGEXP_COUNT function, it is necessary to specify "oracle" for search_path in advance.
    </para>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "Notes on Using orafce" for information on how to edit search_path.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
    SELECT REGEXP_COUNT('a'||CHR(10)||'d', 'a.d') FROM DUAL;
     regexp_count 
    --------------
                0
    (1 row)

    SELECT REGEXP_COUNT('a'||CHR(10)||'d', 'a.d', 1, 'm') FROM DUAL;
     regexp_count 
    --------------
                0
    (1 row)

    SELECT REGEXP_COUNT('a'||CHR(10)||'d', 'a.d', 1, 'n') FROM DUAL;
     regexp_count 
    --------------
                1
    (1 row)

    SELECT REGEXP_COUNT('a'||CHR(10)||'d', '^d$', 1, 'm') FROM DUAL;
     regexp_count 
    --------------
                1
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>REGEXP_INSTR</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns the beginning or ending position within the string where the match for a pattern was located.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     REGEXP_INSTR(string text, pattern text) returns integer
     REGEXP_INSTR(string text, pattern text, startPos integer) returns integer
     REGEXP_INSTR(string text, pattern text, startPos integer, occurrence integer) returns integer
     REGEXP_INSTR(string text, pattern text, startPos integer, occurrence integer) returns integer
     REGEXP_INSTR(string text, pattern text, startPos integer, occurrence integer, return_opt integer) returns integer
     REGEXP_INSTR(string text, pattern text, startPos integer, occurrence integer, return_opt integer, flags text) returns integer
     REGEXP_INSTR(string text, pattern text, startPos integer, occurrence integer, return_opt integer, flags text) returns integer
     REGEXP_INSTR(string text, pattern text, startPos integer, occurrence integer, return_opt integer, flags text, group integer) returns integer
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       REGEXP_INSTR returns an integer indicating the beginning or ending position of
       the matched substring, depending on the value of the <emphasis>return_opt</emphasis>
       argument. If no match is found, then the function returns 0.
      </para>
     </listitem>
     <listitem>
      <para>
       The search starts from the specified start position <emphasis>startPos</emphasis> in
       <emphasis>string</emphasis>, default starts from the beginning of <emphasis>string</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       <emphasis>startPos</emphasis> is a positive integer, negative values to search from
       the end of <emphasis>string</emphasis> are not allowed.
      </para>
     </listitem>
     <listitem>
      <para>
       <emphasis>occurrence</emphasis> is a positive integer indicating which occurrence of
       <emphasis>pattern</emphasis> in <emphasis>string</emphasis> should be search for.
       The default is 1, meaning the first occurrence of <emphasis>pattern</emphasis> in
       <emphasis>string</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       <emphasis>return_opt</emphasis> lets you specify what should be returned
       in relation to the occurrence:
      </para>
      <itemizedlist>
       <listitem>
        <para>
         return_opt = 0, the position of the first character of the occurrence is returned.
         This is the default.
        </para>
       </listitem>
       <listitem>
        <para>
         return_opt = 1, the position of the character following the occurrence is returned.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       <emphasis>flags</emphasis> is a character expression that lets you change the default
       matching behavior of the function.  See REGEXP_COUNT for detailed information.
      </para>
     </listitem>
     <listitem>
      <para>
       For a <emphasis>pattern</emphasis> with capture group, <emphasis>group</emphasis> is a
       positive integer indicating which capture group in <emphasis>pattern</emphasis> shall be
       returned by the function. Capture groups can be nested, they are numbered in order in
       which their left parentheses appear in <emphasis>pattern</emphasis>.
       If <emphasis>group</emphasis> is zero, then the position of the entire substring that matches
       the pattern is returned. If <emphasis>group</emphasis> value exceed the number of capture
       groups in <emphasis>pattern</emphasis>, the function returns zero.
       A null <emphasis>group</emphasis> value returns <emphasis>NULL</emphasis>.
       The default value for <emphasis>group</emphasis> is zero.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     If using the REGEXP_INSTR function, it is necessary to specify "oracle" for search_path in advance.
    </para>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "Notes on Using orafce" for information on how to edit search_path.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
    SELECT REGEXP_INSTR('1234567890', '(123)(4(56)(78))') FROM DUAL;
     regexp_instr 
    --------------
                1
    (1 row)

    SELECT REGEXP_INSTR('1234567890', '(4(56)(78))', 3) FROM DUAL;
     regexp_instr 
    --------------
                4
    (1 row)

    SELECT REGEXP_INSTR('123 123456 1234567, 1234567 1234567 12', '[^ ]+', 1, 6) FROM DUAL;
     regexp_instr 
    --------------
               37

    (1 row)

    SELECT REGEXP_INSTR('199 Oretax Prayers, Riffles Stream, CA', '[S|R|P][[:alpha:]]{6}', 3, 2, 1) FROM DUAL;
     regexp_instr 
    --------------
               28
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>REGEXP_LIKE</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Condition in the WHERE clause of a query, causing the query to return rows that match the given pattern.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     REGEXP_LIKE(string text, pattern text) returns boolean
     REGEXP_LIKE(string text, pattern text, flags text) returns boolean
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       REGEXP_LIKE is similar to the LIKE condition, except it performs regular expression
       matching instead of the simple pattern matching performed by LIKE.
      </para>
     </listitem>
     <listitem>
      <para>
       Returns a boolean, <emphasis>true</emphasis> when <emphasis>pattern</emphasis> match
       in <emphasis>string</emphasis>, <emphasis>false</emphasis> otherwise.
      </para>
     </listitem>
     <listitem>
      <para>
       <emphasis>flags</emphasis> is a character expression that lets you change the default
       matching behavior of the function. See REGEXP_COUNT for detailed information.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     If using the REGEXP_LIKE function, it is necessary to specify "oracle" for search_path in advance.
    </para>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "Notes on Using orafce" for information on how to edit search_path.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
    SELECT REGEXP_LIKE('a'||CHR(10)||'d', 'a.d', 'm') FROM DUAL;
     regexp_like 
    -------------
     f
    (1 row)

    SELECT REGEXP_LIKE('a'||CHR(10)||'d', 'a.d', 'n') FROM DUAL;
     regexp_like 
    -------------
     t
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>REGEXP_SUBSTR</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns the string that matches the pattern specified in the call to the function.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     REGEXP_SUBSTR(string text, pattern text) returns text
     REGEXP_SUBSTR(string text, pattern text, startPos integer) returns text
     REGEXP_SUBSTR(string text, pattern text, startPos integer, occurrence integer) returns text
     REGEXP_SUBSTR(string text, pattern text, startPos integer, occurrence integer, flags text) returns text
     REGEXP_SUBSTR(string text, pattern text, startPos integer, occurrence integer, flags text, group int) returns text
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       REGEXP_SUBSTR returns the matched substring resulting from matching
       a POSIX regular expression pattern to a string. If no match is found,
       then the function returns <emphasis>NULL</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       The search starts from the specified start position <emphasis>startPos</emphasis> in
       <emphasis>string</emphasis>, default starts from the beginning of <emphasis>string</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       <emphasis>startPos</emphasis> is a positive integer, negative values to search from
       the end of <emphasis>string</emphasis> are not allowed.
      </para>
     </listitem>
     <listitem>
      <para>
       <emphasis>occurrence</emphasis> is a positive integer indicating which occurrence of
       <emphasis>pattern</emphasis> in <emphasis>string</emphasis> should be search for.
       The default is 1, meaning the first occurrence of <emphasis>pattern</emphasis> in
       <emphasis>string</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       <emphasis>flags</emphasis> is a character expression that lets you change the default
       matching behavior of the function.  See REGEXP_COUNT for detailed information.
      </para>
     </listitem>
     <listitem>
      <para>
       For a <emphasis>pattern</emphasis> with capture group, *group* is a positive integer
       indicating which capture group in <emphasis>pattern</emphasis> shall be returned by
       the function. Capture groups can be nested, they are numbered in order in which their
       left parentheses appear in <emphasis>pattern</emphasis>.
       If <emphasis>group</emphasis> is zero, then the position of the entire substring that
       matches the pattern is returned.
       If <emphasis>group</emphasis> value exceed the number of capture groups in <emphasis>
       pattern</emphasis>, the function returns <emphasis>NULL</emphasis>.
       A null <emphasis>group</emphasis> value returns <emphasis>NULL</emphasis>.
       The default value for <emphasis>group</emphasis> is zero.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     If using the REGEXP_SUBSTR function, it is necessary to specify "oracle" for search_path in advance.
    </para>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "Notes on Using orafce" for information on how to edit search_path.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
    SELECT REGEXP_SUBSTR('number of your street, zipcode town, FR', ',[^,]+') FROM DUAL;
     regexp_substr  
    ----------------
     , zipcode town
    (1 row)

    SELECT regexp_substr('number of your street, zipcode town, FR', ',[^,]+', 24) FROM DUAL;
     regexp_substr 
    ---------------
     , FR
    (1 row)

    SELECT regexp_substr('number of your street, zipcode town, FR', ',[^,]+', 1, 2) FROM DUAL;
     regexp_substr 
    ---------------
     , FR
    (1 row)

    SELECT regexp_substr('1234567890 1234567890', '(123)(4(56)(78))', 1, 1, 'i', 0) FROM DUAL;
     regexp_substr 
    ---------------
     12345678
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>REGEXP_REPLACE</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns the string that matches the pattern specified in the call to the function.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     REGEXP_REPLACE(string text, pattern text, replace_string text, startPos integer,
     occurrence integer, flags text) returns text
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       REGEXP_REPLACE returns a modified version of the source string where occurrences of
       a POSIX regular expression pattern found in the source string are replaced with the
       specified replacement string. If no match is found or the occurrence queried exceed
       the number of match, then the source string untouched is returned.
      </para>
     </listitem>
     <listitem>
      <para>
       The search and replacement starts from the specified start position
       <emphasis>startPos</emphasis> in <emphasis>string</emphasis>,
       default starts from the beginning of <emphasis>string</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       <emphasis>startPos</emphasis> is a positive integer, negative values to search from
       the end of <emphasis>string</emphasis> are not allowed.
      </para>
     </listitem>
     <listitem>
      <para>
       <emphasis>occurrence</emphasis> is a positive integer indicating which occurrence of
       <emphasis>pattern</emphasis> in <emphasis>string</emphasis> should be search for and
       replaced. The default is 0, meaning all occurrences of <emphasis>pattern</emphasis>
       in <emphasis>string</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       <emphasis>flags</emphasis> is a character expression that lets you change the default
       matching behavior of the function.  See REGEXP_COUNT for detailed information.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     If using the REGEXP_REPLACE function, it is necessary to specify "oracle" for search_path in advance.
    </para>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "Notes on Using orafce" for information on how to edit search_path.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
    SELECT regexp_replace('512.123.4567 612.123.4567', '([[:digit:]]{3})\.([[:digit:]]{3})\.([[:digit:]]{4})', '(\1) \2-\3') FROM DUAL;
            regexp_replace
    -------------------------------
     (512) 123-4567 (612) 123-4567
    (1 row)

    SELECT oracle.REGEXP_REPLACE('number   your     street,    zipcode  town, FR', '( ){2,}', ' ', 9);
                 regexp_replace             
    ----------------------------------------
     number   your street, zipcode town, FR
    (1 row)

    SELECT oracle.REGEXP_REPLACE('number   your     street,    zipcode  town, FR', '( ){2,}', ' ', 9, 2);
                   regexp_replace                
    ---------------------------------------------
     number   your     street, zipcode  town, FR
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>REPLACE</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns string with every occurrence of search_string replaced with replacement_string. 
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     REPLACE(string text, pattern text) returns text
     REPLACE(string text, pattern text, replace_string text) returns text
     REPLACE(string uuid, pattern text, replace_string text) returns text
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If replace_string is omitted or null, then all occurrences of search_string are removed.
       If search_string is null, then string is returned. 
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     The above REPLACE specification uses orafce for its behavior, which is different to that of REPLACE of LightDB. The search_path parameter must be modified for it to behave according to the orafce specification. 
    </para>

    <para><emphasis role="bold">
     Information
    </emphasis></para>

    <para>
     The general rules for REPLACE of LightDB are as follows:
    </para>

    <itemizedlist>
     <listitem>
      <para>
       If replace_string or search_string is null, then null is returned.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "Notes on Using orafce" for information on how to edit search_path.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
SELECT REPLACE('abcdAbcdasd', 'a') FROM DUAL;
  replace  
-----------
 bcdAbcdsd
(1 row)

SELECT REPLACE('abcdAbcdasd', 'a','c') FROM DUAL;
   replace   
-------------
 cbcdAbcdcsd
(1 row)

SELECT REPLACE('abcdAbcdasd', NULL,'c') FROM DUAL;
   replace   
-------------
 abcdAbcdasd
(1 row)

SELECT REPLACE('abcdAbcdasd', 'a',NULL) FROM DUAL;
  replace  
-----------
 bcdAbcdsd
(1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>RPAD</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Right-pads a string to a specified length with a sequence of characters.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     RPAD(str text, len integer) returns text
     RPAD(str text, len integer, paddingStr text) returns text
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       RPAD returns the result after repeatedly padding the end of string <emphasis>str</emphasis>
       with padding characters <emphasis>paddingStr</emphasis> until the string reaches length
       <emphasis>len</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       If the string is CHAR type, the padding characters are added to the string
       without removing trailing spaces.
      </para>
     </listitem>
     <listitem>
      <para>
       In the resultant string, fullwidth characters are recognized as having a length of 2,
       and halfwidth characters having a length of 1. If a fullwidth character cannot be
       included in the resultant string because there is only space available for one halfwidth
       character, the string is padded with a single-byte space.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is TEXT.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     The RPAD specification above uses orafce for its behavior, which is different
     to that of RPAD of LightDB. The search_path parameter must be modified for it
     to behave according to the orafce specification.
    </para>

    <para><emphasis role="bold">
     Information
    </emphasis></para>

    <para>
     The general rules for RPAD of LightDB are as follows:
    </para>

    <itemizedlist>
     <listitem>
      <para>
       If the string is CHAR type, trailing spaces are removed and then the padding
       characters are added to the string.
      </para>
     </listitem>
     <listitem>
      <para>
       The result length is the number of characters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "The SQL Language" > "Functions and Operators" > "String Functions and Operators"
       in the LightDB Documentation for information on RPAD.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, a 10-character string that has been formed
     by right-padding the string "abc" with "a" is returned.
    </para>

    <programlisting>
    SELECT RPAD('abc',10,'a') FROM DUAL;
        rpad
    ------------
     abcaaaaaaa
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>RTRIM</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Removes the specified characters from the end of a string.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     RTRIM(str text) returns text
     RTRIM(str text, trimChars text) returns text
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       RTRIM returns a string with <emphasis>trimChars</emphasis> removed from
       the end of string <emphasis>str</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       If multiple trim characters are specified, all characters matching the
       trim characters are removed. If <emphasis>trimChars</emphasis> is omitted,
       all trailing halfwidth spaces are removed.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is TEXT.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     The RTRIM specification above uses orafce for its behavior, which is different
     to that of RTRIM of LightDB. The search_path parameter must be modified for it
     to behave the same as the orafce specification.
    </para>

    <para><emphasis role="bold">
     Information
    </emphasis></para>

    <para>
     The general rules for RTRIM of LightDB are as follows:
    </para>

    <itemizedlist>
     <listitem>
      <para>
       If the string is CHAR type, trailing spaces are removed and then the trim characters are removed.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "The SQL Language" > "Functions and Operators" > "String Functions and Operators"
       in the LightDB Documentation for information on RTRIM.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, a string that has had "ab" removed from the end of "aabcab" is returned.
    </para>

    <programlisting>
    SELECT RTRIM('aabcab','ab') FROM DUAL;
     rtrim
    -------
     aabc
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>SOUNDEX</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     SOUNDEX returns a character string containing the phonetic representation of char.
     This function lets you compare words that are spelled differently, but sound alike in English. 
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     SOUNDEX(str text) returns text
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       The phonetic representation is defined in The Art of Computer Programming, Volume 3: Sorting and Searching, by Donald E. Knuth.
      </para>
     </listitem>
     <listitem>
      <para>
       Retain the first letter of the string and remove all other occurrences of the following letters: a, e, h, i, o, u, w, y.
      </para>
     </listitem>
     <listitem>
      <para>
       Assign numbers to the remaining letters as follows:
      </para>
      <programlisting>
b, f, p, v = 1
c, g, j, k, q, s, x, z = 2
d, t = 3
l = 4
m, n = 5
r = 6
      </programlisting>
     </listitem>
     <listitem>
      <para>
       If two or more letters with the same number were adjacent in the original name (before step 1), or adjacent except for any intervening h and w, then retain the first letter and omit rest of all the adjacent letters with same number.
      </para>
     </listitem>
     <listitem>
      <para>
       Return the first four bytes padded with 0.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     If using the SOUNDEX function, it is necessary to specify "oracle" for search_path in advance.
    </para>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "Notes on Using orafce" for information on how to edit search_path.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, a string that has had "ab" removed from the end of "aabcab" is returned.
    </para>

    <programlisting>
SELECT SOUNDEX('SMYTHE')=SOUNDEX('Smith') as same FROM DUAL;
 same 
------
 t
(1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>SUBSTR</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Extracts part of a string using characters to specify position and length.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     SUBSTR(str text, startPos integer) returns text
     SUBSTR(str text, startPos integer, len integer) returns text
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       SUBSTR extracts and returns a substring of string <emphasis>str</emphasis>,
       beginning at position <emphasis>startPos</emphasis>, for number of characters
       <emphasis>len</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       When <emphasis>startPos</emphasis> is positive, it will be the number of
       characters from the beginning of the string.
      </para>
     </listitem>
     <listitem>
      <para>
       When <emphasis>startPos</emphasis> is 0, it will be treated as 1.
      </para>
     </listitem>
     <listitem>
      <para>
       When <emphasis>startPos</emphasis> is negative, it will be the number of
       characters from the end of the string.
      </para>
     </listitem>
     <listitem>
      <para>
       When <emphasis>len</emphasis> is not specified, all characters to the end of the string
       are returned. NULL is returned when <emphasis>len</emphasis> is less than 1.
      </para>
     </listitem>
     <listitem>
      <para>
       For <emphasis>startPos</emphasis> and <emphasis>len</emphasis>, specify an integer or NUMERIC
       type. If numbers including decimal places are specified, they are truncated to integers.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is TEXT.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       There are two types of SUBSTR. One that behaves as described above and one that behaves
       the same as SUBSTRING. The search_path parameter must be modified for it to behave the
       same as the specification described above.
      </para>
     </listitem>
     <listitem>
      <para>
       If the change has not been implemented, SUBSTR is the same as SUBSTRING.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Information
    </emphasis></para>

    <para>
     The general rules for SUBSTRING of LightDB are as follows:
    </para>

    <itemizedlist>
     <listitem>
      <para>
       The start position will be from the beginning of the string,
       whether the start position is positive, 0, or negative.
      </para>
     </listitem>
     <listitem>
      <para>
       When <emphasis>len</emphasis> is not specified, all characters
       to the end of the string are returned.
      </para>
     </listitem>
     <listitem>
      <para>
       An empty string is returned if no string is extracted or <emphasis>len</emphasis>
       is less than 1.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "The SQL Language" > "Functions and Operators" > "String Functions and Operators"
       in the LightDB Documentation for information on SUBSTRING.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, part of the string "ABCDEFG" is extracted.
    </para>

    <programlisting>
    SELECT SUBSTR('ABCDEFG',3,4) "Substring" FROM DUAL;
     Substring
    -----------
     CDEF
    (1 row)

    SELECT SUBSTR('ABCDEFG',-5,4) "Substring" FROM DUAL;
     Substring
    -----------
     CDEF
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>SUBSTRB</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Extracts part of a string using bytes to specify position and length.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     SUBSTRB(str text, startPos integer) returns varchar2
     SUBSTRB(str text, startPos integer, len integer) returns varchar2
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       SUBSTR extracts and returns a substring of string <emphasis>str</emphasis>,
       beginning at byte position <emphasis>startPos</emphasis>, for number of byte
       <emphasis>len</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       When <emphasis>startPos</emphasis> is 0 or negative, extraction starts at the
       position found by subtracting 1 from the start position and shifting by that
       number of positions to the left.
      </para>
     </listitem>
     <listitem>
      <para>
       When <emphasis>len</emphasis> is not specified, all bytes to the end of the
       string are returned.
      </para>
     </listitem>
     <listitem>
      <para>
       An empty string is returned if no string is extracted or <emphasis>len</emphasis> is less than 1.
      </para>
     </listitem>
     <listitem>
      <para>
       For <emphasis>startPos</emphasis> and <emphasis>len</emphasis>, specify a SMALLINT or INTEGER type.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is VARCHAR2.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     The external specification of SUBSTRB is different to that of SUBSTR added by orafce,
     conforming with SUBSTRING of LightDB.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, part of the string "aaabbbccc" is extracted.
    </para>

    <programlisting>
    SELECT SUBSTRB('aaabbbccc',4,3) FROM DUAL;
     substrb
    -----------
     bbb
    (1 row)

    SELECT SUBSTRB('aaabbbccc',-2,6) FROM DUAL;
     substrb
    -----------
     aaa
    (1 row)
    </programlisting>
   </sect4>
  </sect3>

  <sect3>
   <title>Date/Time Functions</title>

   <para>
    The following date/time functions are supported:
   </para>

   <itemizedlist>
    <listitem>
     <para>ADD_MONTHS</para>
    </listitem>
    <listitem>
     <para>DBTIMEZONE</para>
    </listitem>
    <listitem>
     <para>LAST_DAY</para>
    </listitem>
    <listitem>
     <para>MONTHS_BETWEEN</para>
    </listitem>
    <listitem>
     <para>NEXT_DAY</para>
    </listitem>
    <listitem>
     <para>ROUND</para>
    </listitem>
    <listitem>
     <para>SESSIONTIMEZONE</para>
    </listitem>
    <listitem>
     <para>SYSDATE</para>
    </listitem>
    <listitem>
     <para>TRUNC</para>
    </listitem>
    <listitem>
     <para>TZ_OFFSET</para>
    </listitem>
   </itemizedlist>

   <para><emphasis role="bold">
    Note
   </emphasis></para>

   <para>
    If the DATE type only is shown in the date/time functions,
    these functions can be used in both orafce and LightDB.
   </para>

   <sect4>
    <title>ADD_MONTHS</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Adds months to a date.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     ADD_MONTHS(date DATE, months INTEGER) returns DATE
     ADD_MONTHS(date TIMESTAMP WITH TIME ZONE, months INTEGER) returns TIMESTAMP
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       ADD_MONTHS returns <emphasis>date</emphasis> plus <emphasis>months</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       For <emphasis>date</emphasis>, specify a DATE or TIMESTAMP WITH TIME ZONE type.
      </para>
     </listitem>
     <listitem>
      <para>
       For <emphasis>months</emphasis>, specify a SMALLINT or INTEGER type.
      </para>
     </listitem>
     <listitem>
      <para>
       If a negative value is specified for <emphasis>months</emphasis>,
       the number of months is subtracted from the date.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is DATE or TIMESTAMP.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     If using the DATE type of orafce, it is necessary to specify "oracle" for search_path in advance.
    </para>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "Notes on Using orafce" for information on how to edit search_path.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     The example below shows the result of adding 3 months to the date May 1, 2016.
    </para>

    <programlisting>
    SELECT ADD_MONTHS(DATE'2016/05/01',3) FROM DUAL;
         add_months
    ---------------------
     2016-08-01 00:00:00
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>DBTIMEZONE</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns the value of the database time zone.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     DBTIMEZONE() returns text
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       DBTIMEZONE returns the time zone value of the database.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is TEXT.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using DBTIMEZONE, it is necessary to specify "oracle" for search_path in advance.
      </para>
     </listitem>
     <listitem>
      <para>
       The time zone of the database is set to "GMT" by default.
       To change the time zone, change the "orafce.timezone" parameter.
       An example using the SET statement is shown below.
      </para>
      <programlisting>
       SET orafce.timezone = 'Japan';
      </programlisting>
     </listitem>
     <listitem>
      <para>
       The orafce.timezone settings can be set using any of the methods for setting server parameters.
      </para>
     </listitem>
     <listitem>
      <para>
       If the SQL statement is executed with orafce.timezone set, the following message may be displayed,
       however, the parameter settings are enabled, so you can ignore this.
      </para>
      <programlisting>
       WARNING:   unrecognized configuration parameter "orafce.timezone"
      </programlisting>
     </listitem>
     <listitem>
      <para>
       The time zones that can be set in "orafce.timezone" are the same as for the "TimeZone" server parameter.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "The SQL Language" > "Data Types" > "Date/Time Types" in the LightDB
       Documentation for information on the time zone.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, the DBTIMEZONE result is returned.
    </para>

    <programlisting>
     SELECT DBTIMEZONE() FROM DUAL;
      dbtimezone
     ------------
      GMT
     (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>LAST_DAY</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns the last day of the month in which the specified date falls.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     LAST_DAY(date DATE) returns DATE
     LAST_DAY(date TIMESTAMPTZ) returns TIMESTAMPTZ
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       LAST_DAY returns the last day of the month in which the specified date falls.
      </para>
     </listitem>
     <listitem>
      <para>
       For <emphasis>date</emphasis>, specify a DATE or TIMESTAMPTZ type.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is DATE or TIMESTAMPTZ.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     If using the DATE type of orafce, it is necessary to specify "oracle" for search_path in advance.
    </para>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "Notes on Using orafce" for information on how to edit search_path.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the example below, the last date of "February 01, 2016" is returned.
    </para>

    <programlisting>
    SELECT LAST_DAY(DATE'2016/02/01') FROM DUAL;
         last_day
    ---------------------
     2016-02-29 00:00:00
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>MONTHS_BETWEEN</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns the number of months between two dates.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     MONTHS_BETWEEN(date1 DATE, date2 DATE) returns NUMERIC
     MONTHS_BETWEEN(date1 TIMESTAMP WITH TIME ZONE, date2 TIMESTAMP WITH TIME ZONE) returns NUMERIC
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       MONTHS_BETWEEN returns the difference in the number of months between
       <emphasis>date1</emphasis> and <emphasis>date2</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       For <emphasis>date1</emphasis> and <emphasis>date2</emphasis>,
       specify a DATE or TIMESTAMPTZ type.
      </para>
     </listitem>
     <listitem>
      <para>
       If <emphasis>date2</emphasis> is earlier than <emphasis>date1</emphasis>,
       the return value will be negative.
      </para>
     </listitem>
     <listitem>
      <para>
       If two dates fall on the same day, or each of the two dates are the last day of the
       month to which they belong, an integer is returned. If the days are different, one
       month is considered to be 31 days, and a value with the difference in the number of
       days divided by 31 added is returned.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is DATE or NUMERIC.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     If using the DATE type of orafce, it is necessary to specify "oracle" for search_path in advance.
    </para>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "Notes on Using orafce" for information on how to edit search_path.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, the difference between the months of March 15,
     2016 and November 15, 2015 is returned.
    </para>

    <programlisting>
     SELECT MONTHS_BETWEEN(DATE'2016/03/15', DATE'2015/11/15') FROM DUAL;
      months_between
     ----------------
                    4
     (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>NEXT_DAY</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns the date of the first instance of a particular day of the week
     that follows the specified date.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     NEXT_DAY(date DATE, dayOfWk TEXT) returns DATE
     NEXT_DAY(date DATE, dayOfWk INTEGER) returns DATE
     NEXT_DAY(date TIMESTAMP WITH TIME ZONE, dayOfWk TEXT) returns TIMESTAMP
     NEXT_DAY(date TIMESTAMP WITH TIME ZONE, dayOfWk INTEGER) returns TIMESTAMP
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       NEXT_DAY returns the date matching the first instance of <emphasis>dayOfWk</emphasis>
       that follows <emphasis>date</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       For <emphasis>date</emphasis>, specify a DATE or TIMESTAMPTZ WITH TIME ZONE type.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify a numeric value or string indicating the day of the week.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Values that can be specified for the day
    </emphasis></para>

    <table>
     <title>Setting dayOfWk for NEXT_DAY Function</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>
         <para>
          Setting example
         </para>
        </entry>
        <entry>
         <para>
          Overview
         </para>
        </entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>
         <para>
          1
         </para>
        </entry>
        <entry>
         <para>
          1 (Sunday) to 7 (Saturday) can be specified
         </para>
        </entry>
       </row>

       <row>
        <entry>
         <para>
          'Sun', or 'Sunday'
         </para>
        </entry>
        <entry>
         <para>
          English display of the day
         </para>
        </entry>
       </row>

       <row>
        <entry>
         <para>
          '*'
         </para>
        </entry>
        <entry>
         <para>
          Japanese display of the day
         </para>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <itemizedlist>
     <listitem>
      <para>
       The data type of the return value is DATE or TIMESTAMP.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using the DATE type of orafce, it is necessary to specify "oracle" for search_path in advance.
      </para>
     </listitem>
     <listitem>
      <para>
       The ability to use Japanese for entering days is provided by the orafce proprietary specification.
       Japanese cannot be used for entering days when using date/time functions other than NEXT_DAY
       (such as TO_DATE).
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "Notes on Using orafce" for information on how to edit search_path.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the example below, the date of the first Friday on or after "May 1, 2016" is returned.
    </para>

    <programlisting>
    SELECT NEXT_DAY(DATE'2016/05/01', 'Friday') FROM DUAL;
          next_day
    ---------------------
     2016-05-06 00:00:00
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>ROUND</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Rounds a date.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     ROUND(date DATE) returns DATE
     ROUND(date DATE, fmt TEXT) returns DATE
     ROUND(date TIMESTAMP WITH TIME ZONE) returns TIMESTAMP WITH TIME ZONE
     ROUND(date TIMESTAMP WITH TIME ZONE, fmt TEXT) returns TIMESTAMP WITH TIME ZONE
     ROUND(date TIMESTAMP WITHOUT TIME ZONE) returns TIMESTAMP WITHOUT TIME ZONE
     ROUND(date TIMESTAMP WITHOUT TIME ZONE, fmt TEXT) returns TIMESTAMP WITHOUT TIME ZONE
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       ROUND returns a date rounded to the unit specified by format model <emphasis>fmt</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       For <emphasis>date</emphasis>, specify a DATE or TIMESTAMPTZ type.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the format model as a string.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Values that can be specified for the format model
    </emphasis></para>

    <table>
     <title>Setting Format Model for ROUND Function</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>
         <para>
          Format model
         </para>
        </entry>
        <entry>
         <para>
          Rounding unit
         </para>
        </entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>
         <para>
          Y,YY,YYY,YYYY,
         </para>
         <para>
          SYYYY,YEAR,SYEAR
         </para>
        </entry>
        <entry>
         <para>
          Year
         </para>
        </entry>
       </row>

       <row>
        <entry>
         <para>
          I,IY,IYY,IYYY
         </para>
        </entry>
        <entry>
         <para>
          Year (values including calendar weeks, in compliance with the ISO standard)
         </para>
        </entry>
       </row>

       <row>
        <entry>
         <para>
          Q
         </para>
        </entry>
        <entry>
         <para>
          Quarter
         </para>
        </entry>
       </row>

       <row>
        <entry>
         <para>
          WW
         </para>
        </entry>
        <entry>
         <para>
          Week (first day of the year)
         </para>
        </entry>
       </row>

       <row>
        <entry>
         <para>
          IW
         </para>
        </entry>
        <entry>
         <para>
          Week (Monday of that week)
         </para>
        </entry>
       </row>

       <row>
        <entry>
         <para>
          W
         </para>
        </entry>
        <entry>
         <para>
          Week (first weekday on which the first day of the month falls)
         </para>
        </entry>
       </row>

       <row>
        <entry>
         <para>
          DAY,DY,D
         </para>
        </entry>
        <entry>
         <para>
          Week (Sunday of that week)
         </para>
        </entry>
       </row>

       <row>
        <entry>
         <para>
          MONTH,MON,MM,RM
         </para>
        </entry>
        <entry>
         <para>
          Month
         </para>
        </entry>
       </row>

       <row>
        <entry>
         <para>
          CC,SCC
         </para>
        </entry>
        <entry>
         <para>
          Century
         </para>
        </entry>
       </row>

       <row>
        <entry>
         <para>
          DDD,DD,J
         </para>
        </entry>
        <entry>
         <para>
          Day
         </para>
        </entry>
       </row>

       <row>
        <entry>
         <para>
          HH,HH12,HH24
         </para>
        </entry>
        <entry>
         <para>
          Hour
         </para>
        </entry>
       </row>

       <row>
        <entry>
         <para>
          MI
         </para>
        </entry>
        <entry>
         <para>
          Minute
         </para>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <itemizedlist>
     <listitem>
      <para>
       If decimal places are rounded: for year, the boundary for rounding is July 1;
       for month, the day is 16; and for week, the weekday is Thursday.
      </para>
     </listitem>
     <listitem>
      <para>
       If <emphasis>fmt</emphasis> is omitted, the date is rounded by day.
      </para>
     </listitem>
     <listitem>
      <para>
       If the DATE type of LightDB is specified for the date, that DATE type will be the data type
       of the return value. If the TIMESTAMP type is specified for the date, the data type will be
       TIMESTAMP WITH TIME ZONE, irrespective of whether a time zone is used.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the example below, the result of "June 20, 2016 18:00:00" rounded by Sunday of the week is returned.
    </para>

    <programlisting>
    SELECT ROUND(TIMESTAMP'2016/06/20 18:00:00','DAY') FROM DUAL;
             round
    ------------------------
     2016-06-19 00:00:00+09
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>SESSIONTIMEZONE</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns the time zone of the session.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     SESSIONTIMEZONE() returns text
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       SESSIONTIMEZONE returns the time zone value between sessions.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is TEXT.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using SESSIONTIMEZONE, it is necessary to specify "oracle" for search_path in advance.
      </para>
     </listitem>
     <listitem>
      <para>
       The value returned by SESSIONTIMEZONE becomes the value set in the "TimeZone" server parameter.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "Notes on Using orafce" for information on how to edit search_path.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, the time zone of the session is returned.
    </para>

    <programlisting>
    SELECT SESSIONTIMEZONE() FROM DUAL;
     sessiontimezone
    -----------------
     Japan
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>SYSDATE</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns the system date.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     SYSDATE() returns oracle.date
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       SYSDATE returns the system date.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is the DATE type of orafce.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using SYSDATE, it is necessary to specify "oracle" for search_path in advance.
      </para>
     </listitem>
     <listitem>
      <para>
       The date returned by SYSDATE depends on the time zone value of the orafce database.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "DBTIMEZONE" for information on the time zone values of the database.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "The SQL Language" > "Data Types" > "Date/Time Types" in the LightDB
       Documentation for information on the time zone.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, the system date is returned.
    </para>

    <programlisting>
    SELECT SYSDATE() FROM DUAL;
           sysdate
    ---------------------
     2016-06-22 08:06:51
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>TRUNC</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Truncates a date.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     TRUNC(date DATE) returns DATE
     TRUNC(date DATE, fmt TEXT) returns DATE
     TRUNC(date TIMESTAMP WITH TIME ZONE) returns TIMESTAMP WITH TIME ZONE
     TRUNC(date TIMESTAMP WITH TIME ZONE, fmt TEXT) returns TIMESTAMP WITH TIME ZONE
     TRUNC(date TIMESTAMP WITHOUT TIME ZONE) returns TIMESTAMP WITHOUT TIME ZONE
     TRUNC(date TIMESTAMP WITHOUT TIME ZONE, fmt TEXT) returns TIMESTAMP WITHOUT TIME ZONE
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       TRUNC returns a date truncated to the unit specified by format model <emphasis>fmt</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       For <emphasis>date</emphasis>, specify a DATE or TIMESTAMP type.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the format model as a string. The values that can be specified are the same as for ROUND.
      </para>
     </listitem>
     <listitem>
      <para>
       If <emphasis>fmt</emphasis> is omitted, the date is truncated by day.
      </para>
     </listitem>
     <listitem>
      <para>
       If the DATE type of LightDB is specified for the date, that DATE type will be the data type
       of the return value. If the TIMESTAMP type is specified for the date, the data type will be
       TIMESTAMP WITH TIME ZONE, irrespective of whether a time zone is used.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "ROUND" for information on the values that can be specified for the format model.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the example below, the result of "August 10, 2016 15:30:00" truncated by the day is returned.
    </para>

    <programlisting>
    SELECT TRUNC(TIMESTAMP'2016/08/10 15:30:00','DDD') FROM DUAL;
             trunc
    ------------------------
     2016-08-10 00:00:00+09
    (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>TZ_OFFSET</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns the time zone offset.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     TZ_OFFSET(text) returns text
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       You can enter a valid time zone region name, a time zone offset from UTC (which simply returns itself).
      </para>
     </listitem>
     <listitem>
      <para>
        For a listing of valid values for time_zone_name, query the name column of the pg_timezone_names. 
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using TZ_OFFSET, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
SELECT TZ_OFFSET('Asia/Shanghai') FROM DUAL;
 tz_offset 
-----------
 08:00:00
(1 row)
    (1 row)
    </programlisting>
   </sect4>

  </sect3>

  <sect3>
   <title>Data Type Formatting Functions</title>

   <para>
    The following data type formatting functions are supported:
   </para>

   <itemizedlist>
    <listitem>
     <para>CONVERT</para>
    </listitem>
    <listitem>
     <para>NUMTOYMINTERVAL</para>
    </listitem>
    <listitem>
     <para>TO_BLOB(raw)</para>
    </listitem>
    <listitem>
     <para>TO_CHAR</para>
    </listitem>
    <listitem>
     <para>TO_DATE</para>
    </listitem>
    <listitem>
     <para>TO_MULTI_BYTE</para>
    </listitem>
    <listitem>
     <para>TO_NUMBER</para>
    </listitem>
    <listitem>
     <para>TO_SINGLE_BYTE</para>
    </listitem>
    <listitem>
     <para>ASCIISTR</para>
    </listitem>
    <listitem>
     <para>ASCII</para>
    </listitem>
   </itemizedlist>

   <sect4>
    <title>CONVERT</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     CONVERT converts a character string from one character set to another. 
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     CONVERT(str TEXT,dest_char_set TEXT,source_char_set TEXT DEFAULT 'utf8') returns TEXT
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       TThe str argument is the value to be converted. 
      </para>
     </listitem>
     <listitem>
      <para>
       The dest_char_set argument is the name of the character set to which str is converted. 
      </para>
     </listitem>
     <listitem>
      <para>
       The source_char_set argument is the name of the character set in which str is stored in the database. The default value is the database character set.  
      </para>
     </listitem>
     <listitem>
      <para>
       Both the destination and source character set arguments can be either literals or columns containing the name of the character set.   
      </para>
     </listitem>
     <listitem>
      <para>
       For complete correspondence in character conversion, it is essential that the destination character set contains a representation of all the characters defined in the source character set. Where a character does not exist in the destination character set, a replacement character appears. Replacement characters can be defined as part of a character set definition.    
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using CONVERT for converting string, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
 SELECT CONVERT('娴嬭瘯', 'gbk', 'utf8') from dual; FROM DUAL;
 convert 
---------
 测试
(1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>NUMTOYMINTERVAL</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     NUMTOYMINTERVAL converts number to an INTERVAL YEAR TO MONTH literal.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     NUMTOYMINTERVAL(n numeric, interval_unit text) returns interval
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       The value for interval_unit specifies the unit of n and must resolve to one of the following string values: 'YEAR', 'MONTH'. 
      </para>
     </listitem>
     <listitem>
      <para>
       interval_unit is case insensitive.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using NUMTOYMINTERVAL for specifying date/time values, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
SELECT NUMTOYMINTERVAL(1,'YEAR') FROM DUAL;
 numtoyminterval 
-----------------
 1 year
(1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>TO_BLOB(raw)</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     TO_BLOB(raw) converts RAW values to BLOB values. 
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     TO_BLOB(raw) returns blob
    </programlisting>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using the TO_BLOB(raw) function, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
SELECT TO_BLOB(UTL_RAW.CAST_TO_RAW('测试')) FROM DUAL;
    to_blob     
----------------
 \xe6b58be8af95
(1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>TO_CHAR</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Converts a value to a string.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     TO_CHAR(num SMALLINT) returns TEXT
     TO_CHAR(num INTEGER) returns TEXT
     TO_CHAR(num BIGINT) returns TEXT
     TO_CHAR(num REAL) returns TEXT
     TO_CHAR(num DOUBLE PRECISION) returns TEXT
     TO_CHAR(num NUMERIC) returns TEXT
     TO_CHAR(date TIMESTAMP) returns TEXT
     TO_CHAR(TEXT) returns TEXT
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       TO_CHAR converts the specified number or date/time value to a string.
      </para>
     </listitem>
     <listitem>
      <para>
       For <emphasis>num</emphasis>, specify a numeric data type.
      </para>
     </listitem>
     <listitem>
      <para>
       For <emphasis>date</emphasis>, specify a DATE or TIMESTAMP type.
       Also, you must set a date/time format for the nls_date_format variable in advance.
       A setting example using the SET statement is shown below.
      </para>
      <programlisting>
       SET nls_date_format = 'YYYY/MM/DD HH24:MI:SS';
      </programlisting>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is TEXT.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using TO_CHAR for specifying date/time values, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
     <listitem>
      <para>
       The nls_date_format settings can be set using any of the methods for
       setting server parameters.
      </para>
     </listitem>
     <listitem>
      <para>
       If nls_date_format is set, the following message may be displayed when
       an SQL statement is executed, however, the parameter settings are enabled,
       so you can ignore this.
      </para>
      <programlisting>
       WARNING:  unrecognized configuration parameter "nls_date_format"
      </programlisting>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, the numeric value "123.45" is returned as a string.
    </para>

    <programlisting>
     SELECT TO_CHAR(123.45) FROM DUAL;
      to_char
     ---------
      123.45
     (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>TO_DATE</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Converts a string to a date in accordance with the specified format.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     TO_DATE(str TEXT) returns TIMESTAMP
     TO_DATE(str TEXT, fmt TEXT) returns TIMESTAMP
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       TO_DATE converts string <emphasis>str</emphasis> to a date in accordance
       with the specified format <emphasis>fmt</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify a string indicating the date/time.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the required date/time format. If omitted, the format specified in the
       nls_date_format variable is used. If the nls_date_format variable
       has not been set, the existing date/time input interpretation is used.
       A setting example using the SET statement is shown below.
      </para>
      <programlisting>
       SET nls_date_format = 'YYYY/MM/DD HH24:MI:SS';
      </programlisting>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is TIMESTAMP.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       The above TO_DATE specification uses orafce for its behavior, which is different
       to that of TO_DATE of LightDB. The search_path parameter must be modified for it
       to behave according to the orafce specification.
      </para>
     </listitem>
     <listitem>
      <para>
       The nls_date_format settings can be set using any of the methods for
       setting server parameters.
      </para>
     </listitem>
     <listitem>
      <para>
       If nls_date_format is set, the following message may be displayed when
       an SQL statement is executed, however, the parameter settings are enabled,
       so you can ignore this.
      </para>
      <programlisting>
       WARNING:  unrecognized configuration parameter "nls_date_format"
      </programlisting>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Information
    </emphasis></para>

    <para>
     The general rule for TO_DATE for specifying the data type format of LightDB is as follows:
    </para>

    <itemizedlist>
     <listitem>
      <para>
       The data type of the return value is the DATE type of LightDB.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "The SQL Language" > "Functions and Operators" > "Data Type Formatting Functions"
       in the LightDB Documentation for information on TO_DATE of LightDB.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters" in the
       LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Date/Time Support" > "Date/Time Input Interpretation" in the LightDB Documentation
       for information on the interpretation of existing date/time input.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, the string "2016/12/31" is converted to a date and returned.
    </para>

    <programlisting>
     SELECT TO_DATE('2016/12/31','YYYY/MM/DD') FROM DUAL;
            to_date
     ---------------------
      2016-12-31 00:00:00
     (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>TO_MULTI_BYTE</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Converts a single-byte string to a multibyte string.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     TO_MULTI_BYTE(str TEXT) returns TEXT
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       TO_MULTI_BYTE converts halfwidth characters in string <emphasis>str</emphasis>
       to fullwidth characters, and returns the converted string.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify a string indicating the date/time.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the required date/time format. If omitted, the format specified in the
       nls_date_format variable is used. If the nls_date_format variable
       has not been set, the existing date/time input interpretation is used.
       A setting example using the SET statement is shown below.
      </para>
      <programlisting>
       Only halfwidth alphanumeric characters, spaces and symbols can be converted.
      </programlisting>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is TEXT.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, "abc123" is converted to fullwidth characters and returned.
    </para>

    <programlisting>
     SELECT TO_MULTI_BYTE('abc123') FROM DUAL;
      to_multi_byte
     ---------------
        ******
     (1 row)
    </programlisting>

    <para>
     "******" is multibyte "abc123".
    </para>
   </sect4>

   <sect4>
    <title>TO_NUMBER</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Converts a value to a number in accordance with the specified format.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     TO_NUMBER(str TEXT) returns NUMERIC
     TO_NUMBER(num NUMERIC) returns NUMERIC
     TO_NUMBER(num NUMERIC, fmt NUMERIC) returns NUMERIC
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       TO_NUMBER converts the specified value to a numeric value in accordance with
       the specified format <emphasis>fmt</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       For <emphasis>num</emphasis>, specify a numeric data type.
      </para>
     </listitem>
     <listitem>
      <para>
       For <emphasis>str</emphasis>, specify a string indicating the numeric value.
       Numeric values must comprise only of convertible characters.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the required numeric data format.
       The specified numeric value is handled as is as a data type expression.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is NUMERIC.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "The SQL Language" > "Functions and Operators" > "Data Type Formatting Functions"
     in the LightDB Documentation for information on numeric value formats.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, the numeric literal "-130.5" is converted to a numeric value and returned.
    </para>

    <programlisting>
     SELECT TO_NUMBER(-130.5) FROM DUAL;
      to_number
     -----------
         -130.5
     (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>TO_SINGLE_BYTE</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Converts a multibyte string to a single-byte string.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     TO_SINGLE_BYTE(str TEXT) returns TEXT
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       TO_SINGLE_BYTE converts fullwidth characters in string <emphasis>str</emphasis>
       to halfwidth characters, and returns the converted string.
      </para>
     </listitem>
     <listitem>
      <para>
       Only fullwidth alphanumeric characters, spaces and symbols that can be
       displayed in halfwidth can be converted.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is TEXT.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, "******" is converted to halfwidth characters and returned.
     "******" is multibyte "xyz999".
    </para>

    <programlisting>
     SELECT TO_SINGLE_BYTE('******') FROM DUAL;
      to_single_byte
     ----------------
      xyz999
     (1 row)
    </programlisting>
   </sect4>

  <sect4>
    <title>ASCIISTR</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     ASCIISTR takes as its argument a string, or an expression that resolves to a string, in any character set and returns an ASCII version of the string in the database character set.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     ASCIISTR(str TEXT) returns TEXT
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Non-ASCII characters are converted to the form \xxxx, where xxxx represents a UTF-16 code unit.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is TEXT.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, "Ä" is converted to "\00C4".
    </para>

    <programlisting>
     SELECT ASCIISTR('ABÄCDE') FROM DUAL;
      asciistr
     ----------------
      AB\00C4CDE
     (1 row)
    </programlisting>
   </sect4>

  <sect4>
    <title>ASCII</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     ASCII takes as its argument a string, or an expression that resolves to a string, in any character set and returns an value in the database character set of the first character.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     ASCIISTR(str TEXT) returns BIGINT
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If your database character set is 7-bit ASCII, then this function returns an ASCII value. If your database character set is UTF-8 Code, then this function returns an UTF-8 value.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is BIGINT.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, "Ä" is converted to "50052"  in UTF-8.
    </para>

    <programlisting>
     SELECT ORACLE.ASCII('Ä') FROM DUAL;
      ascii
     -------
      50052
     (1 row)
    </programlisting>
   </sect4>

  </sect3>

  <sect3>
   <title>Conditional Expressions</title>

   <para>
    The following functions for making comparisons are supported:
   </para>

   <itemizedlist>
    <listitem>
     <para>DECODE</para>
    </listitem>
    <listitem>
     <para>LNNVL</para>
    </listitem>
    <listitem>
     <para>NANVL</para>
    </listitem>
    <listitem>
     <para>NVL</para>
    </listitem>
    <listitem>
     <para>NVL2</para>
    </listitem>
   </itemizedlist>

   <sect4>
    <title>DECODE</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Compares values and if they match, returns a corresponding value.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     DECODE(expr, srch,  result)
     DECODE(expr, srch,  result,  default)
     DECODE(expr, srch1, result1, srch2, result2)
     DECODE(expr, srch1, result1, srch2, result2, default)
     DECODE(expr, srch1, result1, srch2, result2, srch3, result3)
     DECODE(expr, srch1, result1, srch2, result2, srch3, result3, default)
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       DECODE compares values of the value expression to be converted and the search values one by one.
       If the values match, a corresponding result value is returned.
       If no values match, the default value is returned if it has been specified.
       A NULL value is returned if a default value has not been specified.
      </para>
     </listitem>
     <listitem>
      <para>
       If the same search value is specified more than once, then the result value returned
       is the one listed for the first occurrence of the search value.
      </para>
     </listitem>
     <listitem>
      <para>
       The following data types can be used in result values and in the default value:
      </para>
      <itemizedlist>
       <listitem>
        <para>CHAR</para>
       </listitem>
       <listitem>
        <para>VARCHAR</para>
       </listitem>
       <listitem>
        <para>VARCHAR2</para>
       </listitem>
       <listitem>
        <para>NCHAR</para>
       </listitem>
       <listitem>
        <para>NCHAR VARYING</para>
       </listitem>
       <listitem>
        <para>NVARCHAR2</para>
       </listitem>
       <listitem>
        <para>TEXT</para>
       </listitem>
       <listitem>
        <para>INTEGER</para>
       </listitem>
       <listitem>
        <para>BIGINT</para>
       </listitem>
       <listitem>
        <para>NUMERIC</para>
       </listitem>
       <listitem>
        <para>DATE</para>
       </listitem>
       <listitem>
        <para>TIME WITHOUT TIME ZONE</para>
       </listitem>
       <listitem>
        <para>TIMESTAMP WITHOUT TIME ZONE</para>
       </listitem>
       <listitem>
        <para>TIMESTAMP WITH TIME ZONE</para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       The same data type must be specified for the values to be converted and the search values.
       However, note that different data types may also be specified if a literal is specified
       in the search value, and the value expression to be converted contains data types that
       can be converted.
      </para>
     </listitem>
     <listitem>
      <para>
       If the result values and default value are all literals, the data types for these
       values will be as shown below:
      </para>
      <itemizedlist>
       <listitem>
        <para>
         If all values are string literals, all will become character types.
        </para>
       </listitem>
       <listitem>
        <para>
         If there is one or more numeric literal, all will become numeric types.
        </para>
       </listitem>
       <listitem>
        <para>
         If there is one or more literal cast to the datetime/time types,
         all will become datetime/time types.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
     <listitem>
      <para>
       If the result values and default value contain a mixture of literals and non-literals,
       the literals will be converted to the data types of the non-literals.
      </para>
     </listitem>
     <listitem>
      <para>
       The same data type must be specified for all result values and for the default value.
       However, different data types can be specified if the data type of any of the result
       values or default value can be converted - these data types are listed below:
      </para>
     </listitem>
    </itemizedlist>

    <table>
     <title>Data type combinations that can be converted by DECODE (summary)</title>
     <tgroup cols="5">
      <colspec colname="c1" colnum="1" colwidth="1*"/>
      <colspec colname="c2" colnum="2" colwidth="1*"/>
      <colspec colname="c3" colnum="3" colwidth="1*"/>
      <colspec colname="newCol4" colnum="4" colwidth="1*"/>
      <colspec colname="newCol5" colnum="5" colwidth="1*"/>
      <thead>
       <row>
        <entry/>
        <entry/>
        <entry namest="c3" nameend="newCol5"><emphasis role="bold">Other result values or default
         value</emphasis></entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry/>
        <entry/>
        <entry align="center">Numeric type</entry>
        <entry align="center">Character type</entry>
        <entry align="center">Date/time type</entry>
       </row>
       <row>
        <entry morerows="2"><emphasis role="bold">Result value (any)</emphasis></entry>
        <entry>Numeric type</entry>
        <entry align="center">Y</entry>
        <entry align="center">N</entry>
        <entry align="center">N</entry>
       </row>
       <row>
        <entry>Character type</entry>
        <entry align="center">N</entry>
        <entry align="center">Y</entry>
        <entry align="center">N</entry>
       </row>
       <row>
        <entry>Date/time type</entry>
        <entry align="center">N</entry>
        <entry align="center">N</entry>
        <entry align="center">S(*1)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>Y: Can be converted</para>
    <para>S: Some data types can be converted</para>
    <para>N: Cannot be converted</para>
    <para>*1: The data types that can be converted for date/time types are listed below:</para>

    <table frame="all">
     <title>
      Result value and default value date/time data types that can be converted by DECODE
     </title>
     <tgroup cols="6">
      <colspec colname="c1" colnum="1" colwidth="1*"/>
      <colspec colname="c2" colnum="2" colwidth="1*"/>
      <colspec colname="c3" colnum="3" colwidth="1*"/>
      <colspec colname="c4" colnum="4" colwidth="1*"/>
      <colspec colname="c5" colnum="5" colwidth="1*"/>
      <colspec colname="c6" colnum="6" colwidth="1*"/>
      <thead>
       <row>
        <entry/>
        <entry/>
        <entry namest="c3" nameend="c6"><emphasis role="bold">Other result values or default
         value</emphasis></entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry/>
        <entry/>
        <entry>DATE</entry>
        <entry>TIME WITHOUT TIME ZONE</entry>
        <entry>TIMESTAMP WITHOUT TIME ZONE</entry>
        <entry>TIMESTAMP WITH TIME ZONE</entry>
       </row>
       <row>
        <entry morerows="3"><emphasis role="bold">Result value (any)</emphasis></entry>
        <entry>DATE</entry>
        <entry align="center" valign="middle">Y</entry>
        <entry align="center" valign="middle">N</entry>
        <entry align="center" valign="middle">Y</entry>
        <entry align="center" valign="middle">Y</entry>
       </row>
       <row>
        <entry>TIME WITHOUT TIME ZONE</entry>
        <entry align="center" valign="middle">N</entry>
        <entry align="center" valign="middle">Y</entry>
        <entry align="center" valign="middle">N</entry>
        <entry align="center" valign="middle">N</entry>
       </row>
       <row>
        <entry>TIMESTAMP WITHOUT TIME ZONE</entry>
        <entry align="center" valign="middle">Y</entry>
        <entry align="center" valign="middle">N</entry>
        <entry align="center" valign="middle">Y</entry>
        <entry align="center" valign="middle">Y</entry>
       </row>
       <row>
        <entry>TIMESTAMP WITH TIME ZONE</entry>
        <entry align="center" valign="middle">Y</entry>
        <entry align="center" valign="middle">N</entry>
        <entry align="center" valign="middle">Y</entry>
        <entry align="center" valign="middle">Y</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>Y: Can be converted</para>
    <para>N: Cannot be converted</para>

    <itemizedlist>
     <listitem>
      <para>
       The data type of the return value will be the data type within the result
       or default value that is longest and has the highest precision.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, the value of col3 in table t1 is compared and converted to a
     different value. If the col3 value matches search value 1, the result value returned is
     "one". If the col3 value does not match any of search values 1, 2, or 3, the default
     value "other number" is returned.
    </para>

    <programlisting>
     SELECT col1,
            DECODE(col3, 1, 'one',
                         2, 'two',
                         3, 'three',
                         'other number') "num-word"
            FROM t1;
     col1  | num-word
     ------+----------
      1001 | one
      1002 | two
      1003 | three
     (3 rows)
    </programlisting>
   </sect4>

   <sect4>
    <title>LNNVL</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Determines if a value is TRUE or FALSE for the specified condition.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     LNNVL(cond BOOLEAN) returns BOOLEAN
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       LNNVL determines if a value is TRUE or FALSE for the specified condition.
       If the result of the condition is FALSE or NULL, TRUE is returned.
       If the result of the condition is TRUE, FALSE is returned.
      </para>
     </listitem>
     <listitem>
      <para>
       The expression for returning TRUE or FALSE is specified in the condition.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is BOOLEAN.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, col1 and col3 of table t1 are returned when
     col3 has a value of 2000 or less, or null values.
    </para>

    <programlisting>
     SELECT col1,col3 FROM t1 WHERE LNNVL( col3 > 2000 );
      col1 | col3
     ------+------
      1001 | 1000
      1002 | 2000
      2002 |
     (3 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>NANVL</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns a substitute value when a value is not a number (NaN).
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     NANVL(expr FLOAT4,  substitute FLOAT4)  returns FLOAT4
     NANVL(expr FLOAT8,  substitute FLOAT8)  returns FLOAT8
     NANVL(expr NUMERIC, substitute NUMERIC) returns NUMERIC
     NANVL(expr FLOAT4,  substitute VARCHAR) returns FLOAT4
     NANVL(expr FLOAT8,  substitute VARCHAR) returns FLOAT8
     NANVL(expr NUMERIC, substitute VARCHAR) returns NUMERIC
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       NANVL returns a substitute value when the specified value is not a number (NaN).
       The substitute value can be either a number or a string that can be converted to a number.
      </para>
     </listitem>
     <listitem>
      <para>
       For <emphasis>expr</emphasis> and <emphasis>substitute</emphasis>, specify a numeric data type.
       If <emphasis>expr</emphasis> and <emphasis>substitute</emphasis> have different data types,
       they will be converted to the data type with greater length or precision, and that is the data
       type that will be returned.
      </para>
     </listitem>
     <listitem>
      <para>
       For <emphasis>substitute</emphasis>, you can also specify a string indicating the numeric value.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type used for the return value if a string is specified for the substitute value
       will be the same as the data type of <emphasis>expr</emphasis>.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, "0" is returned if the value of col1 in table t1 is a NaN value.
    </para>

    <programlisting>
     SELECT col1, NANVL(col3,0) FROM t1;
      col1 | nanvl
     ------+-------
      2001 |     0
     (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>NVL</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns a substitute value when a value is NULL.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     NVL(expr1 anyelement, expr2 anyelement) return anyelement
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       NVL returns a substitute value when the specified value is NULL.
       When <emphasis>expr1</emphasis> is NULL, <emphasis>expr2</emphasis> is returned.
       When <emphasis>expr1</emphasis> is not NULL, <emphasis>expr1</emphasis> is returned.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the same data types for <emphasis>expr1</emphasis> and <emphasis>expr2</emphasis>.
       However, if a constant is specified in <emphasis>expr2</emphasis>, and the data type can
       also be converted by <emphasis>expr1</emphasis>, different data types can be specified.
       When this happens, the conversion by <emphasis>expr2</emphasis> is done to suit the data
       type in <emphasis>expr1</emphasis>, so the value of <emphasis>expr2</emphasis> returned
       when <emphasis>expr1</emphasis> is a NULL value will be the value converted in the data
       type of <emphasis>expr1</emphasis>.
       This is not necessary for types (numeric, int) and (bigint, int).
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, "IS NULL" is returned if the value of col1 in table t1 is a NULL value.
    </para>

    <programlisting>
     SELECT col2, NVL(col1,'IS NULL') "nvl" FROM t1;
      col2 |   nvl
     ------+---------
      aaa  | IS NULL
     (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>NVL2</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns a substitute value based on whether a value is NULL or not NULL.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     NVL2(expr anyelement, substitute1 anyelement, substitute2 anyelement) return anyelement
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       NVL2 returns a substitute value based on whether the specified value is NULL or not NULL.
       When <emphasis>expr</emphasis> is NULL, <emphasis>substitute2</emphasis> is returned.
       When it is not NULL, <emphasis>substitute1</emphasis> is returned.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the same data types for <emphasis>expr</emphasis>, <emphasis>substitute1</emphasis>,
       and <emphasis>substitute2</emphasis>. However, if a literal is specified in <emphasis>
       substitute1</emphasis> or <emphasis>substitute2</emphasis>, and the data type can also be
       converted by <emphasis>expr</emphasis>, different data types can be specified. When this
       happens, <emphasis>substitute1</emphasis> or <emphasis>substitute2</emphasis> is converted
       to suit the data type in <emphasis>expr</emphasis>, so the value of <emphasis>substitute2
       </emphasis> returned when <emphasis>expr</emphasis> is a NULL value will be the value
       converted to the data type of <emphasis>expr</emphasis>.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, if a value in column col1 in table t1 is NULL,
     "IS NULL" is returned, and if not NULL, "IS NOT NULL" is returned.
    </para>

    <programlisting>
     SELECT col2, NVL2(col1,'IS NOT NULL','IS NULL') FROM t1;
      col2 |   nvl2
     ------+---------
      aaa  | IS NULL
      bbb  | IS NOT NULL
     (2 row)
    </programlisting>
   </sect4>
  </sect3>

  <sect3>
   <title>Aggregate Functions</title>

   <para>
    The following aggregation functions are supported:
   </para>

   <itemizedlist>
    <listitem>
     <para>ANY_VALUE</para>
    </listitem>
    <listitem>
     <para>BIT_AND_AGG</para>
    </listitem>
    <listitem>
     <para>BIT_OR_AGG</para>
    </listitem>
    <listitem>
     <para>BIT_XOR_AGG</para>
    </listitem>
    <listitem>
     <para>KURTOSIS_POP</para>
    </listitem>
    <listitem>
     <para>KURTOSIS_SAMP</para>
    </listitem>
    <listitem>
     <para>LISTAGG</para>
    </listitem>
    <listitem>
     <para>MEDIAN</para>
    </listitem>
    <listitem>
     <para>SKEWNESS_POP</para>
    </listitem>
    <listitem>
     <para>SKEWNESS_SAMP</para>
    </listitem>
   </itemizedlist>

   <sect4>
    <title>ANY_VALUE</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     ANY_VALUE returns a single non-deterministic value of expr.  
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     ANY_VALUE(expr anyelement) returns anyelement
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Use ANY_VALUE to optimize a query that has a GROUP BY clause. ANY_VALUE returns a value of an expression in a group.
       It is optimized to return the first value. 
      </para>
     </listitem>
     <listitem>
      <para>
       It ensures that there are no comparisons for any incoming row and also eliminates the necessity to specify every column as part of the GROUP BY clause. 
      </para>
     </listitem>
     <listitem>
      <para>
       Because it does not compare values, ANY_VALUE returns a value more quickly than MIN or MAX in a GROUP BY query. 
      </para>
     </listitem>
     <listitem>
      <para>
       Returns any value within each group based on the GROUP BY specification. Returns NULL if all rows in the group have NULL expression values. 
      </para>
     </listitem>
     <listitem>
      <para>
       The result of ANY_VALUE is not deterministic. 
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using ANY_VALUE, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
create table test_any_value(key1 int, key2 int);
insert into test_any_value values(1, 1);
select any_value(key2)  from test_any_value group by key1;
 any_value 
-----------
         1
(1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>BIT_AND_AGG</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     BIT_AND_AGG is a bitwise aggregation function that returns the result of a bitwise AND operation. 
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     BIT_AND_AGG(numeric) returns int
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       You can use BIT_AND_AGG as part of a GROUP BY query, window function, or as an analytical function. 
      </para>
     </listitem>
     <listitem>
      <para>
       For a given set of values, the result of a bitwise aggregate is always deterministic and independent of ordering.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is int.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using BIT_AND_AGG, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select bit_and_agg(column1)  from (values (1),(2),(4),(8)) x;
 bit_and_agg 
-------------
           0
(1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>BIT_OR_AGG</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     BIT_OR_AGG is a bitwise aggregation function that returns the result of a bitwise OR operation. 
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     BIT_OR_AGG(numeric) returns int
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       You can use BIT_OR_AGG as part of a GROUP BY query, window function, or as an analytical function. 
      </para>
     </listitem>
     <listitem>
      <para>
       For a given set of values, the result of a bitwise aggregate is always deterministic and independent of ordering.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is int.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using BIT_OR_AGG, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select bit_or_agg(column1)  from (values (1),(2),(4),(8)) x;
 bit_or_agg 
------------
         15
(1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>BIT_XOR_AGG</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     BIT_XOR_AGG is a bitwise aggregation function that returns the result of a bitwise XOR operation. 
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     BIT_XOR_AGG(numeric) returns int
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       You can use BIT_XOR_AGG as part of a GROUP BY query, window function, or as an analytical function. 
      </para>
     </listitem>
     <listitem>
      <para>
       For a given set of values, the result of a bitwise aggregate is always deterministic and independent of ordering.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is int.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using BIT_XOR_AGG, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select bit_xor_agg(column1)  from (values (1),(3),(4),(8)) x;
 bit_xor_agg 
-------------
          14
(1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>KURTOSIS_POP</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     The population kurtosis function KURTOSIS_POP is primarily used to determine the characteristics of outliers in a given distribution. 
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     KURTOSIS_POP(numeric) returns numeric
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       NULL values in expr are ignored. 
      </para>
     </listitem>
     <listitem>
      <para>
       Returns NULL if all rows in the group have NULL expr values. 
      </para>
     </listitem>
     <listitem>
      <para>
       Returns 0 if there are one or two rows in expr. 
      </para>
     </listitem>
     <listitem>
      <para>
       For a given set of values, the result of population kurtosis (KURTOSIS_POP) and sample kurtosis (KURTOSIS_SAMP) are always deterministic.
       However, the values of KURTOSIS_POP and KURTOSIS_SAMP differ. As the number of values in the data set increases, the difference between the computed values of KURTOSIS_SAMP and KURTOSIS_POP decreases.  
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using the KURTOSIS_POP function, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select kurtosis_pop(column1) from  (values (1),(2),(4),(8)) x;
      kurtosis_pop       
-------------------------
 -1.09897920604914942667
(1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>KURTOSIS_SAMP</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     The sample kurtosis function KURTOSIS_SAMP is primarily used to determine the characteristics of outliers in a given distribution. 
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     KURTOSIS_SAMP(numeric) returns numeric
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       NULL values in expr are ignored. 
      </para>
     </listitem>
     <listitem>
      <para>
       Returns NULL if all rows in the group have NULL expr values. 
      </para>
     </listitem>
     <listitem>
      <para>
       Returns 0 if there are one or two rows in expr. 
      </para>
     </listitem>
     <listitem>
      <para>
       For a given set of values, the result of sample kurtosis (KURTOSIS_SAMP) and population kurtosis (KURTOSIS_POP) are always deterministic.
       However, the values of KURTOSIS_SAMP and KURTOSIS_POP differ. As the number of values in the data set increases, the difference between the computed values of KURTOSIS_SAMP and KURTOSIS_POP decreases.   
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using the KURTOSIS_SAMP function, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select kurtosis_samp(column1) from  (values (1),(2),(4),(8)) x;
   kurtosis_samp    
--------------------
 0.7576559546313793
(1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>LISTAGG</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns a concatenated, delimited list of string values.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     LISTAGG(strExpr TEXT) returns TEXT
     LISTAGG(strExpr TEXT, delimiter TEXT) []returns TEXT
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       LISTAGG concatenates and delimits a set of string values and returns the result.
      </para>
     </listitem>
     <listitem>
      <para>
       For <emphasis>delimiter</emphasis>, specify a string.
       If the delimiter is omitted, a list of strings without a delimiter is returned.
      </para>
     </listitem>
     <listitem>
      <para>
       In LightDB, LISTAGG support using distinct in function with within group clauses.
       e.g: LISTAGG(distinct c1) within group(order by c1)
      </para>
     </listitem>
     <listitem>
      <para>
       In LightDB, LISTAGG support using within group clauses with over clauses.
       In this scenario we cannot use distinct in function yet.
       e.g: LISTAGG(c1) within group(order by c1) over(partition by c2)
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is TEXT.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, the result with values of column col2 in table t1 delimited by ':' is returned.
    </para>

    <programlisting>
     SELECT LISTAGG(col2,':') FROM t1;
           listagg
     -------------------
      AAAAA:BBBBB:CCCCC
     (1 row)
    </programlisting>


    <para>
     In the following example, using within group with over.
    </para>

    <programlisting>
CREATE TABLE EMP
(   EMPNO    NUMBER(4, 0),
    ENAME    VARCHAR2(10),
    JOB      VARCHAR2(9),
    MGR      NUMBER(4, 0),
    HIREDATE DATE,
    SAL      NUMBER(7, 2),
    COMM     NUMBER(7, 2),
    DEPTNO   NUMBER(2, 0),
    DNAME    VARCHAR2(100),
    CONSTRAINT PK_EMP PRIMARY KEY (EMPNO)
);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME) values (7369, 'SMITH',  'CLERK',    7902, to_date('1980-12-17','yyyy-mm-dd'), 800.00,  null,    20, null);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME) values (7499, 'ALLEN',  'SALESMAN', 7698, to_date('1981-02-20','yyyy-mm-dd'), 1600.00, 300.00,  30, null);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME) values (7521, 'WARD',   'SALESMAN', 7698, to_date('1981-02-22','yyyy-mm-dd'), 1250.00, 500.00,  30, null);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME) values (7566, 'JONES',  'MANAGER',  7839, to_date('1981-04-02','yyyy-mm-dd'), 2975.00, null,    20, null);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME) values (7654, 'MARTIN', 'SALESMAN', 7698, to_date('1981-09-28','yyyy-mm-dd'), 1250.00, 1400.00, 30, null);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME) values (7698, 'BLAKE',  'MANAGER',  7839, to_date('1981-05-01','yyyy-mm-dd'), 2850.00, null,    30, null);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME) values (7782, 'CLARK',  'MANAGER',  7839, to_date('1981-06-09','yyyy-mm-dd'), 2450.00, null,    10, null);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME) values (7788, 'SCOTT',  'ANALYST',  7566, to_date('1987-04-19','yyyy-mm-dd'), 3000.00, null,    20, null);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME) values (7839, 'KING',   'PRESIDENT',null, to_date('1981-11-17','yyyy-mm-dd'), 5000.00, null,    10, null);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME) values (7844, 'TURNER', 'SALESMAN', 7698, to_date('1981-09-08','yyyy-mm-dd'), 1500.00, 0.00,    30, null);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME) values (7876, 'ADAMS',  'CLERK',    7788, to_date('1987-05-23','yyyy-mm-dd'), 1100.00, null,    20, null);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME) values (7900, 'JAMES',  'CLERK',    7698, to_date('1981-12-03','yyyy-mm-dd'), 950.00,  null,    30, null);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME) values (7902, 'FORD',   'ANALYST',  7566, to_date('1981-12-03','yyyy-mm-dd'), 3000.00, null,    20, null);
insert into EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME) values (7934, 'MILLER', 'CLERK',    7782, to_date('1982-01-23','yyyy-mm-dd'), 1300.00, null,    10, null);

select listagg(ename, ',') within group(order by ename) over(partition by deptno) as enames,
       deptno,
       ename
  from EMP;
                enames                | deptno | ename  
--------------------------------------+--------+--------
 CLARK,KING,MILLER                    |     10 | CLARK
 CLARK,KING,MILLER                    |     10 | KING
 CLARK,KING,MILLER                    |     10 | MILLER
 ADAMS,FORD,JONES,SCOTT,SMITH         |     20 | ADAMS
 ADAMS,FORD,JONES,SCOTT,SMITH         |     20 | FORD
 ADAMS,FORD,JONES,SCOTT,SMITH         |     20 | JONES
 ADAMS,FORD,JONES,SCOTT,SMITH         |     20 | SCOTT
 ADAMS,FORD,JONES,SCOTT,SMITH         |     20 | SMITH
 ALLEN,BLAKE,JAMES,MARTIN,TURNER,WARD |     30 | ALLEN
 ALLEN,BLAKE,JAMES,MARTIN,TURNER,WARD |     30 | BLAKE
 ALLEN,BLAKE,JAMES,MARTIN,TURNER,WARD |     30 | JAMES
 ALLEN,BLAKE,JAMES,MARTIN,TURNER,WARD |     30 | MARTIN
 ALLEN,BLAKE,JAMES,MARTIN,TURNER,WARD |     30 | TURNER
 ALLEN,BLAKE,JAMES,MARTIN,TURNER,WARD |     30 | WARD
(14 rows)

    </programlisting>

   </sect4>

   <sect4>
    <title>MEDIAN</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Calculates the median of a set of numbers.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     MEDIAN(numExpr REAL) returns REAL
     MEDIAN(numExpr DOUBLE PRECISION) returns DOUBLE PRECISION
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       MEDIAN returns the median of a set of numbers.
      </para>
     </listitem>
     <listitem>
      <para>
       The numbers must be numeric data type.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value will be REAL if the numbers are REAL type,
       or DOUBLE PRECISION if any other type is specified.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, the median of column col3 in table t1 is returned.
    </para>

    <programlisting>
     SELECT MEDIAN(col3) FROM t1;
      median
     --------
        2000
     (1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>SKEWNESS_POP</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     SKEWNESS_POP is an aggregate function that is primarily used to determine symmetry in a given distribution. 
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     SKEWNESS_POP(numeric) returns numeric
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       NULL values in expr are ignored. 
      </para>
     </listitem>
     <listitem>
      <para>
       Returns NULL if all rows in the group have NULL expr values. 
      </para>
     </listitem>
     <listitem>
      <para>
       Returns 0 if there are one or two rows in expr. 
      </para>
     </listitem>
     <listitem>
      <para>
       For a given set of values, the result of population skewness (SKEWNESS_POP) and sample skewness (SKEWNESS_SAMP) are always deterministic. However, the values of SKEWNESS_POP and SKEWNESS_SAMP differ. As the number of values in the data set increases, the difference between the computed values of SKEWNESS_SAMP and SKEWNESS_POP decreases.    
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using the SKEWNESS_POP function, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
SELECT SKEWNESS_POP(column1) from  (values (1),(2),(4),(8)) x;
      skewness_pop      
------------------------
 0.65680773449969915746
(1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>SKEWNESS_SAMP</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     SKEWNESS_SAMP is an aggregate function that is primarily used to determine symmetry in a given distribution. 
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     SKEWNESS_SAMP(numeric) returns numeric
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       NULL values in expr are ignored. 
      </para>
     </listitem>
     <listitem>
      <para>
       Returns NULL if all rows in the group have NULL expr values. 
      </para>
     </listitem>
     <listitem>
      <para>
       Returns 0 if there are one or two rows in expr. 
      </para>
     </listitem>
     <listitem>
      <para>
       For a given set of values, the result of population skewness (SKEWNESS_POP) and sample skewness (SKEWNESS_SAMP) are always deterministic. However, the values of SKEWNESS_POP and SKEWNESS_SAMP differ. As the number of values in the data set increases, the difference between the computed values of SKEWNESS_SAMP and SKEWNESS_POP decreases. 
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using the SKEWNESS_SAMP function, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
SELECT SKEWNESS_SAMP(column1) from  (values (1),(2),(4),(8)) x;
     skewness_samp      
------------------------
 1.13762436695768880892
(1 row)
    </programlisting>
   </sect4>

  </sect3>

  <sect3>
   <title>Functions That Return Internal Information</title>

   <para>
    The following functions that return internal information are supported:
   </para>

   <itemizedlist>
    <listitem>
     <para>DUMP</para>
    </listitem>
    <listitem>
     <para>NLS_CHARSET_ID</para>
    </listitem>
    <listitem>
     <para>NLS_CHARSET_NAME</para>
    </listitem>
    <listitem>
     <para>SYS_CONTEXT</para>
    </listitem>
    <listitem>
     <para>USERENV</para>
    </listitem>
   </itemizedlist>

   <sect4>
    <title>DUMP</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns internal information of a value.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     DUMP(expr TEXT) returns VARCHAR
     DUMP(expr TEXT, fmt INTEGER) returns VARCHAR
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       DUMP returns the internal information of the values specified in expressions
       in a display format that is in accordance with the output format.
      </para>
     </listitem>
     <listitem>
      <para>
       The internal code (Typ) of the data type, the data length (Len) and the internal
       expression of the data are output as internal information.
      </para>
     </listitem>
     <listitem>
      <para>
       Any data type can be specified for the expressions.
      </para>
     </listitem>
     <listitem>
      <para>
       The display format (base <emphasis>n</emphasis> ) of the internal expression of
       the data is specified for the output format. The base numbers that can be specified
       are 8, 10, and 16. If omitted, 10 is used as the default.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is VARCHAR.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     The information output by DUMP will be the complete internal information.
     Therefore, the values may change due to product updates, and so on.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     In the following example, the internal information of column col1 in table t1 is returned.
    </para>

    <programlisting>
     SELECT col1, DUMP(col1) FROM t1;
      col1 |                dump
     ------+------------------------------------
      1001 | Typ=25 Len=8: 32,0,0,0,49,48,48,49
      1002 | Typ=25 Len=8: 32,0,0,0,49,48,48,50
      1003 | Typ=25 Len=8: 32,0,0,0,49,48,48,51
     (3 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>NLS_CHARSET_ID</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     NLS_CHARSET_ID returns the character set ID number corresponding to character set name string. 
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     NLS_CHARSET_ID(str text) returns integer
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Invalid character set names return null.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       The character set name is from Oracle, use this function only for compatibility.
      </para>
     </listitem>
     <listitem>
      <para>
       If using the NLS_CHARSET_ID function, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>


    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     The following example returns the character set ID of a character set:
    </para>

    <programlisting>
SELECT NLS_CHARSET_ID('AL32UTF8') FROM DUAL;
 nls_charset_id 
----------------
            873
(1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>NLS_CHARSET_NAME</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     NLS_CHARSET_NAME returns the name of the character set corresponding to ID number number.  
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     NLS_CHARSET_NAME(str text) returns integer
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If number is not recognized as a valid character set ID, then this function returns null. 
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       The character set name is from Oracle, use this function only for compatibility.
      </para>
     </listitem>
     <listitem>
      <para>
       If using the NLS_CHARSET_NAME function, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>


    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     The following example returns the character set corresponding to character set ID number 873:
    </para>

    <programlisting>
SELECT NLS_CHARSET_NAME(873) FROM DUAL;
 nls_charset_name 
------------------
 AL32UTF8
(1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>SYS_CONTEXT</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns the value of parameter associated with the context namespace at the current instant
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     SYS_CONTEXT(namespace text, parameter text, length int4 default 256) returns text
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       For namespace and parameter, you can specify either a string or an expression that resolves to a string designating a namespace or an attribute.
      </para>
     </listitem>
     <listitem>
      <para>
       The context namespace must already have been created, and the associated parameter and its value must also have been set.
      </para>
     </listitem>
     <listitem>
      <para>
       The namespace must be a valid identifier. The parameter name can be any string.
       It is not case sensitive, but it cannot exceed 4000 bytes in length. 
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     LightDB provides the following built-in namespaces: 
    </para>

    <itemizedlist>
     <listitem>
      <para>
       USERENV - Describes the current session.
       The predefined parameters of namespace USERENV are listed in table <xref linkend="Predefined-Parameters-USERENV"/>
      </para>
     </listitem>
     <listitem>
      <para>
       SYS_SESSION_ROLES - Indicates whether a specified role is currently enabled for the session. 
      </para>
     </listitem>
    </itemizedlist>

  <table id="Predefined-Parameters-USERENV">
   <title>Predefined Parameters of Namespace USERENV </title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Parameters
       </para>
      </entry>
      <entry>
       <para>
        Overview
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        CLIENT_IDENTIFIER
       </para>
      </entry>
      <entry>
       <para>
        The name of the program used for the database session
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        CLIENT_INFO
       </para>
      </entry>
      <entry>
       <para>
        The name of the program used for the database session
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        CLIENT_PROGRAM_NAME
       </para>
      </entry>
      <entry>
       <para>
        The name of the program used for the database session
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        CDB_NAME
       </para>
      </entry>
      <entry>
       <para>
        Current database
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        CON_ID
       </para>
      </entry>
      <entry>
       <para>
        Always 1
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        CON_NAME
       </para>
      </entry>
      <entry>
       <para>
        Current database
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        CURRENT_SCHEMA
       </para>
      </entry>
      <entry>
       <para>
        Current schema
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        CURRENT_SCHEMAID
       </para>
      </entry>
      <entry>
       <para>
        Current schema id
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        CURRENT_USER
       </para>
      </entry>
      <entry>
       <para>
        Current user
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        CURRENT_USERID
       </para>
      </entry>
      <entry>
       <para>
        Current user id
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        DATABASE_ROLE
       </para>
      </entry>
      <entry>
       <para>
        The role is one of the following: PRIMARY, PHYSICAL STANDBY
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        DB_NAME
       </para>
      </entry>
      <entry>
       <para>
        Current database
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        DB_UNIQUE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Current database
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        HOST
       </para>
      </entry>
      <entry>
       <para>
        Name of the host machine from which the client has connected
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        INSTANCE
       </para>
      </entry>
      <entry>
       <para>
        Always 1
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        INSTANCE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Always 'LightDB'
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        IP_ADDRESS
       </para>
      </entry>
      <entry>
       <para>
        IP address of the machine from which the client is connected
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        ISDBA
       </para>
      </entry>
      <entry>
       <para>
        Returns TRUE if the user has been authenticated as having DBA privileges
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        LANG
       </para>
      </entry>
      <entry>
       <para>
        The abbreviated name for the language, a shorter form than the existing 'LANGUAGE' parameter 
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        LANGUAGE
       </para>
      </entry>
      <entry>
       <para>
        The language and territory currently used by your session, along with the database character set
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        MODULE
       </para>
      </entry>
      <entry>
       <para>
        The name of the program used for the database session
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        NETWORK_PROTOCOL
       </para>
      </entry>
      <entry>
       <para>
        Network protocol being used for communication
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        NLS_DATE_FORMAT
       </para>
      </entry>
      <entry>
       <para>
        The date format for the session
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        ORACLE_HOME
       </para>
      </entry>
      <entry>
       <para>
        The full path name for the data home directory
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        PID
       </para>
      </entry>
      <entry>
       <para>
        Current process ID
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        SERVER_HOST
       </para>
      </entry>
      <entry>
       <para>
        listen_addresses
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        SERVICE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Current database
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        SESSION_USER
       </para>
      </entry>
      <entry>
       <para>
        Current user
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        SESSION_USERID
       </para>
      </entry>
      <entry>
       <para>
        Current user id
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        SESSIONID
       </para>
      </entry>
      <entry>
       <para>
        Current session process id
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        SID
       </para>
      </entry>
      <entry>
       <para>
        Current session process id
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using SYS_CONTEXT, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     The following statement returns the name of the user who logged onto the database:
    </para>

    <programlisting>
SELECT SYS_CONTEXT ('USERENV', 'SESSION_USER') FROM DUAL;
 sys_context 
-------------
 lightdb
(1 row)
    </programlisting>
   </sect4>
   <sect4>
    <title>USERENV</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Returns information about the current session
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     USERENV(parameter text) returns text
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This information can be useful for writing an application-specific audit trail table or for determining the language-specific characters currently used by your session. 
      </para>
     </listitem>
     <listitem>
      <para>
        Table <xref linkend="Predefined-Parameters-USERENV"/> describes the values for the parameter argument. 
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using USERENV, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <para>
     The following example returns the LANGUAGE parameter of the current session: 
    </para>

    <programlisting>
SELECT USERENV('LANGUAGE') "Language" FROM DUAL;
  Language   
-------------
 en_US.UTF-8
(1 row)
    </programlisting>
   </sect4>
  </sect3>

  <sect3>
   <title>Datetime Operator</title>

   <para>
    The following datetime operators are supported for the DATE type of orafce.
   </para>

   <table frame="all">
    <title>Datetime operator</title>
    <tgroup cols="3">
     <colspec colname="c1" colnum="1" colwidth="1*"/>
     <colspec colname="c2" colnum="2" colwidth="1.6*"/>
     <colspec colname="c3" colnum="3" colwidth="1.3*"/>
     <thead>
      <row>
       <entry><emphasis role="bold">Operation</emphasis></entry>
       <entry align="left"><emphasis role="bold">Example</emphasis></entry>
       <entry align="left"><emphasis role="bold">Result</emphasis></entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry align="center">+</entry>
       <entry>DATE'2016/01/01' + 10</entry>
       <entry>2016-01-11 00:00:00</entry>
      </row>
      <row>
       <entry align="center">-</entry>
       <entry>DATE'2016/03/20' - 35</entry>
       <entry>2016-02-14 00:00:00</entry>
      </row>
      <row>
       <entry align="center">-</entry>
       <entry>DATE'2016/09/01' - DATE'2015/12/31'</entry>
       <entry>245</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    Note
   </emphasis></para>

   <para>
    If using datetime operators for the DATE type of orafce, it is necessary
    to specify "oracle" for search_path in advance.
   </para>

   <para><emphasis role="bold">
    See
   </emphasis></para>

   <para>
    Refer to "Notes on Using orafce" for information on how to edit search_path.
   </para>
  </sect3>

  <sect3>
   <title>Other functions</title>

   <para>
    The following functions is used for other purpose:
   </para>

   <itemizedlist>
    <listitem>
     <para>EMPTY_CLOB</para>
    </listitem>
    <listitem>
     <para>ORA_HASH</para>
    </listitem>
    <listitem>
     <para>VSIZE</para>
    </listitem>
    <listitem>
     <para>DEPS_SAVE_AND_DROP_DEPENDENCIES/DEPS_RESTORE_DEPENDENCIES</para>
    </listitem>
   </itemizedlist>

   <sect4>
    <title>EMPTY_CLOB</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     Return an empty CLOB 
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     EMPTY_CLOB() RETURNS clob
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Actually return ''.
      </para>
     </listitem>
     <listitem>
      <para>
       EMPTY means that the CLOB is initialized, but not populated with data.  
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using the EMPTY_CLOB function, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select length(empty_clob()) FROM DUAL;
 length 
--------
      0
(1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>ORA_HASH</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     ORA_HASH is a function that computes a hash value for a given expression.
     This function is useful for operations such as analyzing a subset of data and generating a random sample.  
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     ORA_HASH(p_data anyelement,p_buckets int4, p_seed int4) RETURNS int
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       The p_data argument determines the data for which you want LightDB Database to compute a hash value.
       There are no restrictions on the length of data represented by expr, which commonly resolves to a column name.
      </para>
     </listitem>
     <listitem>
      <para>
       The optional p_buckets argument determines the maximum bucket value returned by the hash function.
       You can specify any value between 0 and 2147483647. The default is 0. 
      </para>
     </listitem>
     <listitem>
      <para>
       The optional p_seed argument enables LightDB to produce many different results for the same set of data. LightDB applies the hash function to the combination of expr and p_seed.
       You can specify any value between 0 and 2147483647. The default is 0. 
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is int.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using ORA_HASH, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select ora_hash('abcdAbcdasd'::text) FROM DUAL;
 ora_hash  
-----------
 303228277
(1 row)
    </programlisting>
   </sect4>

   <sect4>
    <title>VSIZE</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     VSIZE returns the number of bytes in the internal representation of expr. If expr is null, then this function returns null.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     VSIZE(anyelement) RETURNS integer
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
        Same with pg_column_size.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using VSIZE, it is necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Refer to "Notes on Using orafce" for information on how to edit search_path.
      </para>
     </listitem>
     <listitem>
      <para>
       Refer to "Server Administration" > "Server Configuration" > "Setting Parameters"
       in the LightDB Documentation for information on how to set the server parameters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select vsize(123456789) FROM DUAL;
 vsize 
-------
     4
(1 row)
    </programlisting>
   </sect4>


   <sect4>
    <title>DEPS_SAVE_AND_DROP_DEPENDENCIES/DEPS_RESTORE_DEPENDENCIES</title>

    <para><emphasis role="bold">
     Description
    </emphasis></para>

    <para>
     These functions are used to modify tables that have view dependencies.
     Recursively backup all dependent views, then modify base tables, then recreate all backuped views.
    </para>

    <para>
     DEPS_SAVE_AND_DROP_DEPENDENCIES save and drop dependencies for table.
    </para>

    <para>
     DEPS_RESTORE_DEPENDENCIES restore dependencies for table.
    </para>

    <para><emphasis role="bold">
     Syntax
    </emphasis></para>

    <programlisting>
     DEPS_SAVE_AND_DROP_DEPENDENCIES(name, name default current_schema()::name, jsonb default '{}'::jsonb) RETURNS void
     DEPS_RESTORE_DEPENDENCIES(name, name default current_schema()::name, jsonb default '{}'::jsonb)
    </programlisting>

    <para><emphasis role="bold">
     General rules
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
        Create under lt_catalog.
      </para>
     </listitem>
     <listitem>
      <para>
        dependencies is saved in lt_catalog.deps_saved_ddl table.
      </para>
     </listitem>
     <listitem>
      <para>
        dry_run Run without actually dropping dependencies, default false.
      </para>
     </listitem>
     <listitem>
      <para>
        verbose Show debug log, , default false.
      </para>
     </listitem>
     <listitem>
      <para>
        populate_materialized_view Enable or disable materialized view refresh-on-create via WITH [NO] DATA flag, default false.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If using DEPS_SAVE_AND_DROP_DEPENDENCIES/DEPS_RESTORE_DEPENDENCIES, it is not necessary to specify
       "oracle" for search_path in advance.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
create table test_t(key1 int);
create view test_t_v as select * from test_t;
begin;
select deps_save_and_drop_dependencies('test_t');
alter table test_t modify key1 number;
select * from deps_restore_dependencies('test_t');
commit;
    </programlisting>
   </sect4>

  </sect3>

 </sect2>

 <sect2>
  <title>Package Reference</title>

  <para>
   A "package" is a group of features, brought together by schemas, that have a single
   functionality, and are used by calling from PL/pgSQL.
  </para>

  <para>
   The following packages are supported:
  </para>

  <itemizedlist>
   <listitem>
    <para>DBMS_ALERT</para>
   </listitem>
   <listitem>
    <para>DBMS_ASSERT</para>
   </listitem>
   <listitem>
    <para>DBMS_LOB</para>
   </listitem>
   <listitem>
    <para>DBMS_OUTPUT</para>
   </listitem>
   <listitem>
    <para>DBMS_PIPE</para>
   </listitem>
   <listitem>
    <para>DBMS_RANDOM</para>
   </listitem>
   <listitem>
    <para>DBMS_UTILITY</para>
   </listitem>
   <listitem>
    <para>DBMS_JOB</para>
   </listitem>
   <listitem>
    <para>DBMS_LOCK</para>
   </listitem>
   <listitem>
    <para>DBMS_METADATA</para>
   </listitem>
   <listitem>
    <para>DBMS_OBFUSCATION_TOOLKIT</para>
   </listitem>
   <listitem>
    <para>DBMS_SNAPSHOT</para>
   </listitem>
   <listitem>
    <para>UTL_FILE</para>
   </listitem>
   <listitem>
    <para>UTL_RAW</para>
   </listitem>
   <listitem>
    <para>UTL_URL</para>
   </listitem>
   <listitem>
    <para>UTL_ENCODE</para>
   </listitem>
  </itemizedlist>

  <para>
   To call the different functionalities from PL/pgSQL, use the PERFORM statement or SELECT
   statement, using the package name to qualify the name of the functionality. Refer to the
   explanations for each of the package functionalities for information on the format for
   calling.
  </para>

  <sect3>
   <title>DBMS_ALERT</title>
   <para><emphasis role="bold">
    Overview
   </emphasis></para>

   <para>
    The DBMS_ALERT package sends alerts from a PL/pgSQL session to multiple other PL/pgSQL sessions.
   </para>

   <para>
    This package can be used when processing 1:N, such as when notifying alerts from a given
    PL/pgSQL session to another PL/pgSQL session at the same time.
   </para>

   <table frame="all">
     <title>DBMS_ALERT Features</title>
     <tgroup cols="2" align="left">
      <colspec colname="c1" colnum="1" colwidth="1*" align="left"/>
      <colspec colname="c2" colnum="2" colwidth="2.71*" align="left"/>
      <thead>
       <row>
        <entry><emphasis role="bold">Feature</emphasis></entry>
        <entry><emphasis role="bold">Description</emphasis></entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>REGISTER</entry>
        <entry>Registers the specified alert.</entry>
       </row>
       <row>
        <entry>REMOVE</entry>
        <entry>Removes the specified alert.</entry>
       </row>
       <row>
        <entry>REMOVEALL</entry>
        <entry>Removes all alerts from a session.</entry>
       </row>
       <row>
        <entry>SIGNAL</entry>
        <entry>Notifies alerts.</entry>
       </row>
       <row>
        <entry>WAITANY</entry>
        <entry>Waits for notification of any alerts for which a session is registered.</entry>
       </row>
       <row>
        <entry>WAITONE</entry>
        <entry>Waits for notification of a specific alert for which a session is registered.</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para><emphasis role="bold">
    Syntax
   </emphasis></para>

   <mediaobject>
    <imageobject>
     <imagedata fileref="images/DBMS_ALERT.svg" format="SVG" width="100%"/>
    </imageobject>
   </mediaobject>

   <sect4>
    <title>Description of Features</title>

    <para>
     This section explains each feature of DBMS_ALERT.
    </para>

    <para><emphasis role="bold">
     REGISTER
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       REGISTER registers the specified alert to a session. By registering alerts to a session,
       SIGNAL notifications can be received.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the name of the alert.
      </para>
     </listitem>
     <listitem>
      <para>
       Alerts are case-sensitive.
      </para>
     </listitem>
     <listitem>
      <para>
       Multiple alerts can be registered within a single session. If registering multiple
       alerts, call REGISTER for each alert.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM DBMS_ALERT.REGISTER('sample_alert');
    </programlisting>

    <para><emphasis role="bold">
     REMOVE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       REMOVE removes the specified alert from a session.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the name of the alert.
      </para>
     </listitem>
     <listitem>
      <para>
       Alerts are case-sensitive.
      </para>
     </listitem>
     <listitem>
      <para>
       The message left by the alert will be removed.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM DBMS_ALERT.REMOVE('sample_alert');
    </programlisting>

    <para><emphasis role="bold">
     REMOVEALL
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       REMOVEALL removes all alerts registered within a session.
      </para>
     </listitem>
     <listitem>
      <para>
       All messages left by the alerts will be removed.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM DBMS_ALERT.REMOVEALL();
    </programlisting>

    <para><emphasis role="bold">
     SIGNAL
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       SIGNAL sends a message notification for the specified alert.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the name of the alert for which message notifications are sent.
      </para>
     </listitem>
     <listitem>
      <para>
       Alerts are case-sensitive.
      </para>
     </listitem>
     <listitem>
      <para>
       In the message, specify the alert message for notifications.
      </para>
     </listitem>
     <listitem>
      <para>
       Message notifications are not complete at the stage when SIGNAL is executed. Message
       notifications are sent upon committing the transaction. Message notifications are discarded
       if a rollback is performed after SIGNAL is executed.
      </para>
     </listitem>
     <listitem>
      <para>
       If message notifications are sent for the same alert from multiple sessions, the
       messages will be accumulated without being removed.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM DBMS_ALERT.SIGNAL('ALERT001','message001');
    </programlisting>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     If SIGNAL is issued continuously and the accumulated messages exceed a certain amount, an
     insufficient memory error may be output. If the memory becomes insufficient, call AITANY or
     WAITONE to receive an alert, and reduce the accumulated messages.
    </para>

    <para><emphasis role="bold">
     WAITANY
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       WAITANY waits for notification of any alerts registered for a session.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the maximum wait time <emphasis role="italic">timeout</emphasis> in seconds to
       wait for an alert.
      </para>
     </listitem>
     <listitem>
      <para>
       Use a SELECT statement to obtain the notified information, which is stored in the name,
       message and status columns.
      </para>
     </listitem>
     <listitem>
      <para>
       The name column stores the alert names. The data type of name is TEXT.
      </para>
     </listitem>
     <listitem>
      <para>
       The message column stores the messages of notified alerts. The data type of message is TEXT.
      </para>
     </listitem>
     <listitem>
      <para>
       The status column stores the status code returned by the operation: 0-an alert occurred;
       1-a timeout occurred. The data type of status is INTEGER.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         alert_name         TEXT := 'sample_alert';
         alert_message      TEXT;
         alert_status       INTEGER;
     BEGIN
         SELECT name,message,status INTO alert_name,alert_message,alert_status FROM DBMS_ALERT.WAITANY(60);
    </programlisting>

    <para><emphasis role="bold">
     WAITONE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       WAITONE waits for notification of the specified alert.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the name of the alert to wait for.
      </para>
     </listitem>
     <listitem>
      <para>
       Alerts are case-sensitive.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the maximum wait time <emphasis role="italic">timeout</emphasis> in seconds to
       wait for the alert.
      </para>
     </listitem>
     <listitem>
      <para>
       Use a SELECT statement to obtain the notified information, which is stored in the
       message and status columns.
      </para>
     </listitem>
     <listitem>
      <para>
       The message column stores the messages of notified alerts. The data type of message is TEXT.
      </para>
     </listitem>
     <listitem>
      <para>
       The status column stores the status code returned by the operation: 0-an alert occurred;
       1-a timeout occurred. The data type of status is INTEGER.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         alert_message   TEXT;
         alert_status    INTEGER;
     BEGIN
         SELECT message,status INTO alert_message,alert_status FROM DBMS_ALERT.WAITONE('sample_alert', 60);
    </programlisting>
   </sect4>

   <sect4>
    <title>Usage Example</title>

    <para>
     Below is a usage example of the processing flow of DBMS_ALERT.
    </para>

    <para><emphasis role="bold">
     DBMS_ALERT flow
    </emphasis></para>

    <mediaobject>
     <imageobject>
      <imagedata fileref="images/DBMS_ALERT_flow.svg" format="SVG" width="100%"/>
     </imageobject>
    </mediaobject>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       The target of message notifications by SIGNAL is sessions for which REGISTER is executed
       at the time of executing SIGNAL.
      </para>
     </listitem>
     <listitem>
      <para>
       On the receiving side, always ensure that REMOVE or REMOVEALL is used to remove alerts
       as soon as the alerts are no longer needed. If a session is closed without removing the
       alerts, it may no longer be possible to receive a SIGNAL for alerts of the same name in
       another session.
      </para>
     </listitem>
     <listitem>
      <para>
       DBMS_ALERT and DBMS_PIPE use the same memory environment. Therefore, when insufficient
       memory is detected for DBMS_PIPE, it is possible that insufficient memory will also be
       detected for DBMS_ALERT.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Usage example
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Sending side
      </para>
     </listitem>
    </itemizedlist>

    <programlisting>
     CREATE FUNCTION send_dbms_alert_exe() RETURNS VOID AS $$
     BEGIN
         PERFORM DBMS_ALERT.SIGNAL('sample_alert','SIGNAL ALERT');
     END;
     $$ LANGUAGE plpgsql;
     SELECT send_dbms_alert_exe();
     DROP FUNCTION send_dbms_alert_exe();
    </programlisting>

    <itemizedlist>
     <listitem>
      <para>
       Receiving side
      </para>
     </listitem>
    </itemizedlist>

    <programlisting>
     CREATE FUNCTION receive_dbms_alert_exe() RETURNS VOID AS $$
     DECLARE
         alert_name    TEXT := 'sample_alert';
     	alert_message TEXT;
     	alert_status  INTEGER;
     BEGIN
     	PERFORM DBMS_ALERT.REGISTER(alert_name);
     	SELECT message,status INTO alert_message,alert_status FROM DBMS_ALERT.WAITONE(alert_name,300);
     	RAISE NOTICE 'Message : %', alert_message;
     	RAISE NOTICE 'Status  : %', alert_status;
     	PERFORM DBMS_ALERT.REMOVE(alert_name);
     END;
     $$ LANGUAGE plpgsql;
     SELECT receive_dbms_alert_exe();
     DROP FUNCTION receive_dbms_alert_exe();
    </programlisting>
   </sect4>
  </sect3>

  <sect3>
   <title>DBMS_ASSERT</title>

   <para><emphasis role="bold">
    Overview
   </emphasis></para>

   <para>
    Performs verification of the properties of input values in PL/pgSQL.
   </para>

   <table>
    <title>DBMS_ASSERT Features</title>
    <tgroup cols="2">
     <colspec colnum="1" colname="col1"/>
     <colspec colnum="2" colname="col2"/>
     <thead>
      <row>
       <entry>Feature</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>ENQUOTE_LITERAL</entry>
       <entry>Returns the specified string enclosed in single quotation marks.</entry>
      </row>
      <row>
       <entry>ENQUOTE_NAME</entry>
       <entry>Returns the specified string enclosed in double quotation marks.</entry>
      </row>
      <row>
       <entry>NOOP</entry>
       <entry>Returns the specified string as is.</entry>
      </row>
      <row>
       <entry>OBJECT_NAME</entry>
       <entry>Verifies if the specified string is a defined identifier.</entry>
      </row>
      <row>
       <entry>QUALIFIED_SQL_NAME</entry>
       <entry>Verifies if the specified string is in the appropriate format as an identifier.</entry>
      </row>
      <row>
       <entry>SCHEMA_NAME</entry>
       <entry>Verifies if the specified string is a defined schema.</entry>
      </row>
      <row>
       <entry>SIMPLE_SQL_NAME</entry>
       <entry>Verifies if the specified string is in the appropriate format as a single identifier.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    Syntax
   </emphasis></para>

   <mediaobject>
    <imageobject>
     <imagedata fileref="images/DBMS_ASSERT.svg" format="SVG" width="100%"/>
    </imageobject>
   </mediaobject>

   <sect4>
    <title>Description of Features</title>

    <para>
     This section explains each feature of DBMS_ASSERT.
    </para>

    <para><emphasis role="bold">
     ENQUOTE_LITERAL
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       ENQUOTE_LITERAL returns the specified string enclosed in single quotation marks.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify a string enclosed in single quotation marks.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is VARCHAR.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         q_literal    VARCHAR(256);
     BEGIN
         q_literal := DBMS_ASSERT.ENQUOTE_LITERAL('literal_word');
    </programlisting>

    <para><emphasis role="bold">
     ENQUOTE_NAME
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       ENQUOTE_NAME returns the specified string enclosed in double quotation marks.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify a string enclosed in double quotation marks.
      </para>
     </listitem>
     <listitem>
      <para>
       For lowercase conversion, specify TRUE or FALSE. Specify TRUE to convert uppercase
       characters in the string to lowercase. If FALSE is specified, conversion to lowercase will
       not take place. The default is TRUE.
      </para>
     </listitem>
     <listitem>
      <para>
       If all the characters in the string are lowercase, they will not be enclosed in double
       quotation marks.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is VARCHAR.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "The SQL Language" > "Data Types" > "Boolean Type" in the LightDB
     Documentation for information on boolean type (TRUE/FALSE) values.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         dq_literal    VARCHAR(256);
     BEGIN
         dq_literal := DBMS_ASSERT.ENQUOTE_NAME('TBL001');
    </programlisting>

    <para><emphasis role="bold">
     NOOP
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       NOOP returns the specified string as is.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify a string.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is VARCHAR.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         literal    VARCHAR(256);
     BEGIN
         literal := DBMS_ASSERT.NOOP('NOOP_WORD');
    </programlisting>

    <para><emphasis role="bold">
     OBJECT_NAME
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       OBJECT_NAME verifies if the specified string is a defined identifier.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the identifier for verification. If the identifier has been defined, the
       specified identifier will be returned. Otherwise, the following error will occur.
      </para>
     </listitem>
    </itemizedlist>

    <programlisting>
     ERROR:  invalid object name
    </programlisting>

    <itemizedlist>
     <listitem>
      <para>
       The data type of the return value is VARCHAR.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         object_name    VARCHAR(256);
     BEGIN
         object_name := DBMS_ASSERT.OBJECT_NAME('SCM001.TBL001');
    </programlisting>

    <para><emphasis role="bold">
     QUALIFIED_SQL_NAME
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       QUALIFIED_SQL_NAME verifies if the specified string is in the appropriate format as an identifier.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the identifier for verification. If the string can be used as an identifier, the
       specified identifier will be returned. Otherwise, the following error will occur.
      </para>
     </listitem>
    </itemizedlist>

    <programlisting>
     ERROR:  string is not qualified SQL name
    </programlisting>

    <itemizedlist>
     <listitem>
      <para>
       The data type of the return value is VARCHAR.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "The SQL Language" > "Lexical Structure" > "Identifiers and Key Words" in the
     LightDB Documentation for information on the formats that can be used as identifiers.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         object_name    VARCHAR(256);
     BEGIN
         object_name := DBMS_ASSERT.QUALIFIED_SQL_NAME('SCM002.TBL001');
    </programlisting>

    <para><emphasis role="bold">
     SCHEMA_NAME
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       SCHEMA_NAME verifies if the specified string is a defined schema.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify a schema name for verification. If the schema has been defined, the specified
       schema name will be returned. Otherwise, the following error will occur.
      </para>
     </listitem>
    </itemizedlist>

    <programlisting>
     ERROR:  invalid schema name
    </programlisting>

    <itemizedlist>
     <listitem>
      <para>
       The data type of the return value is VARCHAR.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         schema_name    VARCHAR(256);
     BEGIN
         schema_name := DBMS_ASSERT.SCHEMA_NAME('SCM001');
    </programlisting>

    <para><emphasis role="bold">
     SIMPLE_SQL_NAME
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       SIMPLE_SQL_NAME verifies if the specified string is in the appropriate format as a
       single identifier.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify an identifier for verification. If the specified string can be used as an
       identifier, the specified identifier will be returned. Otherwise, the following error will
       occur.
      </para>
     </listitem>
    </itemizedlist>

    <programlisting>
     ERROR:  string is not qualified SQL name
    </programlisting>

    <itemizedlist>
     <listitem>
      <para>
       The data type of the return value is VARCHAR.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "The SQL Language" > "Lexical Structure" > "Identifiers and Key Words" in the
     LightDB Documentation for information on the formats that can be used as identifiers. Note
     that an error will occur if an identifier using fullwidth characters is specified. If fullwidth
     characters are included, specify a quoted identifier.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         simple_name    VARCHAR(256);
     BEGIN
         simple_name := DBMS_ASSERT.SIMPLE_SQL_NAME('COL01');
    </programlisting>
   </sect4>

   <sect4>
    <title>Usage Example</title>

    <para>
     A usage example of DBMS_ASSERT is shown below.
    </para>

    <programlisting>
     CREATE FUNCTION dbms_assert_exe() RETURNS VOID AS $$
     DECLARE
     	w_schema VARCHAR(20) := 'public';
     	w_table  VARCHAR(20) := 'T1';
     	w_object VARCHAR(40);
     BEGIN
     	PERFORM DBMS_ASSERT.NOOP(w_schema);
     	PERFORM DBMS_ASSERT.SIMPLE_SQL_NAME(w_table);
     	PERFORM DBMS_ASSERT.SCHEMA_NAME(w_schema);
     	w_object := w_schema || '.' || w_table;
     	PERFORM DBMS_ASSERT.QUALIFIED_SQL_NAME(w_object);
     	PERFORM DBMS_ASSERT.OBJECT_NAME(w_object);
     	RAISE NOTICE 'OBJECT     : %', DBMS_ASSERT.ENQUOTE_LITERAL(w_object);
     	RAISE NOTICE 'TABLE_NAME : %', DBMS_ASSERT.ENQUOTE_NAME(w_table);
     END;
     $$
     LANGUAGE plpgsql;
     SELECT dbms_assert_exe();
     DROP FUNCTION dbms_assert_exe();
    </programlisting>
   </sect4>
  </sect3>
  <sect3>
   <title>DBMS_LOB</title>

   <para><emphasis role="bold">
    Overview
   </emphasis></para>   
   <para>
    Some functions compatible with DBMS_LOB package.
   </para>

   <table>
    <title>DBMS_LOB Features</title>
    <tgroup cols="2">
     <colspec colnum="1" colname="col1"/>
     <colspec colnum="2" colname="col2"/>
     <thead>
      <row>
       <entry>Feature</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>INSTR</entry>
       <entry>Returns starting index of specified LOB.</entry>
      </row>
      <row>
       <entry>SUBSTR</entry>
       <entry>Extracts the substring of LOB.</entry>
      </row>
      <row>
       <entry>GETLENGTH</entry>
       <entry>Returns the number of characters in the LOB.</entry>
      </row>
      <row>
       <entry>APPEND</entry>
       <entry>Appends the contents of the source LOB to the destination LOB.</entry>
      </row>
      <row>
       <entry>CLOSE</entry>
       <entry>Closes a previously opened internal or external LOB.(invalid)</entry>
      </row>
      <row>
       <entry>COMPARE</entry>
       <entry>Compares two entire LOBs or parts of two LOBs.</entry>
      </row>

      <row>
       <entry>COPY</entry>
       <entry>Copies all, or part, of the source LOB to the destination LOB.</entry>
      </row>
      <row>
       <entry>CREATETEMPORAR</entry>
       <entry>Creates a temporary BLOB or CLOB and its corresponding index in the user's default temporary tablespace.(invalid)</entry>
      </row>
      <row>
       <entry>ERASE</entry>
       <entry>Erases all or part of a LOB.</entry>
      </row>
      <row>
       <entry>FREETEMPORARY</entry>
       <entry>Erases all or part of a LOB.</entry>
      </row>
      <row>
       <entry>OPEN</entry>
       <entry>Frees the temporary BLOB or CLOB in the default temporary tablespace.(invalid)</entry>
      </row>
      <row>
       <entry>READ</entry>
       <entry>Reads data from the LOB starting at the specified offset.</entry>
      </row>
      <row>
       <entry>TRIM</entry>
       <entry>Trims the LOB value to the specified shorter length.</entry>
      </row>
      <row>
       <entry>WRITE</entry>
       <entry>Writes data to the LOB from a specified offset.</entry>
      </row>
      <row>
       <entry>WRITEAPPEND</entry>
       <entry>Writes a buffer to the end of a LOB.</entry>
      </row>
      <row>
       <entry>COMPARE</entry>
       <entry>Compares two entire LOBs or parts of two LOBs.</entry>
      </row>
      <row>
       <entry>COMPARE</entry>
       <entry>Compares two entire LOBs or parts of two LOBs.</entry>
      </row>
      <row>
       <entry>COMPARE</entry>
       <entry>Compares two entire LOBs or parts of two LOBs.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

    <para><emphasis role="bold">
    Syntax
    </emphasis></para>
    <programlisting>
     INSTR(STR TEXT, PATT TEXT, START INTEGER DEFAULT  1, NTH INTEGER DEFAULT 1) RETURNS INTEGER
     INSTR(STR BLOB, PATT TEXT, START INTEGER DEFAULT  1, NTH INTEGER DEFAULT 1) RETURNS INTEGER
     SUBSTR(STR TEXT, AMOUNT INTEGER DEFAULT 32767, START_OFFSET INTEGER DEFAULT 1) RETURNS TEXT
     SUBSTR(STR BLOB, AMOUNT INTEGER DEFAULT 32767, START_OFFSET INTEGER DEFAULT 1) RETURNS TEXT
     GETLENGTH(STR TEXT) RETURNS INTEGER
     GETLENGTH(STR BLOB) RETURNS INTEGER 
     APPEND(dest_lob BLOB,src_lob BLOB)/APPEND(CLOB,CLOB) 
     COMPARE(lob_1 BLOB,lob_2 BLOB,amount INT4 DEFAULT 2147483647,offset_1 INT4 DEFAULT 1,offset_2 INT4 DEFAULT 1)/COMPARE(CLOB,CLOB,INT4 DEFAULT 2147483647,INT4 DEFAULT 1,INT4 DEFAULT 1)
     COPY(dest_lob BLOB,src_lob BLOB,amount INT4,dest_offset INT4 DEFAULT 1,src_offset INT4 DEFAULT 1)/COPY(CLOB,CLOB,INT4,INT4 DEFAULT 1,INT4 DEFAULT 1)
     ERASE(lob_loc BLOB,amount INT4,p_offset INT4 DEFAULT 1)/ERASE(CLOB,INT4,INT4 DEFAULT 1)
     READ(lob_loc BLOB,amount INT4,p_offset INT4,buffer RAW)/READ(CLOB,INT4,INT4,TEXT)
     TRIM(lob_loc BLOB,newlen INT4)/TRIM(CLOB,INT4)
     WRITE(lob_loc BLOB,amount INT4,p_offset INT4,buffer RAW)/WRITE(CLOB,INT4,INT4,TEXT)
     WRITEAPPEND(lob_loc BLOB,amount INT4,buffer RAW)/WRITEAPPEND(CLOB,INT4,TEXT)
    </programlisting>
   <para><emphasis role="bold">
    Features
   </emphasis></para>
   
   <sect4>
    <title>Description</title>

    <para>
     This section explains each feature of DBMS_LOB.
    </para>

    <para><emphasis role="bold">
     INSTR
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Offset of the start of the matched pattern, in bytes or characters.It returns 0 if the pattern is not found.
      </para>
     </listitem>
     <listitem>
      <para>
       It retruns null if -any one or more of the IN parameters was NULL or INVALID.
      </para>
     </listitem>
     <listitem>
      <para>
       It returns NULL if offset &lt; 1.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     select dbms_lob.INSTR('Thomas', 'om') from  dual;
     select dbms_lob.INSTR('Thomas'::blob, utl_raw.CAST_TO_RAW('om')) from  dual;
    </programlisting>

    <para><emphasis role="bold">
     SUBSTR
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Extracts the substring of string starting at the start'th character if that is specified, and stopping after count characters if that is specified. 
      </para>
     </listitem>
     <listitem>
      <para>
       It returns NULL if any input parameter is NULL
      </para>
     </listitem>
     <listitem>
      <para>
       It returns NULL if amount &lt; 1.
      </para>
     </listitem>
     <listitem>
      <para>
       It returns NULL if offset &lt; 1.  
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     select dbms_lob.substr('1234567',1,2) from  dual;
     select dbms_lob.substr('1234567'::blob,1,2) from  dual;
    </programlisting>

    <para><emphasis role="bold">
     GETLENGTH
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       The length of the text in bytes or characters as an INTEGER.
      </para>
     </listitem>
     <listitem>
      <para>
       NULL is returned if the input str is NULL.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     select DBMS_LOB.GETLENGTH('abc') from dual;
    </programlisting>

    <para><emphasis role="bold">
     APPEND
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Appends the contents of the source LOB to the destination LOB.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
declare
    l_blob          blob := 'abcd'::blob;
    l_clob          clob := 'abcd'::clob;
begin
    dbms_output.serveroutput(true);
    dbms_lob.append(l_blob, 'ext'::blob);
    dbms_output.put_line(l_blob::text);

    dbms_lob.append(l_clob, 'ext'::clob);
    dbms_output.put_line(l_clob);
end;
/
    </programlisting>

    <para><emphasis role="bold">
     COMPARE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Compares two entire LOBs or parts of two LOBs.
      </para>
     </listitem>
     <listitem>
      <para>
       0 if the comparison succeeds, nonzero if not.
      </para>
     </listitem>
     <listitem>
      <para>
        If any of amount, offset_1 or offset_2 is not a valid LOB offset value. A valid offset is within the range of 1 to LOBMAXSIZE inclusive.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
declare
    l_result        int;
    l_blob          blob := 'abcd'::blob;
    l_clob          clob := 'abcd'::clob;
    l_raw_result    raw;
    l_amout         INTEGER := 100;
    l_text_result  text;
begin
    dbms_output.serveroutput(true);
    l_result := dbms_lob.compare('abcd'::blob, 'abcd'::blob);
    dbms_output.put_line(l_result);
    l_result := dbms_lob.compare('abcd'::clob, 'abcd'::clob);
    dbms_output.put_line(l_result);

end;
/
    </programlisting>

    <para><emphasis role="bold">
     COPY
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Copies all, or part, of the source LOB to the destination LOB.
       You can specify the offsets for both the source and destination LOBs, and the number of bytes or characters to copy.
      </para>
     </listitem>
     <listitem>
      <para>
       If the offset you specify in the destination LOB is beyond the end of the data currently in this LOB, then zero-byte fillers or spaces are inserted in the destination BLOB or CLOB respectively. If the offset is less than the current length of the destination LOB, then existing data is overwritten.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
declare
    l_result        int;
    l_blob          blob := 'abcd'::blob;
    l_clob          clob := 'abcd'::clob;
    l_raw_result    raw;
    l_amout         INTEGER := 100;
    l_text_result  text;
begin
    dbms_output.serveroutput(true);
    dbms_lob.copy(l_blob, 'new_blob'::blob, 100);
    dbms_output.put_line(l_blob::text);
    dbms_lob.copy(l_blob, 'xnew_blob'::blob, 100, 1, 2);
    dbms_output.put_line(l_blob::text);
    dbms_lob.copy(l_blob, 'xnew_blob'::blob, 100, 2, 2);
    dbms_output.put_line(l_blob::text);
end;
/
    </programlisting>

    <para><emphasis role="bold">
     ERASE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Erases an entire internal LOB or part of an internal LOB.
      </para>
     </listitem>
     <listitem>
      <para>
       When data is erased from the middle of a LOB, zero-byte fillers or spaces are written for BLOBs or CLOBs respectively.
      </para>
     </listitem>
     <listitem>
      <para>
       The actual number of bytes or characters erased can differ from the number you specified in the amount parameter if the end of the LOB value is reached before erasing the specified number. The actual number of characters or bytes erased is returned in the amount parameter.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
declare
    l_result        int;
    l_blob          blob := 'abcd'::blob;
    l_clob          clob := 'abcd'::clob;
    l_raw_result    raw;
    l_amout         INTEGER := 100;
    l_text_result  text;
begin
    dbms_output.serveroutput(true);

    l_blob := 'abcd'::blob;
    l_amout := 100;
    dbms_output.put_line(l_blob::text);
    dbms_lob.erase(l_blob, l_amout);
    dbms_output.put_line(l_blob::text);

    l_clob := 'abcd'::clob;
    l_amout := 4;
    dbms_lob.erase(l_clob, l_amout);
    dbms_output.put_line(l_clob);
end;
/
    </programlisting>


    <para><emphasis role="bold">
     READ
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This procedure reads a piece of a LOB, and returns the specified amount into the buffer parameter, starting from an absolute offset from the beginning of the LOB.
      </para>
     </listitem>
     <listitem>
      <para>
       The number of bytes or characters actually read is returned in the amount parameter. If the input offset points past the End of LOB, then amount is set to 0, and a NO_DATA_FOUND exception is raised.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
declare
    l_result        int;
    l_blob          blob := 'abcd'::blob;
    l_clob          clob := 'abcd'::clob;
    l_raw_result    raw;
    l_amout         INTEGER := 100;
    l_text_result  text;
begin
    dbms_output.serveroutput(true);

    l_amout := 5;
    dbms_lob.read('abcde'::blob, l_amout, 1, l_raw_result);
    dbms_output.put_line(l_raw_result);

    l_amout := 5;
    dbms_lob.read('abcde'::clob, l_amout, 1, l_text_result);
    dbms_output.put_line(l_text_result);
end;
/
    </programlisting>


    <para><emphasis role="bold">
     TRIM
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This procedure trims the value of the internal LOB to the length you specify in the newlen parameter. Specify the length in bytes for BLOBs, and specify the length in characters for CLOBs.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
declare
    l_result        int;
    l_blob          blob := 'abcd'::blob;
    l_clob          clob := 'abcd'::clob;
    l_raw_result    raw;
    l_amout         INTEGER := 100;
    l_text_result  text;
begin
    dbms_output.serveroutput(true);

    l_blob := 'abcde'::blob;
    dbms_lob.trim(l_blob, 1);
    dbms_output.put_line(l_blob::text);

    l_clob := 'abcde'::clob;
    dbms_lob.trim(l_clob, 1);
    dbms_output.put_line(l_clob);
end;
/
    </programlisting>

    <para><emphasis role="bold">
     WRITE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This procedure writes a specified amount of data into an internal LOB, starting from an absolute offset from the beginning of the LOB. The data is written from the buffer parameter.
      </para>
     </listitem>
     <listitem>
      <para>
       WRITE replaces (overwrites) any data that already exists in the LOB at the offset, for the length you specify.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
declare
    l_result        int;
    l_blob          blob := 'abcd'::blob;
    l_clob          clob := 'abcd'::clob;
    l_raw_result    raw;
    l_amout         INTEGER := 100;
    l_text_result  text;
begin
    dbms_output.serveroutput(true);

    l_blob := 'abcde'::blob;
    dbms_lob.write(l_blob, pg_catalog.length(utl_raw.CAST_TO_RAW('测试')), 2, utl_raw.CAST_TO_RAW('测试'));
    dbms_output.put_line(l_blob::text);

    -- write clob
    l_clob := 'abcde'::clob;
    dbms_lob.write(l_clob, 2, 2,'测试'::text);
    dbms_output.put_line(l_clob);
end;
/
    </programlisting>

    <para><emphasis role="bold">
     WRITEAPPEND
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This procedure writes a specified amount of data to the end of an internal LOB. The data is written from the buffer parameter.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
declare
    l_result        int;
    l_blob          blob := 'abcd'::blob;
    l_clob          clob := 'abcd'::clob;
    l_raw_result    raw;
    l_amout         INTEGER := 100;
    l_text_result  text;
begin
    dbms_output.serveroutput(true);

    -- writeappend blob
    l_blob := 'abcde'::blob;
    dbms_lob.writeappend(l_blob, pg_catalog.length(utl_raw.CAST_TO_RAW('测试')), utl_raw.CAST_TO_RAW('测试'));
    dbms_output.put_line(l_blob::text);

    -- write clob
    l_clob := 'abcde'::clob;
    dbms_lob.writeappend(l_clob, 2,'测试'::text);
    dbms_output.put_line(l_clob);
end;
/
    </programlisting>

   </sect4>

   <sect4>
    <title>Usage Example</title>

    <para>
     A usage example of DBMS_LOB is shown below.
    </para>

    <programlisting>
     CREATE PROCEDURE dbms_lob_exe() AS $$
     DECLARE
     	str1 text;
        str2 text;
     	pos INTEGER;
        count INTEGER;
     BEGIN
     	str2 := dbms_lob.substr('1234567',2,3);
        pos := dbms_lob.instr('Tech on the net', 'e');
        count := dbms_lob.getlength('1234567');
        raise info 'str2=%,pos=%,count=%', str2, pos, count;
     END;
     $$ LANGUAGE plpgsql;
     call dbms_lob_exe();
     DROP PROCEDURE dbms_lob_exe();
    </programlisting>
   </sect4>
  </sect3>

  <sect3>
   <title>DBMS_OUTPUT</title>

   <para><emphasis role="bold">
    Overview
   </emphasis></para>

   <para>
    Sends messages to clients such as ltsql from PL/pgSQL.
   </para>

   <para><emphasis role="bold">
    Features
   </emphasis></para>

   <table>
    <title>DBMS_OUTPUT Features</title>
    <tgroup cols="2">
     <colspec colnum="1" colname="col1"/>
     <colspec colnum="2" colname="col2"/>
     <thead>
      <row>
       <entry>Feature</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>ENABLE</entry>
       <entry>Enables features of this package.</entry>
      </row>
      <row>
       <entry>DISABLE</entry>
       <entry>Disables features of this package.</entry>
      </row>
      <row>
       <entry>SERVEROUTPUT</entry>
       <entry>Controls whether messages are sent.</entry>
      </row>
      <row>
       <entry>PUT</entry>
       <entry>Sends messages.</entry>
      </row>
      <row>
       <entry>PUT_LINE</entry>
       <entry>Sends messages with a newline character appended.</entry>
      </row>
      <row>
       <entry>NEW_LINE</entry>
       <entry>Sends a newline character.</entry>
      </row>
      <row>
       <entry>GET_LINE</entry>
       <entry>Retrieves a line from the message buffer.</entry>
      </row>
      <row>
       <entry>GET_LINES</entry>
       <entry>Retrieves multiple lines from the message buffer.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    Syntax
   </emphasis></para>

   <mediaobject>
    <imageobject>
     <imagedata fileref="images/DBMS_OUTPUT.svg" format="SVG" width="100%"/>
    </imageobject>
   </mediaobject>

   <sect4>
    <title>Description</title>

    <para>
     This section explains each feature of DBMS_OUTPUT.
    </para>

    <para><emphasis role="bold">
     ENABLE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       ENABLE enables the use of PUT, PUT_LINE, NEW_LINE, GET_LINE, and GET_LINES.
      </para>
     </listitem>
     <listitem>
      <para>
       With multiple executions of ENABLE, the value specified last is the buffer size (in
       bytes). Specify a buffer size from 2000 to 1000000.
      </para>
     </listitem>
     <listitem>
      <para>
       The default value of the buffer size is 20000. If NULL is specified as the buffer size,
       1000000 will be used.
      </para>
     </listitem>
     <listitem>
      <para>
       If ENABLE has not been executed, PUT, PUT_LINE, NEW_LINE, GET_LINE, and GET_LINES are
       ignored even if they are executed.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM DBMS_OUTPUT.ENABLE(20000);
    </programlisting>

    <para><emphasis role="bold">
     DISABLE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       DISABLE disables the use of PUT, PUT_LINE, NEW_LINE, GET_LINE, and GET_LINES.
      </para>
     </listitem>
     <listitem>
      <para>
       Remaining buffer information is discarded.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM DBMS_OUTPUT.DISABLE();
    </programlisting>

    <para><emphasis role="bold">
     SERVEROUTPUT
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       SERVEROUTPUT controls whether messages are sent.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify TRUE or FALSE for <emphasis role="italic">sendMsgs</emphasis>.
      </para>
     </listitem>
     <listitem>
      <para>
       If TRUE is specified, when PUT, PUT_LINE, or NEW_LINE is executed, the message is sent
       to a client such as ltsql and not stored in the buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       If FALSE is specified, when PUT, PUT_LINE, or NEW_LINE is executed, the message is
       stored in the buffer and not sent to a client such as ltsql.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "The SQL Language" > "Data Types" > "Boolean Type" in the LightDB
     Documentation for information on boolean type (TRUE/FALSE) values.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM DBMS_OUTPUT.SERVEROUTPUT(TRUE);
    </programlisting>

    <para><emphasis role="bold">
     PUT
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       PUT sets the message to be sent.
      </para>
     </listitem>
     <listitem>
      <para>
       The string is the message to be sent.
      </para>
     </listitem>
     <listitem>
      <para>
       When TRUE is specified for SERVEROUTPUT, the messages are sent to clients such as ltsql.
      </para>
     </listitem>
     <listitem>
      <para>
       When FALSE is specified for SERVEROUTPUT, the messages are retained in the buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       PUT does not append a newline character. To append a newline character, execute NEW_LINE.
      </para>
     </listitem>
     <listitem>
      <para>
       If a string longer than the buffer size specified in ENABLE is sent, an error occurs.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM DBMS_OUTPUT.PUT('abc');
    </programlisting>

    <para><emphasis role="bold">
     PUT_LINE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       PUT_LINE sets the message to be sent appended with a newline character.
      </para>
     </listitem>
     <listitem>
      <para>
       The string is the message to be sent.
      </para>
     </listitem>
     <listitem>
      <para>
       When TRUE is specified for SERVEROUTPUT, the messages are sent to clients such as ltsql.
      </para>
     </listitem>
     <listitem>
      <para>
       When FALSE is specified for SERVEROUTPUT, the messages are retained in the buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       If a string longer than the buffer size specified in ENABLE is sent, an error occurs.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM DBMS_OUTPUT.PUT_LINE('abc');
    </programlisting>

    <para><emphasis role="bold">
     NEW_LINE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       NEW_LINE appends a newline character to the message created with PUT.
      </para>
     </listitem>
     <listitem>
      <para>
       When TRUE is specified for SERVEROUTPUT, the messages are sent to clients such as ltsql.
      </para>
     </listitem>
     <listitem>
      <para>
       When FALSE is specified for SERVEROUTPUT, the messages are retained in the buffer.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM DBMS_OUTPUT.NEW_LINE();
    </programlisting>

    <para><emphasis role="bold">
     GET_LINE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       GET_LINE retrieves a line from the message buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       Use a SELECT statement to obtain the retrieved line and status code returned by the
       operation, which are stored in the line and status columns.
      </para>
     </listitem>
     <listitem>
      <para>
       The line column stores the line retrieved from the buffer. The data type of line is TEXT.
      </para>
     </listitem>
     <listitem>
      <para>
       The status column stores the status code returned by the operation: 0-completed successfully;
       1-failed because there are no more lines in the buffer. The data type of status is INTEGER.
      </para>
     </listitem>
     <listitem>
      <para>
       If GET_LINE or GET_LINES is executed and then PUT, PUT_LINE or PUT_LINES is executed
       while messages that have not been retrieved from the buffer still exist, the messages not
       retrieved from the buffer will be discarded.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         buff1   VARCHAR(20);
         stts1   INTEGER;
     BEGIN
         SELECT line,status INTO buff1,stts1 FROM DBMS_OUTPUT.GET_LINE();
    </programlisting>

    <para><emphasis role="bold">
     GET_LINES
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       GET_LINES retrieves multiple lines from the message buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the number of lines to retrieve from the buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       Use a SELECT statement to obtain the retrieved lines and the number of lines retrieved,
       which are stored in the lines and numlines columns.
      </para>
     </listitem>
     <listitem>
      <para>
       The lines column stores the lines retrieved from the buffer. The data type of lines is TEXT.
      </para>
     </listitem>
     <listitem>
      <para>
       The numlines column stores the number of lines retrieved from the buffer. If this number
       is less than the number of lines requested, then there are no more lines in the buffer. The
       data type of numlines is INTEGER.
      </para>
     </listitem>
     <listitem>
      <para>
       If GET_LINE or GET_LINES is executed and then PUT, PUT_LINE, or NEW_LINE is executed
       while messages that have not been retrieved from the buffer still exist, the messages not
       retrieved from the buffer will be discarded.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         buff    VARCHAR(20)[10];
         stts    INTEGER := 10;
     BEGIN
         SELECT lines, numlines INTO buff,stts FROM DBMS_OUTPUT.GET_LINES(stts);
    </programlisting>
   </sect4>

   <sect4>
    <title>Usage Example</title>

    <para>
     A usage example of DBMS_OUTPUT is shown below.
    </para>

    <programlisting>
     CREATE FUNCTION dbms_output_exe() RETURNS VOID AS $$
     DECLARE
     	buff1 VARCHAR(20);
     	buff2 VARCHAR(20);
     	stts1 INTEGER;
     	stts2 INTEGER;
     BEGIN
     	PERFORM DBMS_OUTPUT.DISABLE();
     	PERFORM DBMS_OUTPUT.ENABLE();
     	PERFORM DBMS_OUTPUT.SERVEROUTPUT(FALSE);
     	PERFORM DBMS_OUTPUT.PUT('DBMS_OUTPUT TEST 1');
     	PERFORM DBMS_OUTPUT.NEW_LINE();
     	PERFORM DBMS_OUTPUT.PUT_LINE('DBMS_OUTPUT TEST 2');
     	SELECT line,status INTO buff1,stts1 FROM DBMS_OUTPUT.GET_LINE();
     	SELECT line,status INTO buff2,stts2 FROM DBMS_OUTPUT.GET_LINE();
     	PERFORM DBMS_OUTPUT.SERVEROUTPUT(TRUE);
     	PERFORM DBMS_OUTPUT.PUT_LINE(buff1);
     	PERFORM DBMS_OUTPUT.PUT_LINE(buff2);
     END;
     $$ LANGUAGE plpgsql;
     SELECT dbms_output_exe();
     DROP FUNCTION dbms_output_exe();
    </programlisting>
   </sect4>
  </sect3>

  <sect3>
   <title>DBMS_PIPE</title>

   <para><emphasis role="bold">
    Overview
   </emphasis></para>

   <para>
    Performs communication between sessions that execute PL/pgSQL.
   </para>

   <para>
    This package can be used for 1:1 communication, such as when data is being exchanged
    between sessions executing PL/pgSQL.
   </para>

   <para>
    For pipes, there are explicit pipes and implicit pipes, and furthermore, for explicit
    pipes, you can select public pipes and private pipes. The characteristics of each type are as
    follows:
   </para>

   <para><emphasis role="bold">
    Types of pipes
   </emphasis></para>

   <table>
    <title>Types of pipes</title>
    <tgroup cols="2">
     <colspec colnum="1" colname="col1"/>
     <colspec colnum="2" colname="col2"/>
     <thead>
      <row>
       <entry>Type</entry>
       <entry>Characteristics</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>Explicit pipe</entry>
       <entry>
        <para>- CREATE_PIPE is used to create a pipe explicitly.</para>
        <para>- While creating a pipe, you can select between a public pipe and private pipe.</para>
        <para>- It is necessary to use REMOVE_PIPE to explicitly remove a pipe.</para>
       </entry>
      </row>
      <row>
       <entry>Implicit pipe</entry>
       <entry>
        <para>- Created automatically when SEND_MESSAGE and RECEIVE_MESSAGE are used.</para>
        <para>- The pipe that is created becomes a public pipe.</para>
        <para>- When messages are received using RECEIVE_MESSAGE, if there are no additional messages
         remaining in the pipe, the pipe will be removed automatically.</para>
       </entry>
      </row>
      <row>
       <entry>Public pipe</entry>
       <entry>
        <para>- Can be created as an explicit pipe or implicit pipe.</para>
        <para>- Can also be used by users other than the creator.</para>
       </entry>
      </row>
      <row>
       <entry>Private pipe</entry>
       <entry>
        <para>- Can only be created as an explicit pipe.</para>
        <para>- Can only be used by its creator.</para>
       </entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    Note
   </emphasis></para>

   <itemizedlist>
    <listitem>
     <para>
      Up to 50 pipes can be used concurrently by a single instance.
     </para>
    </listitem>
    <listitem>
     <para>
      In cases where pipes are frequently created and removed repetitively, use public pipes.
      If you create a private pipe, internal information (the creator of the private pipe) will
      remain even after the pipe is removed. Thus, repeatedly creating and removing pipes may
      ultimately cause memory to run out.
     </para>
    </listitem>
    <listitem>
     <para>
      If a timeout occurs without receiving a message when an implicit pipe is created by
      RECEIVE_MESSAGE, the pipe will not be removed.
     </para>
    </listitem>
   </itemizedlist>

   <para><emphasis role="bold">
    Features
   </emphasis></para>

   <table>
    <title>DBMS_PIPE Features</title>
    <tgroup cols="2">
     <colspec colnum="1" colname="col1"/>
     <colspec colnum="2" colname="col2"/>
     <thead>
      <row>
       <entry>Feature</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>CREATE_PIPE</entry>
       <entry>Creates a public or private pipe.</entry>
      </row>
      <row>
       <entry>NEXT_ITEM_TYPE</entry>
       <entry>Determines the data type of the next item in the local buffer, and returns that
        type.</entry>
      </row>
      <row>
       <entry>PACK_MESSAGE</entry>
       <entry>Sets a message in the local buffer.</entry>
      </row>
      <row>
       <entry>PURGE</entry>
       <entry>Empties the contents of the specified pipe.</entry>
      </row>
      <row>
       <entry>RECEIVE_MESSAGE</entry>
       <entry>Sets a received message in the local buffer.</entry>
      </row>
      <row>
       <entry>REMOVE_PIPE</entry>
       <entry>Removes the specified pipe.</entry>
      </row>
      <row>
       <entry>RESET_BUFFER</entry>
       <entry>Resets the set position of the local buffer.</entry>
      </row>
      <row>
       <entry>SEND_MESSAGE</entry>
       <entry>Sends the contents of the local buffer.</entry>
      </row>
      <row>
       <entry>UNIQUE_SESSION_NAME</entry>
       <entry>Returns a unique session name.</entry>
      </row>
      <row>
       <entry>UNPACK_MESSAGE_BYTEA</entry>
       <entry>Receives a message in the local buffer in BYTEA type.</entry>
      </row>
      <row>
       <entry>UNPACK_MESSAGE_DATE</entry>
       <entry>Receives a message in the local buffer in DATE type.</entry>
      </row>
      <row>
       <entry>UNPACK_MESSAGE_NUMBER</entry>
       <entry>Receives a message in the local buffer in NUMERIC type.</entry>
      </row>
      <row>
       <entry>UNPACK_MESSAGE_RECORD</entry>
       <entry>Receives a message in the local buffer in RECORD type.</entry>
      </row>
      <row>
       <entry>UNPACK_MESSAGE_TEXT</entry>
       <entry>Receives a message in the local buffer in TEXT type.</entry>
      </row>
      <row>
       <entry>UNPACK_MESSAGE_TIMESTAMP</entry>
       <entry>Receives a message in the local buffer in TIMESTAMP type.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    Syntax
   </emphasis></para>

   <mediaobject>
    <imageobject>
     <imagedata fileref="images/DBMS_PIPE.svg" format="SVG" width="100%"/>
    </imageobject>
   </mediaobject>

   <sect4>
    <title>Description of Features</title>

    <para>
     This section explains each feature of DBMS_PIPE.
    </para>

    <para><emphasis role="bold">
     CREATE_PIPE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       CREATE_PIPE explicitly creates a pipe environment for data communication.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the name of the pipe to be created.
      </para>
     </listitem>
     <listitem>
      <para>
       Pipe names are case-sensitive.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the maximum number of messages that can be sent or received. If omitted, 0
       (cannot send messages) will be used. Specify from 1 to 32767.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify TRUE or FALSE for <emphasis role="italic">private</emphasis>. If TRUE is
       specified, a private pipe will be created. If FALSE is specified, a public pipe will be
       created. The default is FALSE.
      </para>
     </listitem>
     <listitem>
      <para>
       An error will occur if a pipe of the same name has already been created.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "The SQL Language" > "Data Types" > "Boolean Type" in the LightDB
     Documentation for information on boolean type (TRUE/FALSE) values.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM DBMS_PIPE.CREATE_PIPE('P01', 100, FALSE);
    </programlisting>

    <para><emphasis role="bold">
     NEXT_ITEM_TYPE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       NEXT_ITEM_TYPE returns the next data type in the local buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is INTEGER. One of the following values is returned:
      </para>
     </listitem>
    </itemizedlist>

    <table>
     <title>Values returned by NEXT_ITEM_TYPE</title>
     <tgroup cols="2">
      <colspec colnum="1" colname="col1"/>
      <colspec colnum="2" colname="col2"/>
      <thead>
       <row>
        <entry>Return value</entry>
        <entry>Data type</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>9</entry>
        <entry>NUMERIC type</entry>
       </row>
       <row>
        <entry>11</entry>
        <entry>TEXT type</entry>
       </row>
       <row>
        <entry>12</entry>
        <entry>DATE type</entry>
       </row>
       <row>
        <entry>13</entry>
        <entry>TIMESTAMP type</entry>
       </row>
       <row>
        <entry>23</entry>
        <entry>BYTEA type</entry>
       </row>
       <row>
        <entry>24</entry>
        <entry>RECORD type</entry>
       </row>
       <row>
        <entry>0</entry>
        <entry>No data in the buffer</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para><emphasis role="bold">Example</emphasis></para>
    <programlisting>
     DECLARE
         i_iType    INTEGER;
     BEGIN
         i_iType := DBMS_PIPE.NEXT_ITEM_TYPE();
    </programlisting>

    <para><emphasis role="bold">
     PACK_MESSAGE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       PACK_MESSAGE sets the specified message in the local buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the data to be set in the local buffer. The following data types can be used:
      </para>
      <itemizedlist>
       <listitem>
        <para>Character type (*1)</para>
       </listitem>
       <listitem>
        <para>Integer type (*2)</para>
       </listitem>
       <listitem>
        <para>NUMERIC type</para>
       </listitem>
       <listitem>
        <para>DATE type</para>
       </listitem>
       <listitem>
        <para>TIMESTAMP type (*3)</para>
       </listitem>
       <listitem>
        <para>BYTEA type</para>
       </listitem>
       <listitem>
        <para>RECORD type</para>
       </listitem>
      </itemizedlist>
     </listitem>
    </itemizedlist>

    <para>
     *1: The character type is converted internally to TEXT type.
    </para>

    <para>
     *2: The integer type is converted internally to NUMERIC type.
    </para>

    <para>
     *3: The TIMESTAMP type is converted internally to TIMESTAMP WITH TIME ZONE type.
    </para>

    <itemizedlist>
     <listitem>
      <para>
       Each time PACK_MESSAGE is called, a new message is added to the local buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       The size of the local buffer is approximately 8 KB. However, each message has overhead,
       so the total size that can be stored is actually less than 8 KB. To clear the local buffer,
       send a message (SEND_MESSAGE), or reset the buffer (RESET_BUFFER) to its initial state.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM DBMS_PIPE.PACK_MESSAGE('Message Test001');
    </programlisting>

    <para><emphasis role="bold">
     PURGE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       PURGE removes the messages in the pipe.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the name of the pipe for which the messages are to be removed.
      </para>
     </listitem>
     <listitem>
      <para>
       Pipe names are case-sensitive.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM DBMS_PIPE.PURGE('P01');
    </programlisting>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     When PURGE is executed, the local buffer is used to remove the messages in the pipe.
     Therefore, if there are any messages remaining in the pipe, the local buffer will be
     overwritten by PURGE.
    </para>

    <para><emphasis role="bold">
     RECEIVE_MESSAGE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       RECEIVE_MESSAGE receives messages that exist in the specified pipe, and sets those
       messages in the local buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       Messages are received in the units in which they are sent to the pipe by SEND_MESSAGE.
       Received messages are removed from the pipe after being set in the local buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the name of the pipe for which the messages are to be received.
      </para>
     </listitem>
     <listitem>
      <para>
       Pipe names are case-sensitive.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the maximum wait time <emphasis role="italic">timeout</emphasis> in seconds to
       wait for a message. If omitted, the default is 31536000 seconds (1 year).
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is INTEGER. If a message is received successfully, 0
       is returned. If a timeout occurs, 1 is returned.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         i_Ret    INTEGER;
     BEGIN
         i_Ret := DBMS_PIPE.RECEIVE_MESSAGE('P01', 60);
    </programlisting>

    <para><emphasis role="bold">
     REMOVE_PIPE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       REMOVE_PIPE removes the specified pipe.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the name of the pipe to be removed.
      </para>
     </listitem>
     <listitem>
      <para>
       Pipe names are case-sensitive.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM DBMS_PIPE.REMOVE_PIPE('P01');
    </programlisting>

    <para><emphasis role="bold">
     RESET_BUFFER
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       RESET_BUFFER resets the set position of the local buffer. Any unnecessary data remaining
       in the local buffer can be discarded using this operation.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM DBMS_PIPE.RESET_BUFFER();
    </programlisting>

    <para><emphasis role="bold">
     SEND_MESSAGE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       SEND_MESSAGE sends data stored in the local buffer to the specified pipe.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the name of the pipe that the data is to be sent to.
      </para>
     </listitem>
     <listitem>
      <para>
       Pipe names are case-sensitive.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the maximum wait time <emphasis role="italic">timeout</emphasis> in seconds for
       sending data stored in the local buffer. If omitted, the default is 31536000 seconds (1 year).
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the maximum number of messages that can be sent or received. If omitted, the
       maximum number of messages set in CREATE_PIPE is used. If omitted in the implicit pipe, the
       number of messages will be unlimited. Specify from 1 to 32767.
      </para>
     </listitem>
     <listitem>
      <para>
       If the maximum number of messages is specified in both SEND_MESSAGE and CREATE_PIPE, the
       larger of the values will be used.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is INTEGER. If a message is received successfully, 0
       is returned. If a timeout occurs, 1 is returned.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         i_Ret    INTEGER;
     BEGIN
         i_Ret := DBMS_PIPE.SEND_MESSAGE('P01', 10, 20);
    </programlisting>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     A timeout will occur during sending if the maximum number of messages is reached, or if
     the message being sent is too large. If a timeout occurs, use RECEIVE_MESSAGE to receive any
     messages that are in the pipe.
    </para>

    <para><emphasis role="bold">
     UNIQUE_SESSION_NAME
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       UNIQUE_SESSION_NAME returns a name that is unique among all the sessions. This name can
       be used as the pipe name.
      </para>
     </listitem>
     <listitem>
      <para>
       Multiple calls from the same session always return the same name.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is VARCHAR. Returns a string of up to 30 characters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         p_Name   VARCHAR(30);
     BEGIN
         p_Name := DBMS_PIPE.UNIQUE_SESSION_NAME();
    </programlisting>

    <para><emphasis role="bold">
     UNPACK_MESSAGE_BYTEA
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       NPACK_MESSAGE_BYTEA receives BTYEA type messages in the local buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       Messages are received in the unit set in the local buffer by PACK_MESSAGE. Received
       messages are removed from the local buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is BYTEA.
      </para>
     </listitem>
     <listitem>
      <para>
       If no messages exist in the local buffer, a NULL value is returned.
      </para>
     </listitem>
     <listitem>
      <para>
       For the data type, it is necessary to align with the data type set by PACK_MESSAGE. If
       the data type is different, the following error will occur.
      </para>
     </listitem>
    </itemizedlist>

    <programlisting>
     ERROR:  datatype mismatch
     DETAIL:  unpack unexpected type: xx
    </programlisting>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         g_Bytea   BYTEA;
     BEGIN
         g_Bytea := DBMS_PIPE.UNPACK_MESSAGE_BYTEA();
    </programlisting>

    <para><emphasis role="bold">
     UNPACK_MESSAGE_DATE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       UNPACK_MESSAGE_DATE receives DATE type messages in the local buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       Messages are received in the unit set in the local buffer by PACK_MESSAGE. Received
       messages are removed from the local buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is DATE.
      </para>
     </listitem>
     <listitem>
      <para>
       If no messages exist in the local buffer, a NULL value is returned.
      </para>
     </listitem>
     <listitem>
      <para>
       For the data type, it is necessary to align with the data type set by PACK_MESSAGE. If
       the data type is different, the following error will occur.
      </para>
     </listitem>
    </itemizedlist>

    <programlisting>
     ERROR:  datatype mismatch
     DETAIL:  unpack unexpected type: xx
    </programlisting>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         g_Date   DATE;
     BEGIN
         g_Date := DBMS_PIPE.UNPACK_MESSAGE_DATE();
    </programlisting>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     If the "oracle" schema is set in search_path, the DATE type of orafce will be used, so for
     receiving data, use UNPACK_MESSAGE_TIMESTAMP. UNPACK_MESSAGE_DATE is the interface for the DATE
     type of LightDB.
    </para>

    <para><emphasis role="bold">
     UNPACK_MESSAGE_NUMBER
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       UNPACK_MESSAGE_NUMBER receives NUMERIC type messages in the local buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       Messages are received in the unit set in the local buffer by PACK_MESSAGE. Received
       messages are removed from the local buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is NUMERIC.
      </para>
     </listitem>
     <listitem>
      <para>
       If no messages exist in the local buffer, a NULL value is returned.
      </para>
     </listitem>
     <listitem>
      <para>
       For the data type, it is necessary to align with the data type set by PACK_MESSAGE. If
       the data type is different, the following error will occur.
      </para>
     </listitem>
    </itemizedlist>

    <programlisting>
     ERROR:  datatype mismatch
     DETAIL:  unpack unexpected type: xx
    </programlisting>

    <para><emphasis role="bold">Example</emphasis></para>

    <programlisting>
     DECLARE
         g_Number   NUMERIC;
     BEGIN
         g_Number := DBMS_PIPE.UNPACK_MESSAGE_NUMBER();
    </programlisting>

    <para><emphasis role="bold">
     UNPACK_MESSAGE_RECORD
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       UNPACK_MESSAGE_RECORD receives RECORD type messages in the local buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       Messages are received in the unit set in the local buffer by PACK_MESSAGE. Received
       messages are removed from the local buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is RECORD.
      </para>
     </listitem>
     <listitem>
      <para>
       If no messages exist in the local buffer, a NULL value is returned.
      </para>
     </listitem>
     <listitem>
      <para>
       For the data type, it is necessary to align with the data type set by PACK_MESSAGE. If
       the data type is different, the following error will occur.
      </para>
     </listitem>
    </itemizedlist>

    <programlisting>
     ERROR:  datatype mismatch
     DETAIL:  unpack unexpected type: xx
    </programlisting>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         msg1     TEXT;
         status   NUMERIC;
     BEGIN
         SELECT col1, col2 INTO msg1, status FROM DBMS_PIPE.UNPACK_MESSAGE_RECORD();
    </programlisting>

    <para><emphasis role="bold">
     UNPACK_MESSAGE_TEXT
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       UNPACK_MESSAGE_TEXT receives TEXT type messages in the local buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       Messages are received in the unit set in the local buffer by PACK_MESSAGE. Received
       messages are removed from the local buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is TEXT.
      </para>
     </listitem>
     <listitem>
      <para>
       If no messages exist in the local buffer, a NULL value is returned.
      </para>
     </listitem>
     <listitem>
      <para>
       For the data type, it is necessary to align with the data type set by PACK_MESSAGE. If
       the data type is different, the following error will occur.
      </para>
     </listitem>
    </itemizedlist>

    <programlisting>
     ERROR:  datatype mismatch
     DETAIL:  unpack unexpected type: xx
    </programlisting>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         g_Text   TEXT;
     BEGIN
         g_Text := DBMS_PIPE.UNPACK_MESSAGE_TEXT();
    </programlisting>

    <para><emphasis role="bold">
     UNPACK_MESSAGE_TIMESTAMP
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       UNPACK_MESSAGE_TIMESTAMP receives TIMESTAMP WITH TIME ZONE type messages in the local buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       Messages are received in the unit set in the local buffer by PACK_MESSAGE. Received
       messages are removed from the local buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is TIMESTAMP WITH TIME ZONE.
      </para>
     </listitem>
     <listitem>
      <para>
       If no messages exist in the local buffer, a NULL value is returned.
      </para>
     </listitem>
     <listitem>
      <para>
       For the data type, it is necessary to align with the data type set by PACK_MESSAGE. If
       the data type is different, the following error will occur.
      </para>
     </listitem>
    </itemizedlist>

    <programlisting>
     ERROR:  datatype mismatch
     DETAIL:  unpack unexpected type: xx
    </programlisting>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         g_Timestamptz   TIMESTAMP WITH TIME ZONE;
     BEGIN
         g_Timestamptz := DBMS_PIPE.UNPACK_MESSAGE_TIMESTAMP();
    </programlisting>
   </sect4>

   <sect4>
    <title>Usage Example</title>

    <para>
     Below is a usage example of the processing flow of DBMS_PIPE.
    </para>

    <para><emphasis role="bold">
     Flow of DBMS_PIPE
    </emphasis></para>

    <mediaobject>
     <imageobject>
      <imagedata fileref="images/DBMS_PIPE_flow.svg" format="SVG" width="100%"/>
     </imageobject>
    </mediaobject>

    <para><emphasis role="bold">Note</emphasis></para>
    <itemizedlist>
     <listitem>
      <para>
       When CREATE_PIPE is used to explicitly create a pipe, ensure to use REMOVE_PIPE to
       remove the pipe. If a pipe is not removed explicitly, once created, it will remain until the
       instance is stopped.
      </para>
     </listitem>
     <listitem>
      <para>
       In the flow diagram, CREATE_PIPE and REMOVE_PIPE are described on the receiving side,
       however, these can be executed on the sending side. In order to maintain consistency, it is
       recommended to create and remove pipes on one side.
      </para>
     </listitem>
     <listitem>
      <para>
       An error will occur for CREATE_PIPE if a pipe of the same name already exists.
       Implicitly created pipes are also the target of SEND_MESSAGE and RECEIVE_MESSAGE, so when
       executing CREATE_PIPE, ensure that SEND_MESSAGE and RECEIVE_MESSAGE are not called beforehand.
      </para>
     </listitem>
     <listitem>
      <para>
       DBMS_ALERT and DBMS_PIPE use the same memory environment. Therefore, when insufficient
       memory is detected for DBMS_ALERT, it is possible that insufficient memory will also be
       detected for DBMS_PIPE.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Information
    </emphasis></para>

    <para>
     The information of pipes that are in use can be viewed in the DBMS_PIPE.DB_PIPES view.
    </para>

    <programlisting>
     SELECT * from dbms_pipe.db_pipes;
      name | items | size | limit | private | owner
     ------+-------+------+-------+---------+-------
      P01  |     1 |   18 |   100 | f       |
     (1 row)
    </programlisting>

    <para><emphasis role="bold">
     Usage example
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Sending side
      </para>
     </listitem>
    </itemizedlist>

    <programlisting>
     CREATE FUNCTION send_dbms_pipe_exe(IN pipe_mess text) RETURNS void AS $$
     DECLARE
     	pipe_name text := 'sample_pipe';
    	 pipe_time timestamp := current_timestamp;
     	pipe_stat int;
     BEGIN
     	PERFORM DBMS_PIPE.RESET_BUFFER();
     	PERFORM DBMS_PIPE.PACK_MESSAGE(pipe_mess);
     	PERFORM DBMS_PIPE.PACK_MESSAGE(pipe_time);
     	pipe_stat := DBMS_PIPE.SEND_MESSAGE(pipe_name);
     	RAISE NOTICE 'PIPE_NAME: % SEND Return Value =%', pipe_name, pipe_stat;
     END;
     $$ LANGUAGE plpgsql;

     SELECT send_dbms_pipe_exe('Sample Message.');
     DROP FUNCTION send_dbms_pipe_exe(text);
    </programlisting>

    <itemizedlist>
     <listitem>
      <para>
       Receiving side
      </para>
     </listitem>
    </itemizedlist>

    <programlisting>
     CREATE FUNCTION receive_dbms_pipe_exe() RETURNS void AS $$
     DECLARE
     	pipe_name text := 'sample_pipe';
     	pipe_text text;
     	pipe_nume numeric;
     	pipe_date date;
     	pipe_time timestamp with time zone;
     	pipe_byte bytea;
     	pipe_reco record;
     	pipe_item int;
     	pipe_stat int;
     BEGIN
     	pipe_stat := DBMS_PIPE.RECEIVE_MESSAGE(pipe_name,300);
     	RAISE NOTICE 'Return Value = %', pipe_stat;
         LOOP
     		pipe_item := DBMS_PIPE.NEXT_ITEM_TYPE();
     		RAISE NOTICE 'Next Item : %', pipe_item;
     		IF (pipe_item = 9) THEN
     		    pipe_nume := DBMS_PIPE.UNPACK_MESSAGE_NUMBER();
     		    RAISE NOTICE 'Get Message : %' ,pipe_nume;
     		ELSIF (pipe_item =11) THEN
     		    pipe_text := DBMS_PIPE.UNPACK_MESSAGE_TEXT();
     		    RAISE NOTICE 'Get Message : %' ,pipe_text;
     		ELSIF (pipe_item = 12) THEN
     		    pipe_date := DBMS_PIPE.UNPACK_MESSAGE_DATE();
     		    RAISE NOTICE 'Get Message : %' ,pipe_date;
     		ELSIF (pipe_item = 13) THEN
    		     pipe_time := DBMS_PIPE.UNPACK_MESSAGE_TIMESTAMP();
     		    RAISE NOTICE 'Get Message : %' ,pipe_time;
     		ELSIF (pipe_item = 23) THEN
     		    pipe_byte := DBMS_PIPE.UNPACK_MESSAGE_BYTEA();
     		    RAISE NOTICE 'Get Message : %' ,pipe_byte;
     		ELSIF (pipe_item = 24) THEN
     		    pipe_reco := DBMS_PIPE.UNPACK_MESSAGE_RECORD();
     		    RAISE NOTICE 'Get Message : %' ,pipe_reco;
     		ELSE
     		    EXIT;
     		END IF;
         END LOOP;
         PERFORM DBMS_PIPE.REMOVE_PIPE(pipe_name);
     END;
     $$ LANGUAGE plpgsql;

     SELECT receive_dbms_pipe_exe();
     DROP FUNCTION receive_dbms_pipe_exe();
    </programlisting>
   </sect4>
  </sect3>

  <sect3>
   <title>DBMS_RANDOM</title>

   <para><emphasis role="bold">
    Overview
   </emphasis></para>

   <para>
    Generates random numbers in PL/pgSQL.
   </para>

   <table>
    <title>DBMS_RANDOM Features</title>
    <tgroup cols="2">
     <colspec colnum="1" colname="col1"/>
     <colspec colnum="2" colname="col2"/>
     <thead>
      <row>
       <entry>Feature</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>INITIALIZE</entry>
       <entry>Initializes the generation of random numbers.</entry>
      </row>
      <row>
       <entry>NORMAL</entry>
       <entry>Returns a normally distributed random number.</entry>
      </row>
      <row>
       <entry>RANDOM</entry>
       <entry>Generates a random number.</entry>
      </row>
      <row>
       <entry>SEED</entry>
       <entry>Resets the seed value.</entry>
      </row>
      <row>
       <entry>STRING</entry>
       <entry>Generates a random string.</entry>
      </row>
      <row>
       <entry>TERMINATE</entry>
       <entry>Terminates generation of random numbers.</entry>
      </row>
      <row>
       <entry>VALUE</entry>
       <entry>Generates a random decimal number between 0 and 1, or between specified
        values.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    Syntax
   </emphasis></para>

   <mediaobject>
    <imageobject>
     <imagedata fileref="images/DBMS_RANDOM.svg" format="SVG" width="100%"/>
    </imageobject>
   </mediaobject>

   <sect4>
    <title>Description of Features</title>

    <para>
     This section explains each feature of DBMS_RANDOM.
    </para>

    <para><emphasis role="bold">
     INITIALIZE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       INITIALIZE initializes the generation of random numbers using the specified seed value.
      </para>
     </listitem>
     <listitem>
      <para>
       For <emphasis role="italic">seedVal</emphasis>, specify a SMALLINT or INTEGER type.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM DBMS_RANDOM.INITIALIZE(999);
    </programlisting>

    <para><emphasis role="bold">
     NORMAL
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       NORMAL generates and returns a normally distributed random number.
      </para>
     </listitem>
     <listitem>
      <para>
       The return value type is DOUBLE PRECISION.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         d_RunNum   DOUBLE PRECISION;
     BEGIN
         d_RunNum := DBMS_RANDOM.NORMAL();
    </programlisting>

    <para><emphasis role="bold">
     RANDOM
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>RANDOM generates and returns a random number.</para>
     </listitem>
     <listitem>
      <para>The data type of the return value is INTEGER.</para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         d_RunInt   INTEGER;
     BEGIN
         d_RunInt := DBMS_RANDOM.RANDOM();
    </programlisting>

    <para><emphasis role="bold">
     SEED
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       SEED initializes the generation of a random number using the specified seed value or seed string.
      </para>
     </listitem>
     <listitem>
      <para>
       For <emphasis role="italic">seedVal</emphasis>, specify a SMALLINT or INTEGER type.
      </para>
     </listitem>
     <listitem>
      <para>
       Any string can be specified for the seed string.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM DBMS_RANDOM.SEED('123');
    </programlisting>

    <para><emphasis role="bold">
     STRING
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       STRING generates and returns a random string in accordance with the specified display
       format and string length.
      </para>
     </listitem>
     <listitem>
      <para>
       For the display format <emphasis role="italic">fmt</emphasis>, specify any of the
       following values. An error will occur if any other value is specified.
      </para>
     </listitem>
    </itemizedlist>

    <table>
     <title>Values that can be specified for the display format</title>
     <tgroup cols="2">
      <colspec colnum="1" colname="col1"/>
      <colspec colnum="2" colname="col2"/>
      <thead>
       <row>
        <entry>Setting value</entry>
        <entry>Generated string</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>'u', 'U'</entry>
        <entry>Uppercase letters only</entry>
       </row>
       <row>
        <entry>'l', 'L'</entry>
        <entry>Lowercase letters only</entry>
       </row>
       <row>
        <entry>'a', 'A'</entry>
        <entry>Mixture of uppercase and lowercase letters</entry>
       </row>
       <row>
        <entry>'x', 'X'</entry>
        <entry>Uppercase letters and numbers</entry>
       </row>
       <row>
        <entry>'p', 'P'</entry>
        <entry>Any displayable character</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <itemizedlist>
     <listitem>
      <para>
       Specify the length of the string to be generated. Specify a SMALLINT or INTEGER type.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is TEXT.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         d_RunStr   TEXT;
     BEGIN
         d_RunStr := DBMS_RANDOM.STRING('a', 20);
    </programlisting>

    <para><emphasis role="bold">
     TERMINATE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Call TERMINATE to terminate generation of random numbers.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Information
    </emphasis></para>

    <para>
     TERMINATE does not do anything, but has been included for compatibility with Oracle databases.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM DBMS_RANDOM.TERMINATE();
    </programlisting>

    <para><emphasis role="bold">
     VALUE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       VALUE generates and returns a random number within the specified range.
      </para>
     </listitem>
     <listitem>
      <para>
       For <emphasis role="italic">min</emphasis> and <emphasis role="italic">max</emphasis>,
       specify a numeric data type. A random number between and inclusive of the minimum value and
       maximum value is generated.
      </para>
     </listitem>
     <listitem>
      <para>
       If the minimum value and maximum value are omitted, a random decimal number between 0
       and 1 will be generated.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is DOUBLE PRECISION.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         d_RunDbl   DOUBLE PRECISION;
     BEGIN
         d_RunDbl := DBMS_RANDOM.VALUE();
    </programlisting>
   </sect4>

   <sect4>
    <title>Usage Example</title>

    <para>
     A usage example of DBMS_RANDOM is shown below.
    </para>

    <programlisting>
     CREATE FUNCTION dbms_random_exe() RETURNS VOID AS $$
     DECLARE
         w_rkey VARCHAR(10) := 'rnd111';
         i_rkey INTEGER := 97310;
     BEGIN
         PERFORM DBMS_RANDOM.INITIALIZE(i_rkey);
         RAISE NOTICE 'RANDOM -> NORMAL : %', DBMS_RANDOM.NORMAL();
         RAISE NOTICE 'RANDOM -> RANDOM : %', DBMS_RANDOM.RANDOM();
         RAISE NOTICE 'RANDOM -> STRING : %', DBMS_RANDOM.STRING('a',10);
         RAISE NOTICE 'RANDOM -> VALUE  : %', DBMS_RANDOM.VALUE();
         PERFORM DBMS_RANDOM.SEED(w_rkey);
         RAISE NOTICE 'RANDOM -> NORMAL : %', DBMS_RANDOM.NORMAL();
         RAISE NOTICE 'RANDOM -> RANDOM : %', DBMS_RANDOM.RANDOM();
         RAISE NOTICE 'RANDOM -> STRING : %', DBMS_RANDOM.STRING('p',10);
         RAISE NOTICE 'RANDOM -> VALUE  : %', DBMS_RANDOM.VALUE(1,100);
         PERFORM DBMS_RANDOM.TERMINATE();
     END;
     $$ LANGUAGE plpgsql;
     SELECT dbms_random_exe();
     DROP FUNCTION dbms_random_exe();
    </programlisting>
   </sect4>
  </sect3>

  <sect3>
   <title>DBMS_UTILITY</title>

   <para><emphasis role="bold">
    Overview
   </emphasis></para>

   <para>
    Provides utilities of PL/pgSQL.
   </para>

   <table>
    <title>DBMS_UTILITY Features</title>
    <tgroup cols="2">
     <colspec colnum="1" colname="col1"/>
     <colspec colnum="2" colname="col2"/>
     <thead>
      <row>
       <entry>Feature</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>FORMAT_CALL_STACK</entry>
       <entry>Returns the current call stack.</entry>
      </row>
      <row>
       <entry>GET_HASH_VALUE</entry>
       <entry>A hash value based on the input string.</entry>
      </row>
      <row>
       <entry>CANONICALIZE</entry>
       <entry>Canonicalizes a given string.</entry>
      </row>
      <row>
       <entry>COMMA_TO_TABLE</entry>
       <entry>Converts a comma-delimited list of names into a PL/SQL table of names.</entry>
      </row>
      <row>
       <entry>TABLE_TO_COMMA</entry>
       <entry>Converts a PL/SQL table of names into a comma-delimited list of names.</entry>
      </row>
      <row>
       <entry>DB_VERSION</entry>
       <entry>Returns version information for the database.</entry>
      </row>
      <row>
       <entry>EXEC_DDL_STATEMENT</entry>
       <entry>Executes the DDL statement in parse_string.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    Syntax
   </emphasis></para>

   <programlisting>
     FORMAT_CALL_STACK(fmt text);
     FORMAT_CALL_STACK();
     GET_HASH_VALUE(name VARCHAR2,base INTEGER,hash_size INTEGER)
     CANONICALIZE(name TEXT,canon_name TEXT,canon_len INT4)
     COMMA_TO_TABLE(list TEXT,tablen INT4,tab TEXT[])
     TABLE_TO_COMMA(tab TEXT[],tablen INT4,list TEXT)
     DB_VERSION(version TEXT,compatibility TEXT)
     EXEC_DDL_STATEMENT(parse_string TEXT)
   </programlisting>

   <sect4>
    <title>Description of Features</title>

    <para>
     This section explains each feature of DBMS_UTILITY.
    </para>

    <para><emphasis role="bold">
     FORMAT_CALL_STACK
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       FORMAT_CALL_STACK returns the current call stack of PL/pgSQL.
      </para>
     </listitem>
     <listitem>
      <para>
       For the display format fmt, specify any of the following values. An error will occur if
       any other value is specified.
      </para>
     </listitem>
    </itemizedlist>

    <table>
     <title>Values that can be specified for the display format</title>
     <tgroup cols="2">
      <colspec colnum="1" colname="col1"/>
      <colspec colnum="2" colname="col2"/>
      <thead>
       <row>
        <entry>Setting value</entry>
        <entry>Displayed content</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>'o'</entry>
        <entry>Standard-format call stack display (with header)</entry>
       </row>
       <row>
        <entry>'s'</entry>
        <entry>Standard-format call stack display (without header)</entry>
       </row>
       <row>
        <entry>'p'</entry>
        <entry>Comma-delimited call stack display (without header)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <itemizedlist>
     <listitem>
      <para>
       If the display format is omitted, display format 'o' will be used.
      </para>
     </listitem>
     <listitem>
      <para>
       The data type of the return value is TEXT.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     DECLARE
         s_StackTrace   TEXT
     BEGIN
         s_StackTrace := DBMS_UTILITY.FORMAT_CALL_STACK();
    </programlisting>

    <para><emphasis role="bold">
     Note
    </emphasis></para>

    <para>
     If a locale other than English is specified for the message locale, the call stack result
     may not be retrieved correctly. To correctly retrieve the call stack result, specify English as
     the message locale.
    </para>
    <para><emphasis role="bold">
     GET_HASH_VALUE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       A hash value based on the input string where the hash value should be between base and base + hash_size -1.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM DBMS_UTILITY.GET_HASH_VALUE('abcdef',0,10000);
    </programlisting>


    <para><emphasis role="bold">
     CANONICALIZE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       The procedure handles a single reserved or key word (such as 'table'), and strips off white spaces for a single identifier so that ' table ' becomes TABLE.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
declare
    l_result        text := '';
begin
    dbms_output.serveroutput(True);
    dbms_utility.canonicalize('taBle', l_result, 100);
    dbms_output.put_line(l_result);
end;
/
    </programlisting>

    <para><emphasis role="bold">
     COMMA_TO_TABLE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       These procedures converts a comma-delimited list of names into a PL/SQL table of names.
      </para>
     </listitem>
     <listitem>
      <para>
       The list must be a non-empty comma-delimited list: Anything other than a comma-delimited list is rejected. Commas inside double quotes do not count.
      </para>
     </listitem>    
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
declare
    tablen          int4;
    tab             text[];
begin
    dbms_output.serveroutput(True);
    dbms_utility.comma_to_table('table, "Table","Table,122324" , Tablesd', tablen, tab);
    dbms_output.put_line(tablen);
    dbms_output.put_line(array_to_string(tab,','));
end;
/
    </programlisting>

    <para><emphasis role="bold">
     TABLE_TO_COMMA
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This procedure converts a PL/SQL table of names into a comma-delimited list of names.
      </para>
     </listitem>  
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
declare
    tablen          int4;
    l_str             text;
begin
    dbms_output.serveroutput(True);

    dbms_utility.table_to_comma('{table," \"table\"","\"table.1234567890\" "," tablezx",NULL}'::text[], tablen, l_str);
    dbms_output.put_line(tablen);
    dbms_output.put_line(l_str);

end;
/
    </programlisting>

    <para><emphasis role="bold">
     DB_VERSION
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This procedure returns version information for the database.
      </para>
     </listitem>  
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
declare
    lt_version        text;
    compatibility     text;
begin
    dbms_output.serveroutput(True);
    dbms_utility.db_version(lt_version, compatibility);
    dbms_output.put_line(lt_version);
    dbms_output.put_line(oracle.nvl(compatibility,'NULL'));
end;
/
    </programlisting>

    <para><emphasis role="bold">
    EXEC_DDL_STATEMENT
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       his procedure executes the DDL statement in parse_string.
      </para>
     </listitem>  
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
declare
    l_result        text := '';
begin
    dbms_output.serveroutput(True);
    dbms_utility.exec_ddl_statement('create table if not exists public.test_exec_ddl_stmt (id int, name text);');
end;
/
    </programlisting>    
   </sect4>

   <sect4>
    <title>Usage Example</title>

    <para>
     A usage example of DBMS_UTILITY is shown below.
    </para>

    <programlisting>
CREATE FUNCTION dbms_utility1_exe() RETURNS VOID AS $$
DECLARE
    s_StackTrace TEXT;
    v_hashvalue  numeric(38,0);
BEGIN
    s_StackTrace := DBMS_UTILITY.FORMAT_CALL_STACK();
    RAISE NOTICE '%', s_StackTrace;
    v_hashvalue := DBMS_UTILITY.GET_HASH_VALUE('abcdef',0,10000);
    RAISE NOTICE 'v_hashvalue=%', v_hashvalue;
END;
$$ LANGUAGE plpgsql;

CREATE FUNCTION dbms_utility2_exe() RETURNS VOID AS $$
BEGIN
    PERFORM dbms_utility1_exe();
END;
$$ LANGUAGE plpgsql;

SELECT dbms_utility2_exe();
DROP FUNCTION dbms_utility2_exe();
DROP FUNCTION dbms_utility1_exe();

declare
    l_result        text := '';
begin
    dbms_output.serveroutput(True);
    dbms_utility.exec_ddl_statement('create table if not exists public.test_exec_ddl_stmt (id int, name text);');
    l_result := dbms_metadata.get_ddl('table', 'test_exec_ddl_stmt');
    dbms_output.put_line(l_result);
    dbms_utility.exec_ddl_statement(' truncate table public.test_exec_ddl_stmt');
    dbms_output.put_line('truncate SUCCESS');
    dbms_utility.exec_ddl_statement('drop table if exists public.test_exec_ddl_stmt ; ');
    dbms_output.put_line('drop SUCCESS');
end;
/
    </programlisting>
   </sect4>
  </sect3>

  <sect3>
   <title>DBMS_JOB</title>

   <para><emphasis role="bold">
    Overview
   </emphasis></para>

   <para>
    Schedules and manages jobs in the lt_cron.
   </para>

   <table>
    <title>DBMS_JOB Features</title>
    <tgroup cols="2">
     <colspec colnum="1" colname="col1"/>
     <colspec colnum="2" colname="col2"/>
     <thead>
      <row>
       <entry>Feature</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>BROKEN</entry>
       <entry>Disables job execution.(invalid)</entry>
      </row>
      <row>
       <entry>CHANGE</entry>
       <entry>Alters any of the user-definable parameters associated with a job.</entry>
      </row>
      <row>
       <entry>INSTANCE</entry>
       <entry>Assigns a job to be run by a instance.(invalid)</entry>
      </row>
      <row>
       <entry>INTERVAL</entry>
       <entry>Alters the interval between executions for a specified job.</entry>
      </row>
      <row>
       <entry>NEXT_DATE</entry>
       <entry>Alters the next execution time for a specified job.(invalid)</entry>
      </row>
      <row>
       <entry>REMOVE</entry>
       <entry>Removes specified job from the job queue.</entry>
      </row>
      <row>
       <entry>RUN</entry>
       <entry>Forces a specified job to run.(invalid)</entry>
      </row>
      <row>
       <entry>SUBMIT</entry>
       <entry>Submits a new job to the job queue.</entry>
      </row>
      <row>
       <entry>USER_EXPORT</entry>
       <entry>Re-creates a given job for export.</entry>
      </row>
      <row>
       <entry>WHAT</entry>
       <entry>Alters the job description for a specified job.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    Syntax
   </emphasis></para>

   <programlisting>
     CHANGE(job INT8,what TEXT,next_date TIMESTAMP,interval TEXT,instance INT4 default null,force BOOL default 'false')
     INTERVAL(job INT8,interval TEXT)
     REMOVE(job INT8)
     SUBMIT(job INT8,what TEXT,next_date TIMESTAMP default sysdate,interval TEXT default 'null',no_parse BOOL default 'false',instance INT4 default null,force BOOL default 'false')
     USER_EXPORT(job INT8,mycall TEXT)
     WHAT(job INT8,what TEXT)
   </programlisting>

   <sect4>
    <title>Description of Features</title>

    <para>
     This section explains each feature of dbms_job.
    </para>

    <para><emphasis role="bold">
     CHANGE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This procedure changes any of the fields a user can set in a job.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
dbms_job.change(l_job_id, 'select 3', sysdate, '0 11 * * *');
    </programlisting>

    <para><emphasis role="bold">
     INTERVAL
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This procedure changes how often a job runs.
      </para>
     </listitem>
     <listitem>
      <para>
       he interval parameter format is lt_cron's format.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
dbms_job.interval(l_job_id, '0 11 * * *');
    </programlisting>

    <para><emphasis role="bold">
     REMOVE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This procedure removes an existing job from the job queue. 
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
dbms_job.remove(2);
    </programlisting>

    <para><emphasis role="bold">
     SUBMIT
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This procedure submits a new job. 
      </para>
     </listitem>
     <listitem>
      <para>
       The job submited by this procedure will not have name.
       It's suggested to submit by 'select cron.Schedule(name,xxx)'.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
dbms_job.submit(l_job_id, 'select 1',sysdate, '0 10 * * *');
    </programlisting>

    <para><emphasis role="bold">
     USER_EXPORT
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Produces the text of a call to re-create the given job.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
dbms_job.user_export(2, l_result);
    </programlisting>

    <para><emphasis role="bold">
     WHAT
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>This procedure changes what an existing job does.</para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     dbms_job.what(2, 'select 2');
    </programlisting>
   </sect4>
   <sect4>
    <title>Usage Example</title>

    <para>
     A usage example of DBMS_JOB is shown below.
    </para>

    <programlisting>
declare
    l_job_id   int8;
    l_result        text := '';
begin
    dbms_output.serveroutput(true);

    -- use dbms_job.submit will not have jobname  
    dbms_job.submit(l_job_id, 'select 1',sysdate, '0 10 * * *');
    dbms_output.put_line('submit job, job id:'||l_job_id);

    dbms_job.user_export(l_job_id, l_result);
    dbms_output.put_line('user_export(job id'||l_job_id||'):'||l_result);

    -- update can't be used for job without name
    dbms_job.what(l_job_id, 'select 2');
    dbms_job.user_export(l_job_id, l_result);
    dbms_output.put_line('after dbms_job.what user_export(job id:'||l_job_id||'):'||l_result);

    dbms_job.interval(l_job_id, '0 11 * * *');
    dbms_job.user_export(l_job_id, l_result);
    dbms_output.put_line('after dbms_job.interval user_export(job id:'||l_job_id||'):'||l_result);

    dbms_job.change(l_job_id, 'select 3', sysdate, '0 11 * * *');
    dbms_job.user_export(l_job_id, l_result);
    dbms_output.put_line('after dbms_job.change user_export(job id:'||l_job_id||'):'||l_result);


    dbms_job.next_date(l_job_id, sysdate);
    dbms_job.broken(l_job_id, True);
    dbms_job.instance(l_job_id, 10);
    dbms_job.run(l_job_id);

    dbms_job.remove(l_job_id);

end;
/
    </programlisting>
   </sect4>
  </sect3>

  <sect3>
   <title>DBMS_LOCK</title>

   <para><emphasis role="bold">
    Overview
   </emphasis></para>

   <para>
    Provides an interface to Lock Management services.
   </para>

   <table>
    <title>DBMS_LOCK Features</title>
    <tgroup cols="2">
     <colspec colnum="1" colname="col1"/>
     <colspec colnum="2" colname="col2"/>
     <thead>
      <row>
       <entry>Feature</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>sleep</entry>
       <entry>Puts a session to sleep for a specific time.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    Syntax
   </emphasis></para>

   <programlisting>
     SLEEP(pi_seconds FLOAT8)
   </programlisting>

   <sect4>
    <title>Description of Features</title>

    <para>
     This section explains each feature of dbms_job.
    </para>

    <para><emphasis role="bold">
     SLEEP
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This procedure suspends the session for a specified period of time.
      </para>
     </listitem>
     <listitem>
       <para>
       suspends in seconds, to suspend the session.
      </para>  
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
dbms_lock.sleep(0.1);
    </programlisting>
   </sect4>
  </sect3>

  <sect3>
   <title>DBMS_METADATA</title>

   <para><emphasis role="bold">
    Overview
   </emphasis></para>

   <para>
    Provides a way for you to retrieve metadata from the database dictionary.
   </para>

   <table>
    <title>DBMS_METADATA Features</title>
    <tgroup cols="2">
     <colspec colnum="1" colname="col1"/>
     <colspec colnum="2" colname="col2"/>
     <thead>
      <row>
       <entry>Feature</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>get_ddl</entry>
       <entry>Let you fetch metadata for objects.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    Syntax
   </emphasis></para>

   <programlisting>
     GET_DDL(object_type VARCHAR,name VARCHAR,schema VARCHAR DEFAULT current_schema(),VARCHAR DEFAULT 'COMPATIBLE',VARCHAR DEFAULT  'ORACLE',VARCHAR DEFAULT  'DDL',BOOL DEFAULT  'false') RETURNS TEXT
   </programlisting>

   <sect4>
    <title>Description of Features</title>

    <para>
     This section explains each feature of dbms_job.
    </para>

    <para><emphasis role="bold">
     GET_DDL
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Let you fetch metadata for objects.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select dbms_metadata.get_ddl('constraint', 'key1_check') from dual;
    </programlisting>
   </sect4>
  </sect3>

  <sect3>
   <title>DBMS_OBFUSCATION_TOOLKIT</title>

   <para><emphasis role="bold">
    Overview
   </emphasis></para>

   <para>
    Enables an application to encrypt data using either the Data Encryption Standard (DES) or the Triple DES algorithms.
   </para>

   <table>
    <title>DBMS_OBFUSCATION_TOOLKIT Features</title>
    <tgroup cols="2">
     <colspec colnum="1" colname="col1"/>
     <colspec colnum="2" colname="col2"/>
     <thead>
      <row>
       <entry>Feature</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>md5</entry>
       <entry>Generates MD5 hashes of data.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    Syntax
   </emphasis></para>

   <programlisting>
     MD5(input_string TEXT) RETURNS RAW
   </programlisting>

   <sect4>
    <title>Description of Features</title>

    <para>
     This section explains each feature of dbms_job.
    </para>

    <para><emphasis role="bold">
     MD5
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Generates MD5 hashes of data.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select dbms_obfuscation_toolkit.md5(input_string => '测试')::text from dual;
    </programlisting>
   </sect4>
  </sect3>

  <sect3>
   <title>DBMS_SNAPSHOT</title>

   <para><emphasis role="bold">
    Overview
   </emphasis></para>

   <para>
   Enables you to refresh snapshots(MVIEW).
   </para>

   <table>
    <title>DBMS_SNAPSHOT Features</title>
    <tgroup cols="2">
     <colspec colnum="1" colname="col1"/>
     <colspec colnum="2" colname="col2"/>
     <thead>
      <row>
       <entry>Feature</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>refresh</entry>
       <entry>Refreshes a list of snapshots.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    Syntax
   </emphasis></para>

   <programlisting>
     REFRESH(list TEXT,method TEXT default 'C')
   </programlisting>

   <sect4>
    <title>Description of Features</title>

    <para>
     This section explains each feature of dbms_job.
    </para>

    <para><emphasis role="bold">
     REFRESH
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This procedure refreshes a list of snapshots(MVIEW).
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select dbms_snapshot.refresh('mv_test_dbms_snapshot,mv_test_dbms_snapshot1') from dual;
    </programlisting>
   </sect4>
  </sect3>

  <sect3>
   <title>UTL_FILE</title>

   <para><emphasis role="bold">
    Overview
   </emphasis></para>

   <para>
    Text files can be written and read using PL/pgSQL.
   </para>

   <para>
    To perform these file operations, the directory for the operation target must be registered
    in the UTL_FILE.UTL_FILE_DIR table beforehand. Use the INSERT statement as the database
    administrator or a user who has INSERT privileges to register the directory. Also, if the
    directory is no longer necessary, delete it from the same table. Refer to "Registering and
    Deleting Directories" for information on the how to register and delete the directory.
   </para>

   <para>
    Declare the file handler explained hereafter as follows in PL/pgSQL:
   </para>

   <programlisting>
    DECLARE f UTL_FILE.FILE_TYPE;
   </programlisting>

   <table>
    <title>UTL_FILE Features</title>
    <tgroup cols="2">
     <colspec colnum="1" colname="col1"/>
     <colspec colnum="2" colname="col2"/>
     <thead>
      <row>
       <entry>Feature</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>FCLOSE</entry>
       <entry>Closes a file.</entry>
      </row>
      <row>
       <entry>FCLOSE_ALL</entry>
       <entry>Closes all files open in a session.</entry>
      </row>
      <row>
       <entry>FCOPY</entry>
       <entry>Copies a whole file or a contiguous portion thereof.</entry>
      </row>
      <row>
       <entry>FFLUSH</entry>
       <entry>Flushes the buffer.</entry>
      </row>
      <row>
       <entry>FGETATTR</entry>
       <entry>Retrieves the attributes of a file.</entry>
      </row>
      <row>
       <entry>FOPEN</entry>
       <entry>Opens a file.</entry>
      </row>
      <row>
       <entry>FREMOVE</entry>
       <entry>Deletes a file.</entry>
      </row>
      <row>
       <entry>FRENAME</entry>
       <entry>Renames a file.</entry>
      </row>
      <row>
       <entry>GET_LINE</entry>
       <entry>Reads a line from a text file.</entry>
      </row>
      <row>
       <entry>IS_OPEN</entry>
       <entry>Checks if a file is open.</entry>
      </row>
      <row>
       <entry>NEW_LINE</entry>
       <entry>Writes newline characters.</entry>
      </row>
      <row>
       <entry>PUT</entry>
       <entry>Writes a string.</entry>
      </row>
      <row>
       <entry>PUT_LINE</entry>
       <entry>Appends a newline character to a string and writes the string.</entry>
      </row>
      <row>
       <entry>PUTF</entry>
       <entry>Writes a formatted string.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    Syntax
   </emphasis></para>

   <mediaobject>
    <imageobject>
     <imagedata fileref="images/UTL_FILE.svg" format="SVG" width="100%"/>
    </imageobject>
   </mediaobject>

   <sect4>
    <title>Registering and Deleting Directories</title>

    <para><emphasis role="bold">
     Registering the directory
    </emphasis></para>

    <para>
     1. Check if the directory is already registered (if it is, then step 2 is not necessary).
    </para>

    <programlisting>
     SELECT * FROM UTL_FILE.UTL_FILE_DIR WHERE dir='/home/pgsql';
    </programlisting>

    <para>
     2. Register the directory.
    </para>

    <programlisting>
     INSERT INTO UTL_FILE.UTL_FILE_DIR VALUES('/home/pgsql');
    </programlisting>

    <para><emphasis role="bold">
     Deleting the directory
    </emphasis></para>

    <programlisting>
     DELETE FROM UTL_FILE.UTL_FILE_DIR WHERE dir='/home/lightdb';
    </programlisting>
   </sect4>

   <sect4>
    <title>Description</title>

    <para>
     This section explains each feature of UTL_FILE.
    </para>

    <para><emphasis role="bold">
     FCLOSE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       FCLOSE closes a file that is open.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify an open file handle.
      </para>
     </listitem>
     <listitem>
      <para>
       The value returned is a NULL value.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     f := UTL_FILE.FCLOSE(f);
    </programlisting>

    <para><emphasis role="bold">
     FCLOSE_ALL
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       FCLOSE_ALL closes all files open in a session.
      </para>
     </listitem>
     <listitem>
      <para>
       Files closed with FCLOSE_ALL can no longer be read or written.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM UTL_FILE.FCLOSE_ALL();
    </programlisting>

    <para><emphasis role="bold">
     FCOPY
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       FCOPY copies a whole file or a contiguous portion thereof. The whole file is copied if
        <emphasis role="italic">startLine</emphasis> and <emphasis role="italic">endLine</emphasis>
       are not specified.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the directory location of the source file.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the source file.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the directory where the destination file will be created.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the name of the destination file.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the line number at which to begin copying. Specify a value greater than 0. If
       not specified, 1 is used.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the line number at which to stop copying. If not specified, the last line number
       of the file is used.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM UTL_FILE.FCOPY('/home/lightdb', 'regress_ltsql.txt', '/home/lightdb', 'regress_ltsql2.txt');
    </programlisting>

    <para><emphasis role="bold">
     FFLUSH
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       FFLUSH forcibly writes the buffer data to a file.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify an open file handle.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM UTL_FILE.FFLUSH(f);
    </programlisting>

    <para><emphasis role="bold">
     FGETATTR
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       FGETATTR retrieves file attributes: file existence, file size, and information about the
       block size of the file.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the directory where the file exists.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the relevant file name.
      </para>
     </listitem>
     <listitem>
      <para>
       Use a SELECT statement to obtain the file attributes, which are stored in the fexists,
       file_length, and blocksize columns.
      </para>
     </listitem>
     <listitem>
      <para>
       The fexists column stores a boolean (TRUE/FALSE) value. If the file exists, fexists is
       set to TRUE. If the file does not exist, fexists is set to FALSE. The data type of fexists is
       BOOLEAN.
      </para>
     </listitem>
     <listitem>
      <para>
       The file_length column stores the length of the file in bytes. If the file does not
       exist, file_length is NULL. The data type of file_length is INTEGER.
      </para>
     </listitem>
     <listitem>
      <para>
       The blocksize column stores the block size of the file in bytes. If the file does not
       exist, blocksize is NULL. The data type of blocksize is INTEGER.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     SELECT fexists, file_length, blocksize INTO file_flag, file_len, size
     FROM UTL_FILE.FGETATTR('/home/lightdb', 'regress_ltsql.txt');
    </programlisting>

    <para><emphasis role="bold">
     FOPEN
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>FOPEN opens a file.</para>
     </listitem>
     <listitem>
      <para>Specify the directory where the file exists.</para>
     </listitem>
     <listitem>
      <para>Specify the file name.</para>
     </listitem>
     <listitem>
      <para>Specify the mode for opening the file:</para>
     </listitem>
    </itemizedlist>

    <para>r: Read</para>
    <para>w: Write</para>
    <para>a: Add</para>

    <itemizedlist>
     <listitem>
      <para>
       Specify the maximum string length (in bytes) that can be processed with one operation.
       If omitted, the default is 1024. Specify a value from 1 to 32767.
      </para>
     </listitem>
     <listitem>
      <para>
       Up to 50 files per session can be open at the same time.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     f := UTL_FILE.FOPEN('/home/pgsql','regress_pgsql.txt','r',1024);
    </programlisting>

    <para><emphasis role="bold">
     FREMOVE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>FREMOVE deletes a file.</para>
     </listitem>
     <listitem>
      <para>Specify the directory where the file exists.</para>
     </listitem>
     <listitem>
      <para>Specify the file name.</para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM UTL_FILE.FREMOVE('/home/lightdb', 'regress_ltsql.txt');
    </programlisting>

    <para><emphasis role="bold">
     FRENAME
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>FRENAME renames a file.</para>
     </listitem>
     <listitem>
      <para>Specify the directory location of the source file.</para>
     </listitem>
     <listitem>
      <para>Specify the source file to be renamed.</para>
     </listitem>
     <listitem>
      <para>Specify the directory where the renamed file will be created.</para>
     </listitem>
     <listitem>
      <para>Specify the new name of the file.</para>
     </listitem>
     <listitem>
      <para>
       Specify whether to overwrite a file if one exists with the same name and in the same
       location as the renamed file. If TRUE is specified, the existing file will be overwritten. If
       FALSE is specified, an error occurs. If omitted, FALSE is set.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "The SQL Language" > "Data Types" > "Boolean Type" in the LightDB
     Documentation for information on boolean type (TRUE/FALSE) values.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM UTL_FILE.FRENAME('/home/lightdb', 'regress_ltsql.txt', '/home/lightdb', 'regress_ltsql2.txt', TRUE);
    </programlisting>

    <para><emphasis role="bold">
     GET_LINE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       GET_LINE reads a line from a file.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the file handle returned by FOPEN using r (read) mode.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the number of bytes to read from the file. If not specified, the maximum string
       length specified at FOPEN will be used.
      </para>
     </listitem>
     <listitem>
      <para>
       The return value is the buffer that receives the line read from the file.
      </para>
     </listitem>
     <listitem>
      <para>
       Newline characters are not loaded to the buffer.
      </para>
     </listitem>
     <listitem>
      <para>
       An empty string is returned if a blank line is loaded.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the maximum length (in bytes) of the data to be read. Specify a value from 1 to
       32767. If not specified, the maximum string length specified at FOPEN is set. If no maximum
       string length is specified at FOPEN, 1024 is set.
      </para>
     </listitem>
     <listitem>
      <para>
       If the line length is greater than the specified number of bytes to read, the remainder
       of the line is read on the next call.
      </para>
     </listitem>
     <listitem>
      <para>
       A NO_DATA_FOUND exception will occur when trying to read past the last line.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     buff := UTL_FILE.GET_LINE(f);
    </programlisting>

    <para><emphasis role="bold">
     IS_OPEN
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       IS_OPEN checks if a file is open.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the file handle.
      </para>
     </listitem>
     <listitem>
      <para>
       The return value is a BOOLEAN type. TRUE represents an open state
       and FALSE represents a closed state.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     See
    </emphasis></para>

    <para>
     Refer to "The SQL Language" > "Data Types" > "Boolean Type" in the LightDB
     Documentation for information on boolean type (TRUE/FALSE) values.
    </para>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     IF UTL_FILE.IS_OPEN(f) THEN
         PERFORM UTL_FILE.FCLOSE(f);
     END IF;
    </programlisting>

    <para><emphasis role="bold">
     NEW_LINE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       NEW_LINE writes one or more newline characters.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify an open file handle.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the number of newline characters to be written to the file.
       If omitted, "1" is used.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM UTL_FILE.NEW_LINE(f, 2);
    </programlisting>

    <para><emphasis role="bold">
     PUT
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       PUT writes a string to a file.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the file handle that was opened with FOPEN using w (write) or a (append).
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the string to be written to the file.
      </para>
     </listitem>
     <listitem>
      <para>
       The maximum length (in bytes) of the string to be written is the maximum string length
       specified at FOPEN.
      </para>
     </listitem>
     <listitem>
      <para>
       PUT does not append a newline character. To append a newline character, execute NEW_LINE.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM UTL_FILE.PUT(f, 'ABC');
    </programlisting>

    <para><emphasis role="bold">
     PUT_LINE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       PUT_LINE appends a newline character to a string and writes the string.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the file handle that was opened with FOPEN w (write) or a (append).
      </para>
     </listitem>
     <listitem>
      <para>
       Specify whether to forcibly write to the file. If TRUE is specified, file writing is
       forced. If FALSE is specified, file writing is asynchronous. If omitted, FALSE will be set.
      </para>
     </listitem>
     <listitem>
      <para>
       The maximum length of the string (in bytes) is the maximum string length specified at FOPEN.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM UTL_FILE.PUT_LINE(f, 'ABC', TRUE);
    </programlisting>

    <para><emphasis role="bold">
     PUTF
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       PUTF writes a formatted string.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the file handle that was opened with FOPEN w (write) or a (append).
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the format, which is a string that includes the formatting characters \n and %s.
      </para>
     </listitem>
     <listitem>
      <para>
       The \n in the format is code for a newline character.
      </para>
     </listitem>
     <listitem>
      <para>
       Specify the same number of input values as there are %s in the format. Up to a maximum
       of five input values can be specified. The %s in the format are replaced with the
       corresponding input characters. If an input value corresponding to %s is not specified, it is
       replaced with an empty string.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
     PERFORM UTL_FILE.PUTF(f, '[1=%s, 2=%s, 3=%s, 4=%s, 5=%s]\n', '1', '2', '3', '4', '5');
    </programlisting>
   </sect4>

   <sect4>
    <title>Usage Example</title>

    <para>
     The procedure when using UTL_FILE, and a usage example, are shown below.
    </para>

    <para>
     1. Preparation
    </para>

    <para>
     Before starting a new job that uses UTL_FILE, register the directory in the
     UTL_FILE.UTL_FILE_DIR table.
    </para>

    <para>
     Refer to "Registering and Deleting Directories" for information on how to register the directory.
    </para>

    <para>
     2. Performing a job
    </para>

    <para>
     Perform a job that uses UTL_FILE. The example is shown below.
    </para>

    <programlisting>
     CREATE OR REPLACE FUNCTION gen_file(mydir TEXT, infile TEXT, outfile TEXT, copyfile TEXT) RETURNS void AS $$
     DECLARE
       v1 VARCHAR(32767);
       inf UTL_FILE.FILE_TYPE;
       otf UTL_FILE.FILE_TYPE;
     BEGIN
       inf := UTL_FILE.FOPEN(mydir, infile,'r',256);
       otf := UTL_FILE.FOPEN(mydir, outfile,'w');
       v1 := UTL_FILE.GET_LINE(inf,256);
       PERFORM UTL_FILE.PUT_LINE(otf,v1,TRUE);
       v1 := UTL_FILE.GET_LINE(inf,256);
       PERFORM UTL_FILE.PUTF(otf,'%s\n',v1);
       v1 := UTL_FILE.GET_LINE(inf, 256);
       PERFORM UTL_FILE.PUT(otf,v1);
       PERFORM UTL_FILE.NEW_LINE(otf);
       PERFORM UTL_FILE.FFLUSH(otf);

       inf := UTL_FILE.FCLOSE(inf);
       otf := UTL_FILE.FCLOSE(otf);

       PERFORM UTL_FILE.FCOPY(mydir, outfile, mydir, copyfile, 2, 3);
       PERFORM UTL_FILE.FRENAME(mydir, outfile, mydir, 'rename.txt');

     END;
     $$ LANGUAGE plpgsql;

     SELECT gen_file('/home/pgsql', 'input.txt', 'output.txt', 'copyfile.txt');
    </programlisting>

    <para>
     3. Post-processing
    </para>

    <para>
     If you remove a job that uses UTL_FILE, delete the directory information from the
     UTL_FILE.UTL_FILE_DIR table. Ensure that the directory information is not being used by another
     job before deleting it.
    </para>

    <para>
     Refer to "Registering and Deleting Directories" for information on how to delete the
     directory.
    </para>
   </sect4>
  </sect3>

  <sect3>
   <title>UTL_RAW</title>

   <para><emphasis role="bold">
    Overview
   </emphasis></para>

   <para>
   Provides SQL functions for manipulating RAW datatypes.
   </para>

   <table>
    <title>UTL_RAW Features</title>
    <tgroup cols="2">
     <colspec colnum="1" colname="col1"/>
     <colspec colnum="2" colname="col2"/>
     <thead>
      <row>
       <entry>Feature</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>BIT_AND</entry>
       <entry>Performs bitwise logical "and" of the values in RAW r1 with RAW r2 and returns the "anded" result RAW.</entry>
      </row>
      <row>
       <entry>BIT_COMPLEMENT</entry>
       <entry>Performs bitwise logical "complement" of the values in RAW r and returns the "complement'ed" result RAW.</entry>
      </row>
      <row>
       <entry>BIT_OR</entry>
       <entry>Performs bitwise logical "or" of the values in RAW r1 with RAW r2 and returns the "or'd" result RAW.</entry>
      </row>
      <row>
       <entry>BIT_XOR</entry>
       <entry>Performs bitwise logical "exclusive or" of the values in RAW r1 with RAW r2 and returns the "xor'd" result RAW.</entry>
      </row>
      <row>
       <entry>CAST_FROM_BINARY_INTEGER</entry>
       <entry>Returns the RAW binary representation of a BINARY_INTEGER value.</entry>
      </row>
      <row>
       <entry>CAST_FROM_NUMBER</entry>
       <entry>Returns the RAW binary representation of a NUMBER value.</entry>
      </row>
      <row>
       <entry>CAST_TO_BINARY_INTEGER </entry>
       <entry>Casts the RAW binary representation of a BINARY_INTEGER into a BINARY_INTEGER.</entry>
      </row>
      <row>
       <entry>CAST_TO_NUMBER</entry>
       <entry>Casts the RAW binary representation of a NUMBER into a NUMBER.</entry>
      </row>
      <row>
       <entry>CAST_TO_RAW</entry>
       <entry>Converts a text value into a RAW value.</entry>
      </row>
      <row>
       <entry>CAST_TO_VARCHAR2</entry>
       <entry>Converts a RAW value into a text value.</entry>
      </row>
      <row>
       <entry>COMPARE</entry>
       <entry>Compares RAW r1 against RAW r2.</entry>
      </row>
      <row>
       <entry>CONCAT</entry>
       <entry>Concatenates up to 12 RAWs into a single RAW.</entry>
      </row>
      <row>
       <entry>CONVERT</entry>
       <entry>Converts RAW r from character set from_charset to character set to_charset and returns the resulting RAW.</entry>
      </row>
      <row>
       <entry>COPIES</entry>
       <entry>Returns n copies of r concatenated together.</entry>
      </row>
      <row>
       <entry>LENGTH</entry>
       <entry>Returns the length in bytes of a RAW r.</entry>
      </row>
      <row>
       <entry>OVERLAY</entry>
       <entry>Overlays the specified portion of target RAW with overlay RAW, starting from byte position pos of target and proceeding for len bytes.</entry>
      </row>
      <row>
       <entry>REVERSE</entry>
       <entry>Reverses a byte sequence in RAW r from end to end.</entry>
      </row>
      <row>
       <entry>TRANSLITERATE</entry>
       <entry>Translates the bytes in the input RAW r according to the bytes in the translation RAWs from_set and to_set.</entry>
      </row>
      <row>
       <entry>TRANSLATE</entry>
       <entry>Converts the bytes in the input RAW r according to the bytes in the transliteration RAWs from_set and to_set.</entry>
      </row>
      <row>
       <entry>XRANGE</entry>
       <entry>Reverses a byte sequence in RAW r from end to end.</entry>
      </row>
      <row>
       <entry>REVERSE</entry>
       <entry>Returns a RAW containing all valid 1-byte encodings in succession, beginning with the value start_byte and ending with the value end_byte.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    Syntax
   </emphasis></para>

   <programlisting>
CAST_TO_VARCHAR2(r raw)  RETURNS TEXT
CAST_TO_RAW(c TEXT)  RETURNS RAW
CONCATr1 RAW,r2 RAW,r3 RAW,r4 RAW,r5 RAW,r6 RAW,r7 RAW,r8 RAW,r9 RAW,r10 RAW,r11 RAW,r12 RAW)  RETURNS RAW
LENGTH(r RAW) RETURNS INT4
SUBSTR(r RAW,pos INT4,len INT4 DEFAULT null)  RETURNS RAW
TRANSLITERATE(r RAW,to_set RAW DEFAULT ''::raw ,from_set RAW DEFAULT ''::raw,pad RAW DEFAULT '00'::raw)  RETURNS RAW
TRANSLATE(r RAW,from_set RAW,to_set RAW) RETURNS RAW
COPIES(r RAW,n INT8) RETURNS RAW
OVERLAY(overlay_str RAW,target RAW,pos INT4 DEFAULT 1,len INT4 DEFAULT NULL,pad RAW DEFAULT '00'::raw) RETURNS RAW
XRANGE(start_byte RAW,end_byte RAW) RETURNS RAW
REVERSE(r RAW) RETURNS RAW
COMPARE(r1 RAW,r2 RAW,pad RAW)  RETURNS INT4
CONVERT(r RAW,to_charset TEXT,from_charset TEXT) RETURNS RAW
BIT_AND(r1 RAW,r2 RAW) RETURNS RAW
BIT_OR(r1 RAW,r2 RAW) RETURNS RAW
BIT_XOR(r1 RAW,r2 RAW) RETURNS RAW
BIT_COMPLEMENT(r RAW) RETURNS RAW
CAST_TO_NUMBER(r RAW)RETURNS NUMERIC
CAST_FROM_NUMBER(n NUMERIC) RETURNS RAW
CAST_TO_BINARY_INTEGER(r RAW,endianess INT)RETURNS INT4
CAST_FROM_BINARY_INTEGER(n INT4,endianess INT) RETURNS RAW
   </programlisting>

   <sect4>
    <title>Description of Features</title>

    <para>
     This section explains each feature of dbms_job.
    </para>

    <para><emphasis role="bold">
     CAST_TO_VARCHAR2
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function converts a RAW value represented using some number of data bytes into a text value with that number of data bytes.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_raw.cast_to_varchar2('43616D65726F6E') from dual;
    </programlisting>

    <para><emphasis role="bold">
     CAST_TO_RAW
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function converts a text value represented using some number of data bytes into a RAW value with that number of data bytes. The data itself is not modified in any way, but its datatype is recast to a RAW datatype.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_raw.cast_to_raw('测试') from dual;
    </programlisting>

    <para><emphasis role="bold">
     CONCAT
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function concatenates up to 12 RAWs into a single RAW.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select  utl_raw.concat( '1', '0102', 'f', '1a2b' ) from dual;
    </programlisting>

    <para><emphasis role="bold">
     LENGTH
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function returns the length in bytes of a RAW r.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select  UTL_RAW.length('FFFF'::raw) from dual;
    </programlisting>

    <para><emphasis role="bold">
     SUBSTR
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       If pos is positive, then SUBSTR counts from the beginning of r to find the first byte. If pos is negative, then SUBSTR counts backward from the end of the r. 
       The value pos can be 0.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_raw.substr( '0102030405', 3, 2 ) from dual;
    </programlisting>

    <para><emphasis role="bold">
     TRANSLITERATE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function converts the bytes in the input RAW r according to the bytes in the transliteration RAWs from_set and to_set.
       Successive bytes in r are looked up in the from_set, and, if not found, copied unaltered to the result RAW.
       If found, then they are replaced in the result RAW by either corresponding bytes in the to_set, or the pad byte when no correspondence exists.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_raw.transliterate( '010203040502', '0709', '01020304', 'ff' ) from dual;
    </programlisting>

    <para><emphasis role="bold">
     TRANSLATE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function translates the bytes in the input RAW r according to the bytes in the translation RAWs from_set and to_set.
       If a byte in r has a matching byte in from_set, then it is replaced by the byte in the corresponding position in to_set, or deleted.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_raw.translate( '0102030405', '0304', '09' ) from dual;
    </programlisting>

    <para><emphasis role="bold">
     COPIES
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function returns n copies of r concatenated together.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_raw.copies( '010203', 3 ) from dual;
    </programlisting>

    <para><emphasis role="bold">
     OVERLAY
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function overlays the specified portion of target RAW with overlay_str RAW, starting from byte position pos of target and proceeding for len bytes.
      </para>
     </listitem>
     <listitem>
      <para>
       If overlay_str has less than len bytes, then it is extended to len bytes using the pad byte. If overlay_str exceeds len bytes, then the extra bytes in overlay_str are ignored.
       If len bytes beginning at position pos of target exceeds the length of target, then target is extended to contain the entire length of overlay_str.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_raw.overlay( 'aabb', '010203', 5, 1, 'FF' ) from dual;
    </programlisting>

    <para><emphasis role="bold">
     XRANGE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function returns a RAW value containing the succession of one-byte encodings beginning and ending with the specified byte-codes.
      </para>
     </listitem>
     <listitem>
      <para>
        If the start_byte value is greater than the end_byte value, then the succession of resulting bytes begins with start_byte, wraps through x'FF' back to x'00', then ends at end_byte.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_raw.xrange( 'FA', '01' ) from dual;
    </programlisting>

    <para><emphasis role="bold">
     REVERSE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function reverses a byte sequence in RAW r from end to end. For example, x'0102F3' would be reversed to x'F30201', and 'xyz' would be reversed to 'zyx'.
       The result length is the same as the input RAW length.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_raw.reverse( '010203040506070809' ) from dual;
    </programlisting>

    <para><emphasis role="bold">
     COMPARE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function compares two RAW values. If they differ in length, then the shorter is extended on the right according to the optional pad parameter.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_raw.compare( '010203', '01020304', '04' ) from dual;
    </programlisting>

    <para><emphasis role="bold">
     CONVERT
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function converts RAW r from character set from_charset to character set to_charset and returns the resulting RAW.
      </para>
     </listitem>
     <listitem>
      <para>
       Both from_charset and to_charset must be supported character sets defined to the LightDB server.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_raw.convert(rawout('测试'::BYTEA)::text::raw,'GBK','UTF8') from dual;
    </programlisting>


    <para><emphasis role="bold">
     BIT_AND
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function performs bitwise logical "and" of the values in RAW r1 with RAW r2 and returns the "anded" result RAW.
      </para>
     </listitem>
     <listitem>
      <para>
       If r1 and r2 differ in length, the shorter of the two RAWs will extend to same length by add '00'. (it is not same with oracle).
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_raw.bit_and('1234ffdd','fff1234f') from dual;
    </programlisting>

    <para><emphasis role="bold">
     BIT_OR
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function performs bitwise logical "or" of the values in RAW r1 with RAW r2 and returns the or'd result RAW.
      </para>
     </listitem>
     <listitem>
      <para>
       If r1 and r2 differ in length, the shorter of the two RAWs will extend to same length by add '00'. (it is not same with oracle).
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_raw.bit_or('1234ffdd','fff1234f') from dual;
    </programlisting>

    <para><emphasis role="bold">
     BIT_XOR
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function performs bitwise logical "exclusive or" of the values in RAW r1 with RAW r2 and returns the xor'd result RAW.
      </para>
     </listitem>
     <listitem>
      <para>
       If r1 and r2 differ in length, the shorter of the two RAWs will extend to same length by add '00'. (it is not same with oracle).
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_raw.bit_xor('1234ffdd','1234ffee') from dual;
    </programlisting>

    <para><emphasis role="bold">
     BIT_COMPLEMENT
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function performs bitwise logical "complement" of the values in RAW r and returns the complement'ed result RAW. The result length equals the input RAW r length.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select UTL_raw.bit_complement('1122FF') from dual;
    </programlisting>

    <para><emphasis role="bold">
     CAST_TO_NUMBER
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function casts the RAW binary representation of a NUMBER into a NUMBER.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_raw.cast_TO_number('C10215') from dual;
    </programlisting>

    <para><emphasis role="bold">
     CAST_FROM_NUMBER
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function returns the RAW binary representation of a NUMBER value.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select UTL_raw.cast_from_number(1.2) from dual;
    </programlisting>

    <para><emphasis role="bold">
     CAST_TO_BINARY_INTEGER
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function casts the RAW binary representation of a INTEGER into a INTEGER.(oracle is BINARY_INTEGER)
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_raw.cast_to_binary_integer('FF00') from dual;
    </programlisting>


    <para><emphasis role="bold">
     CAST_FROM_BINARY_INTEGER
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function returns the RAW binary representation of a INTEGER value.(oracle is BINARY_INTEGER)
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_raw.cast_from_binary_integer(65280) from dual;
    </programlisting>

   </sect4>
  </sect3>

  <sect3>
   <title>UTL_URL</title>

   <para><emphasis role="bold">
    Overview
   </emphasis></para>

   <para>
   Has two functions that provide escape and unescape mechanisms for URL characters.
   </para>

   <table>
    <title>UTL_URL Features</title>
    <tgroup cols="2">
     <colspec colnum="1" colname="col1"/>
     <colspec colnum="2" colname="col2"/>
     <thead>
      <row>
       <entry>Feature</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>ESCAPE</entry>
       <entry>Returns a URL with illegal characters (and optionally reserved characters) escaped using the %2-digit-hex-code format.</entry>
      </row>
      <row>
       <entry>UNESCAPE</entry>
       <entry>Unescapes the escape character sequences to their original forms in a URL. Convert the %XX escape character sequences to the original characters.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    Syntax
   </emphasis></para>

   <programlisting>
ESCAPE(url TEXT,escape_reserved_chars BOOL DEFAULT FALSE,url_charset TEXT DEFAULT 'UTF8')  RETURNS TEXT
UNESCAPE(url TEXT,url_charset TEXT DEFAULT 'UTF8') RETURNS TEXT
   </programlisting>

   <sect4>
    <title>Description of Features</title>

    <para>
     This section explains each feature of dbms_job.
    </para>

    <para><emphasis role="bold">
     ESCAPE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function returns a URL with illegal characters (and optionally reserved characters) escaped using the %2-digit-hex-code format.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_url.escape('http://新年好.com') from dual;
    </programlisting>

    <para><emphasis role="bold">
     UNESCAPE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function unescapes the escape character sequences to its original form in a URL, to convert the %XX escape character sequences to the original characters.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_url.unescape('http%3A%2F%2F%E6%96%B0%E5%B9%B4%E5%A5%BD.com', 'utf8') from dual;
    </programlisting>

   </sect4>
  </sect3>

  <sect3>
   <title>UTL_ENCODE</title>

   <para><emphasis role="bold">
    Overview
   </emphasis></para>

   <para>
   Provides functions that encode RAW data into a standard encoded format.
   </para>

   <table>
    <title>UTL_ENCODE Features</title>
    <tgroup cols="2">
     <colspec colnum="1" colname="col1"/>
     <colspec colnum="2" colname="col2"/>
     <thead>
      <row>
       <entry>Feature</entry>
       <entry>Description</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>BASE64_DECODE</entry>
       <entry>Reads the base 64-encoded RAW input string and decodes it to its original RAW value.</entry>
      </row>
      <row>
       <entry>BASE64_ENCODE</entry>
       <entry>Encodes the binary representation of the RAW value into base 64 elements and returns it in the form of a RAW string.</entry>
      </row>
      <row>
       <entry>MIMEHEADER_DECODE</entry>
       <entry>Decodes a string from mime header format.</entry>
      </row>
      <row>
       <entry>MIMEHEADER_ENCODE</entry>
       <entry>Encodes a string into mime header format.</entry>
      </row>
      <row>
       <entry>QUOTED_PRINTABLE_DECODE</entry>
       <entry>Reads the text quoted printable format input string and decodes it to the corresponding RAW string.</entry>
      </row>
      <row>
       <entry>QUOTED_PRINTABLE_ENCODE</entry>
       <entry>Reads the RAW input string and encodes it to the corresponding quoted printable format string.</entry>
      </row>
      <row>
       <entry>TEXT_DECODE</entry>
       <entry>Decodes a character set sensitive text string.</entry>
      </row>
      <row>
       <entry>TEXT_ENCODE</entry>
       <entry>Encodes a character set sensitive text string.</entry>
      </row>
      <row>
       <entry>UUDECODE</entry>
       <entry>Reads the RAW uuencode format input string and decodes it to the corresponding RAW string.</entry>
      </row>
      <row>
       <entry>UUDECODE</entry>
       <entry>Reads the RAW input string and encodes it to the corresponding uuencode format string.</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para><emphasis role="bold">
    Syntax
   </emphasis></para>

   <programlisting>
BASE64_DECODE(r RAW) RETURNS RAW
BASE64_ENCODE(r RAW) RETURNS RAW
MIMEHEADER_DECODE(buf TEXT) RETURNS TEXT
MIMEHEADER_ENCODE(buf TEXT,encode_charset TEXT default 'UTF8'::text,encoding INT4 default 2::int4) RETURNS TEXT
QUOTED_PRINTABLE_DECODE(r RAW)  RETURNS RAW
QUOTED_PRINTABLE_ENCODE(r RAW) RETURNS RAW
TEXT_DECODE(buf TEXT,encode_charset TEXT default 'UTF8'::text,encoding INT4 default 2::int4) RETURNS TEXT
TEXT_ENCODE(buf TEXT,encode_charset TEXT default 'UTF8'::text,encoding INT4 default 2::int4) RETURNS TEXT
UUDECODE(r RAW) RETURNS RAW
UUENCODE(r RAW,type INT default 1::int,filename TEXT default 'uuencode.txt',permission TEXT default '0') RETURNS RAW
   </programlisting>

   <sect4>
    <title>Description of Features</title>

    <para>
     This section explains each feature of dbms_job.
    </para>

    <para><emphasis role="bold">
     BASE64_DECODE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function reads the base 64-encoded RAW input string and decodes it to its original RAW value.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_encode.base64_decode('3572574C364B2B56') from dual;
    </programlisting>

    <para><emphasis role="bold">
     BASE64_ENCODE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function encodes the binary representation of the RAW value into base 64 elements and returns it in the form of a RAW string.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_encode.base64_encode(rawtohex('测试')::raw) from dual;
    </programlisting>

    <para><emphasis role="bold">
     MIMEHEADER_DECODE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       Decodes a string from mime header format('=?&lt;charset&gt; ?&lt;encoding&gt; ?&lt;encoded text&gt;?= ').
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select UTL_ENCODE.mimeheader_decode('=?UTF-8?Q?What=20is=20the=20date=20=E7=8E=8B=20=3D20=20/=20\=3F?=') from dual;
    </programlisting>

    <para><emphasis role="bold">
     MIMEHEADER_ENCODE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function produces as output an "encoded word" of the form('=?&lt;charset&gt; ?&lt;encoding&gt; ?&lt;encoded text&gt;?= ').
      </para>
     </listitem>
     <listitem>
      <para>
       The ENCODING input parameter accepts as valid values UTL_ENCODE.QUOTED_PRINTABLE or UTL_ENCODE.BASE64 or NULL. If NULL, quoted-printable encoding is selected as a default value.
      </para>
     </listitem>
     <listitem>
      <para>
       The &lt;charset&gt; value is specified as the input parameter encode_charset. 
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_encode.MIMEHEADER_ENCODE('What is the date 王 =20 / \?', encode_charset =>'UTF8', encoding => 1 ) from dual;
    </programlisting>

    <para><emphasis role="bold">
     QUOTED_PRINTABLE_DECODE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function reads the raw quoted printable format input string and decodes it to the corresponding RAW string.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_encode.quoted_printable_decode('3D45353D42453D3830313233345C61732064663D33444142') from dual;
    </programlisting>

    <para><emphasis role="bold">
     QUOTED_PRINTABLE_ENCODE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function reads the RAW input string and encodes it to the corresponding quoted printable format string.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_encode.quoted_printable_decode('3D45353D42453D3830313233345C61732064663D33444142') from dual;
    </programlisting>

    <para><emphasis role="bold">
     TEXT_DECODE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function converts the input text to the target character set as specified by the encode_charset parameter, if not NULL. The encoded text is converted to the base character set of database.
      </para>
     </listitem>
     <listitem>
      <para>
       You can decode from either quoted-printable or base64 format, with regard to each encoding parameter. 1 for base64, 2 for quoted-printable, default is quoted-printable format.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_encode.text_decode('=CD=F91234\as df=3DAB',encode_charset => 'GBK',encoding => 2) from dual;
    </programlisting>

    <para><emphasis role="bold">
     TEXT_ENCODE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function converts the input text to the target character set as specified by the encode_charset parameter, if not NULL. The text is encoded to either base64 or quoted-printable format, as specified by the encoding parameter. 
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select utl_encode.text_encode('往12\as df=AB',encode_charset => 'GBK', encoding => 1) from dual;
    </programlisting>

    <para><emphasis role="bold">
     UUDECODE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function reads the RAW uuencode format input string and decodes it to the corresponding RAW string.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
 select UTL_ENCODE.uudecode(rawtohex(',6[C9&amp;5FA$R,S0`')::raw) from dual;
    </programlisting>

    <para><emphasis role="bold">
     UUENCODE
    </emphasis></para>

    <itemizedlist>
     <listitem>
      <para>
       This function reads the RAW input string and encodes it to the corresponding uuencode format string.
      </para>
     </listitem>
    </itemizedlist>

    <para><emphasis role="bold">
     Example
    </emphasis></para>

    <programlisting>
select UTL_ENCODE.uuencode('5BB8D91959A113233340'::raw) from dual;
    </programlisting>
   </sect4>

  </sect3>

 </sect2>

 <sect2>
  <title>Transaction behavior</title>

  <para>
   Most of the transaction behavior are exactly same, however the below stuff is not.
  </para>

  <sect3>
   <title>Handled Statement Failure.</title>

   <programlisting>
    create table t (a int primary key, b int);
    begin;
    insert into t values(1,1);
    insert into t values(1, 1);
    commit;
   </programlisting>

   <para>
    Oracle : commit can succeed. t has 1 row after that.
   </para>

   <para>
    LightDB: commit failed due to the 2nd insert failed. so t has 0 row.
   </para>
  </sect3>

  <sect3>
   <title>DML with Subquery</title>

   <para>
    Case 1:
   </para>

   <programlisting>
    create table dml(a int, b int);
    insert into dml values(1, 1), (2,2);

    -- session 1:
    begin;
    delete from dml where a in (select min(a) from dml);

    --session 2:
    delete from dml where a in (select min(a) from dml);

    -- session 1:
    commit;
   </programlisting>

   <para>
    In Oracle: 1 row deleted in sess 2. so 0 rows in the dml at last.
   </para>

   <para>
    In LightDB: 0 rows are deleted in sess 2, so 1 rows in the dml at last.
   </para>

   <para>
    Oracle probably detects the min(a) is changed and rollback/rerun the statement.
   </para>

   <para>
    The same reason can cause the below difference as well.
   </para>

   <programlisting>
    create table su (a int, b int);
    insert into su values(1, 1);

    - session 1:
    begin;
    update su set b = 2 where b = 1;

    - sess 2:
    select * from su where a in (select a from su where b = 1) for update;

    - sess 1:
    commit;
   </programlisting>

   <para>
    In Oracle, 0 row is selected. In LightDB, 1 row (1, 2) is selected.
   </para>

   <para>
    A best practice would be never use subquery in DML &amp; SLEECT ... FOR UPDATE. Even
    in Oracle, the behavior is inconsistent as well. Oracle between 11.2.0.1 and 11.2.0.3
    probably behavior same as LightDB, but other versions not.
   </para>
  </sect3>
 </sect2>

 <sect2>
  <title>System View Reference</title>

   <para>
    These views are based on oracle 11g, but some views include some fields from the new version.
   </para>

   <para>
    Views are created under oracle and sys schema.
   </para>
   <para>
    In order to be compatible with oracle, the following views have the same fields as the corresponding views in oracle
    , but return NULL for those fields whose field values cannot be obtained or are difficult to obtain.
   </para>

   <para>
    The supported fields are listed below. Some fields have different meanings from oracle.
   </para>

  <sect3>
   <title>[DBA/ALL/USER]_SEQUENCES</title>
   
   <itemizedlist>
   <listitem>    
   <para>
    DBA_SEQUENCES describes all sequences in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_SEQUENCES view is currently the same as the DBA_SEQUENCES view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_SEQUENCES describes all sequences owned by the current user.
   </para>
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_SEQUENCES</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        SEQUENCE_OWNER
       </para>
      </entry>
      <entry>
       <para>
        Owner of the sequence
        </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SEQUENCE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Sequence name
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        MIN_VALUE
       </para>
      </entry>
      <entry>
       <para>
        Minimum value of the sequence
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        MAX_VALUE
       </para>
      </entry>
      <entry>
       <para>
        Maximum value of the sequence
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        INCREMENT_BY
       </para>
      </entry>
      <entry>
       <para>
       Value by which sequence is incremented
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        CYCLE_FLAG
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether the sequence wraps around on reaching the limit (Y) or not (N)
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        ORDER_FLAG
       </para>
      </entry>
      <entry>
       <para>
       Indicates whether sequence numbers are generated in order (Y) or not (N), Under lightdb this is always Y
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        CACHE_SIZE
       </para>
      </entry>
      <entry>
       <para>
        Number of sequence numbers to cache
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        LAST_NUMBER
       </para>
      </entry>
      <entry>
       <para>
        Last sequence number written to disk.
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_SYNONYMS</title>
   <itemizedlist>
   <listitem>  
   <para>
    SYNONYMS is not supported in LightDB yet, so these view are empty now. 
   </para>
   </listitem>
   </itemizedlist>
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_TAB_COLS, COLS, [DBA/ALL/USER]_TAB_COLUMNS</title>

   <itemizedlist>
   <listitem> 
   <para>
    DBA_TAB_COLS describes the columns of all tables, views in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_TAB_COLS view is currently the same as the DBA_TAB_COLS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_TAB_COLS describes the columns of the tables and  views owned by the current user. This view does not display the OWNER column.
   </para>
   </listitem>
   <listitem>
   <para>
    COLS is same with USER_TAB_COLS.
   </para>
   </listitem>
   <listitem>
   <para>
    DBA_TAB_COLUMNS describes the columns of all tables and views in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_TAB_COLUMNS view is currently the same as the DBA_TAB_COLUMNS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_TAB_COLUMNS describes the columns of the tables and views owned by the current user. This view does not display the OWNER column.
   </para>
   </listitem>
   <listitem>
   <para>
    [DBA/ALL/USER]_TAB_COLS view differs from [DBA/ALL/USER]_TAB_COLUMNS in that hidden columns are not filtered out(HIDDEN_COLUMN,VIRTUAL_COLUMN,SEGMENT_COLUMN_ID,INTERNAL_COLUMN_ID).
   </para>
   </listitem>
   </itemizedlist>
  <table>
   <title>ALL_TAB_COLS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER
       </para>
      </entry>
      <entry>
       <para>
        Owner of the table, view
        </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TABLE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the table, view
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        COLUMN_NAME
       </para>
      </entry>
      <entry>
       <para>
        Column name
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DATA_TYPE
       </para>
      </entry>
      <entry>
       <para>
        Datatype of the column
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DATA_TYPE_OWNER
       </para>
      </entry>
      <entry>
       <para>
       Owner of the datatype of the column
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DATA_LENGTH
       </para>
      </entry>
      <entry>
       <para>
        Length of the column (in bytes for varcahr2, in char for others)
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DATA_PRECISION
       </para>
      </entry>
      <entry>
       <para>
       Decimal precision for NUMBER datatype; binary precision for FLOAT datatype; NULL for all other datatypes
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DATA_SCALE
       </para>
      </entry>
      <entry>
       <para>
        Digits to the right of the decimal point in a number
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        NULLABLE
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether a column allows NULLs. The value is N if there is a NOT NULL constraint on the column or if the column is part of a PRIMARY KEY
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        COLUMN_ID
       </para>
      </entry>
      <entry>
       <para>
        Sequence number of the column as created
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        DEFAULT_LENGTH
       </para>
      </entry>
      <entry>
       <para>
        Default value for the column
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        NUM_DISTINCT
       </para>
      </entry>
      <entry>
       <para>
        Number of distinct values in the column
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        NUM_NULLS
       </para>
      </entry>
      <entry>
       <para>
        Number of NULLs in the column
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        AVG_COL_LEN
       </para>
      </entry>
      <entry>
       <para>
        Average length of the column (in bytes)
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        CHAR_LENGTH
       </para>
      </entry>
      <entry>
       <para>
        Displays the length of the column in characters
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        CHAR_USED
       </para>
      </entry>
      <entry>
       <para>
        Indicates that the column uses BYTE length semantics (B) or CHAR length semantics (C), or whether the datatype is not any of the following (NULL)
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_TAB_COL_STATISTICS</title>

   <itemizedlist>
   <listitem> 
   <para>
    DBA_TAB_COL_STATISTICS contains column statistics and histogram information extracted from "DBA_TAB_COLUMNS". Its columns are the same as those in "ALL_TAB_COL_STATISTICS".
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_TAB_COL_STATISTICS view is currently the same as the DBA_SEQUENCES view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_TAB_COL_STATISTICS displays such information extracted from "USER_TAB_COLUMNS". This view does not display the OWNER column.
   </para>
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_TAB_COL_STATISTICS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER
       </para>
      </entry>
      <entry>
       <para>
        Owner of the table
        </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TABLE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the table
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        COLUMN_NAME
       </para>
      </entry>
      <entry>
       <para>
        Column name
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        NUM_DISTINCT
       </para>
      </entry>
      <entry>
       <para>
        Number of distinct values in the column
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        NUM_NULLS
       </para>
      </entry>
      <entry>
       <para>
        Number of NULLs in the column
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        AVG_COL_LEN
       </para>
      </entry>
      <entry>
       <para>
        Average length of the column (in bytes)
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_OBJECTS, OBJ</title>

   <itemizedlist>
   <listitem> 
   <para>
    DBA_OBJECTS describes all objects in the database. Its columns are the same as those in "ALL_OBJECTS".
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_OBJECTS view is currently the same as the DBA_OBJECTS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_OBJECTS describes all objects owned by the current user. This view does not display the OWNER column.
   </para>
   </listitem>
   <listitem>
   <para>
     OBJ is same with USER_OBJECTS.
   </para>
   </listitem>
   </itemizedlist>
  <table>
   <title>ALL_OBJECTS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER
       </para>
      </entry>
      <entry>
       <para>
        Owner of the object
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        OBJECT_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the object
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SUBOBJECT_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the subobject (for example, partition), NULL if not exist 
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        OBJECT_ID
       </para>
      </entry>
      <entry>
       <para>
        Dictionary object number of the object
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DATA_OBJECT_ID
       </para>
      </entry>
      <entry>
       <para>
        Dictionary object number of the segment that contains the object
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        OBJECT_TYPE
       </para>
      </entry>
      <entry>
       <para>
        Type of the object
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        STATUS
       </para>
      </entry>
      <entry>
       <para>
        Status of the object: VALID, INVALID
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TEMPORARY
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether the object is temporary (the current session can see only data that it placed in this object itself) (Y) or not (N)
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_CATALOG</title>

   <itemizedlist>
   <listitem> 
   <para>
    DBA_CATALOG lists all tables, views, and sequences in the database(no cluster and synonyms). 
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_CATALOG view is currently the same as the DBA_CATALOG view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_OCATALOG displays the tables, views, and sequences in the current user's schema.
   </para>
   </listitem>
   <listitem>
   <para>
    All column in oracle view is supported.
   </para>
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_CATALOG</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER
       </para>
      </entry>
      <entry>
       <para>
        Owner of the TABLE, VIEW, SEQUENCE
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TABLE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the TABLE, VIEW, SEQUENCE
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TABLE_TYPE
       </para>
      </entry>
      <entry>
       <para>
        Type of the TABLE, VIEW, SEQUENCE
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  </sect3>

  <sect3>
   <title>DICTIONARY, DICT</title>
   
   <itemizedlist>
   <listitem> 
   <para>
    DICTIONARY/DICT contains descriptions of data dictionary tables and views.
   </para>
   </listitem>
   </itemizedlist>

  <table>
   <title>DICTIONARY</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        TABLE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the object
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        COMMENTS
       </para>
      </entry>
      <entry>
       <para>
        Text comment on the object
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_DEPENDENCIES</title>

   <itemizedlist>
   <listitem> 
   <para>
    DBA_DEPENDENCIES describes all dependencies in the database between procedures, packages, functions, package bodies, and triggers, including dependencies on views created without any database links.
    This view does not display the SCHEMAID column.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_DEPENDENCIES view is currently the same as the DBA_DEPENDENCIES view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_DEPENDENCIES describes dependencies between objects in the current user's schema. This view does not display the OWNER column.
   </para>
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_DEPENDENCIES</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER
       </para>
      </entry>
      <entry>
       <para>
        Owner of the object
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the object
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TYPE
       </para>
      </entry>
      <entry>
       <para>
        Type of the object
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        REFERENCED_OWNER
       </para>
      </entry>
      <entry>
       <para>
        Owner of the referenced object (remote owner if remote object)
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        REFERENCED_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the referenced object
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        REFERENCED_TYPE
       </para>
      </entry>
      <entry>
       <para>
        Type of the referenced object
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        DEPENDENCY_TYPE
       </para>
      </entry>
      <entry>
       <para>
        Type of the dependency
        (oracle: Indicates whether the dependency is a REF dependency (REF) or not (HARD))
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>   
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_SOURCE</title>

   <itemizedlist>
   <listitem> 
   <para>
    DBA_SOURCE describes the text source of all stored objects in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_SOURCE view is currently the same as the DBA_SOURCE view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_SOURCE describes the text source of the stored objects owned by the current user. This view does not display the OWNER column.
   </para>
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_SOURCE</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER
       </para>
      </entry>
      <entry>
       <para>
        Owner of the object
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the object
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TYPE
       </para>
      </entry>
      <entry>
       <para>
        Type of object: FUNCTION, PACKAGE, PACKAGE BODY, PROCEDURE, TRIGGER
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        LINE
       </para>
      </entry>
      <entry>
       <para>
        Line number of this line of source
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TEXT
       </para>
      </entry>
      <entry>
       <para>
        Text source of the stored object
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_PROCEDURES</title>

   <itemizedlist>
   <listitem> 
   <para>
    DBA_PROCEDURES lists all functions and procedures, along with associated properties.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_PROCEDURES view is currently the same as the DBA_PROCEDURES view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_PROCEDURES lists all functions and procedures owned by the current user, along with associated properties. It does not contain the OWNER column.
   </para>
   </listitem>
   <listitem>
   <para>
    These views indicates whether or not a function is pipelined, parallel enabled or an aggregate function. If a function is pipelined or an aggregate function, the associated implementation type (if any) is also identified.
   </para> 
   </listitem>
   </itemizedlist>

    <table>
     <title>ALL_PROCEDURES</title>
     <tgroup cols="2">
       <thead>
        <row>
         <entry>
          <para>
            Column
          </para>
         </entry>
         <entry>
          <para>
            Description
          </para>
         </entry>
        </row>
       </thead>

       <tbody>
        <row>
         <entry>
          <para>
            OWNER
          </para>
         </entry>
         <entry>
          <para>
            Owner of the procedure
          </para>
         </entry>
        </row>

        <row>
         <entry>
          <para>
            OBJECT_NAME
          </para>
         </entry>
         <entry>
          <para>
            Name of the object: top-level function, procedure, or package name
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
            OBJECT_ID
          </para>
         </entry>
         <entry>
          <para>
            Object number of the object
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
            OBJECT_TYPE
          </para>
         </entry>
         <entry>
          <para>
            The typename of the object
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
            AGGREGATE
          </para>
         </entry>
         <entry>
          <para>
            Indicates whether the procedure is an aggregate function (YES) or not (NO)
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
            PARALLEL
          </para>
         </entry>
         <entry>
          <para>
            Indicates whether the procedure or function is parallel-enabled (YES) or not (NO)
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
            DETERMINISTIC
          </para>
         </entry>
         <entry>
          <para>
            YES, if the procedure/function is declared to be deterministic; otherwise NO
          </para>
         </entry>
        </row>
        </tbody>
     </tgroup>
    </table> 
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_TRIGGERS</title>

   <itemizedlist>
   <listitem> 
   <para>
    DBA_TRIGGERS describes all triggers in the database.
   </para>
   </listitem>
   <listitem>  
   <para>
    The ALL_TRIGGERS view is currently the same as the DBA_TRIGGERS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_TRIGGERS describes the triggers owned by the current user
   </para> 
   </listitem>
   </itemizedlist>
   
   <table>
     <title>ALL_TRIGGERS</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>
          <para>
            Column
          </para>
         </entry>
         <entry>
          <para>
            Description
          </para>
         </entry>
        </row>
       </thead>

       <tbody>
        <row>
         <entry>
          <para>
            OWNER
          </para>
         </entry>
         <entry>
          <para>
            Owner of the trigger
          </para>
         </entry>
        </row>

        <row>
         <entry>
          <para>
            TRIGGER_NAME
          </para>
         </entry>
         <entry>
          <para>
            Name of the trigger
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
            TRIGGER_TYPE
          </para>
         </entry>
         <entry>
          <para>
            When the trigger fires: BEFORE STATEMENT, BEFORE EACH ROW, AFTER STATEMENT, AFTER EACH ROW, INSTEAD OF EACH ROW
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
            TRIGGERING_EVENT
          </para>
         </entry>
         <entry>
          <para>
            DML that fires the trigger 
          </para>
          </entry>
        </row>
        <row>
         <entry>
          <para>
            TABLE_OWNER
          </para>
         </entry>
         <entry>
          <para>
            Owner of the table on which the trigger is defined
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
            BASE_OBJECT_TYPE
          </para>
         </entry>
         <entry>
          <para>
            Base object on which the trigger is defined: TABLE, VIEW 
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
            TABLE_NAME
          </para>
         </entry>
         <entry>
          <para>
            Indicates the table or view name on which the trigger is defined
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
            REFERENCING_NAMES
          </para>
         </entry>
         <entry>
          <para>
            Names used for referencing OLD and NEW column values from within the trigger
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
            WHEN_CLAUSE
          </para>
         </entry>
         <entry>
          <para>
            Must evaluate to TRUE for TRIGGER_BODY to execute
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
            STATUS
          </para>
         </entry>
         <entry>
          <para>
            Indicates whether the trigger is enabled (ENABLED) or disabled (DISABLED); a disabled trigger will not fire
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
            ACTION_TYPE
          </para>
         </entry>
         <entry>
          <para>
            Action type of the trigger body: 'PL/SQL'
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
            TRIGGER_BODY
          </para>
         </entry>
         <entry>
          <para>
            Statements executed by the trigger when it fires
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
            BEFORE_STATEMENT
          </para>
         </entry>
         <entry>
          <para>
            Indicates whether the trigger has a BEFORE STATEMENT section (YES) or not (NO)
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
            BEFORE_ROW
          </para>
         </entry>
         <entry>
          <para>
            Indicates whether the trigger has a BEFORE EACH ROW section (YES) or not (NO)
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
            AFTER_ROW
          </para>
         </entry>
         <entry>
          <para>
            Indicates whether the trigger has an AFTER EACH ROW section (YES) or not (NO)
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
            AFTER_STATEMENT
          </para>
         </entry>
         <entry>
          <para>
            Indicates whether the trigger has an AFTER STATEMENT section (YES) or not (NO)
          </para>
         </entry>
        </row>
        <row>
         <entry>
          <para>
            INSTEAD_OF_ROW
          </para>
         </entry>
         <entry>
          <para>
            Indicates whether the trigger has an INSTEAD OF section (YES) or not (NO)
          </para>
         </entry>
        </row>
        </tbody>
     </tgroup>
    </table>  
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_TRIGGER_COLS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_TRIGGER_COLS describes the use of columns in all triggers in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_TRIGGER_COLS view is currently the same as the DBA_TRIGGER_COLS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_TRIGGER_COLS describes the use of columns in the triggers owned by the current user and in triggers on tables owned by the current user.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_TRIGGER_COLS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        TRIGGER_OWNER
       </para>
      </entry>
      <entry>
       <para>
        Owner of the trigger
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TRIGGER_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the trigger
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TABLE_OWNER
       </para>
      </entry>
      <entry>
       <para>
        Owner of the table on which the trigger is defined
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TABLE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Table on which the trigger is defined
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        COLUMN_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the column used in the trigger
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_TYPES</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_TYPES describes all object types in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_TYPES view is currently the same as the DBA_TYPES view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_TYPES describes the object types owned by the current user. This view does not display the OWNER column.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_TYPES</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER
       </para>
      </entry>
      <entry>
       <para>
        Owner of the type
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TYPE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the type
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TYPE_OID
       </para>
      </entry>
      <entry>
       <para>
        Object identifier (OID) of the type
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TYPECODE
       </para>
      </entry>
      <entry>
       <para>
        Typecode of the type
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        PREDEFINED
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether the type is a predefined type (YES) or not (NO)
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_CONSTRAINTS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_CONSTRAINTS describes all constraint definitions in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_CONSTRAINTS view is currently the same as the DBA_CONSTRAINTS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_CONSTRAINTS describes constraint definitions on tables in the current user's schema.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_CONSTRAINTS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER
       </para>
      </entry>
      <entry>
       <para>
        Owner of the constraint definition
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        CONSTRAINT_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the constraint definition
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        CONSTRAINT_TYPE
       </para>
      </entry>
      <entry>
       <para>
        Type of the constraint definition
       </para>
       <para>
        c - Check constraint on a table
       </para>
       <para>
        p - Primary key
       </para>
       <para>
        u - Unique key
       </para>
       <para>
        f - Constraint that involves a REF column
       </para>
       <para>
        t - Constraint triggers
       </para>
       <para>
        t - exclusivity Constraint
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TABLE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name associated with the table (or view) with the constraint definition
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        SEARCH_CONDITION
       </para>
      </entry>
      <entry>
       <para>
        Text of search condition for a check constraint
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        R_OWNER
       </para>
      </entry>
      <entry>
       <para>
        Owner of the table referred to in a referential constraint
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        DELETE_RULE
       </para>
      </entry>
      <entry>
       <para>
        Delete rule for a referential constraint: 'NO ACTION', 'RESTRICT', 'CASCADE', 'SET NULL', 'SET DEFAULT'
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        STATUS
       </para>
      </entry>
      <entry>
       <para>
        Enforcement status of the constraint: 'ENABLED', 'DISABLED'
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        DEFERRABLE
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether the constraint is deferrable (DEFERRABLE) or not (NOT DEFERRABLE)
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        DEFERRED
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether the constraint was initially deferred (DEFERRED) or not (IMMEDIATE)
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        VALIDATED
       </para>
      </entry>
      <entry>
       <para>
        Has the constraint been validated? Currently, can be false only for foreign keys and CHECK constraints
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        INDEX_OWNER
       </para>
      </entry>
      <entry>
       <para>
        Name of the user owning the index
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        INDEX_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the index (only shown for unique, primary key, foreign key, or exclusion constraint)
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        INVALID
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether the constraint is invalid (INVALID) or not (NULL)
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_CONS_COLUMNS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_CONS_COLUMNS describes all columns in the database that are specified in constraints.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_CONS_COLUMNS view is currently the same as the DBA_CONS_COLUMNS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_CONS_COLUMNS describes columns that are owned by the current user and that are specified in constraints.
   </para>
   </listitem>
   <listitem>
   <para>
    All column in oracle are supported
   </para> 
   </listitem>
   </itemizedlist>
   
  <table>
   <title>ALL_CONS_COLUMNS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER
       </para>
      </entry>
      <entry>
       <para>
        Owner of the constraint definition
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        CONSTRAINT_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the constraint definition
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TABLE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the table with the constraint definition
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        COLUMN_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the column or attribute of the object type column specified in the constraint definition
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        POSITION
       </para>
      </entry>
      <entry>
       <para>
        Original position of the column or attribute in the definition of the object
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table> 
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_VIEWS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_VIEWS describes all views in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_VIEWS view is currently the same as the DBA_VIEWS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_VIEWS describes the views owned by the current user. This view does not display the OWNER column.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_VIEWS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER
       </para>
      </entry>
      <entry>
       <para>
        Owner of the view
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        VIEW_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the view
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TEXT_LENGTH
       </para>
      </entry>
      <entry>
       <para>
        Length of the view text
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TEXT
       </para>
      </entry>
      <entry>
       <para>
        View text
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table> 
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_TABLES, [DBA/ALL/USER]_ALL_TABLES, TAB</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_ALL_TABLES describes all object tables and relational tables in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_ALL_TABLES view is currently the same as the DBA_ALL_TABLES view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_ALL_TABLES describes the object tables and relational tables owned by the current user. This view does not display the OWNER column.
   </para>
   </listitem>
   <listitem>
   <para>
    [DBA/ALL/USER]_TABLES does not display the OBJECT_ID_TYPE, TABLE_TYPE_OWNER and TABLE_TYPE column.
   </para>
   </listitem>
   <listitem>
   <para>
    [DBA/ALL/USER]_TABLES has RESULT_CACHE column, but [DBA/ALL/USER]_ALL_TABLES does not.
   </para>
   </listitem>
   <listitem>
   <para>
    TAB is same with USER_TABLES.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_ALL_TABLES</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER
       </para>
      </entry>
      <entry>
       <para>
        Owner of the table
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TABLE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the table
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TABLESPACE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the tablespace containing the table
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        LOGGING
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether or not changes to the table are logged
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        NUM_ROWS
       </para>
      </entry>
      <entry>
       <para>
        Number of rows in the table
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        BLOCKS
       </para>
      </entry>
      <entry>
       <para>
        Number of used blocks in the table
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        AVG_ROW_LEN
       </para>
      </entry>
      <entry>
       <para>
        Average row length, including row overhead
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        LAST_ANALYZED
       </para>
      </entry>
      <entry>
       <para>
        Date on which the table was most recently analyzed
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        PARTITIONED
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether the table is partitioned (YES) or not (NO)
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TEMPORARY
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether the table is temporary (Y) or not (N)
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        ROW_MOVEMENT
       </para>
      </entry>
      <entry>
       <para>
        If a partitioned table, indicates whether row movement is enabled (ENABLED) or disabled (DISABLED)
       </para>
       <para>
        Always is 'ENABLE'
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table> 
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_TAB_STATISTICS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_TAB_STATISTICS displays optimizer statistics for all tables in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_TAB_STATISTICS view is currently the same as the DBA_TAB_STATISTICS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_TAB_STATISTICS displays optimizer statistics for the tables owned by the current user. This view does not display the OWNER column.
   </para>
   </listitem>
   <listitem>
   <para>
    [DBA/ALL/USER]_TABLES does not display the OBJECT_ID_TYPE, TABLE_TYPE_OWNER and TABLE_TYPE column.
   </para>
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_TAB_STATISTICS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER
       </para>
      </entry>
      <entry>
       <para>
        Owner of the object
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TABLE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the table
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TABLESPACE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the tablespace containing the table
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        PARTITION_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the partition
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        PARTITION_POSITION
       </para>
      </entry>
      <entry>
       <para>
        Position of the partition within the table
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        OBJECT_TYPE
       </para>
      </entry>
      <entry>
       <para>
        Type of the object：TABLE, PARTIOTION, SUBPARTITION
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        NUM_ROWS
       </para>
      </entry>
      <entry>
       <para>
        Number of rows in the object
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        BLOCKS
       </para>
      </entry>
      <entry>
       <para>
        Number of used blocks in the object
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        AVG_ROW_LEN
       </para>
      </entry>
      <entry>
       <para>
        Average row length, including row overhead
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        LAST_ANALYZED
       </para>
      </entry>
      <entry>
       <para>
        Date of the most recent time the table was analyzed
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table> 
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_TAB_COMMENTS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_TAB_COMMENTS displays comments on all tables and views in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_TAB_COMMENTS view is currently the same as the DBA_TAB_COMMENTS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_TAB_COMMENTS displays comments on the tables and views owned by the current user. This view does not display the OWNER column.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_TAB_COMMENTS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER
       </para>
      </entry>
      <entry>
       <para>
        Owner of the object
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TABLE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the object
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TABLE_TYPE
       </para>
      </entry>
      <entry>
       <para>
        Type of the object
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        COMMENTS
       </para>
      </entry>
      <entry>
       <para>
        Comment on the object
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table> 
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_COL_COMMENTS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_COL_COMMENTS displays comments on the columns of all tables and views in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_COL_COMMENTS view is currently the same as the DBA_COL_COMMENTS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_COL_COMMENTS displays comments on the columns of the tables and views owned by the current user. This view does not display the OWNER column.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_COL_COMMENTS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER
       </para>
      </entry>
      <entry>
       <para>
        Owner of the object
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TABLE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the object
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        COLUMN_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the column
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        COMMENTS
       </para>
      </entry>
      <entry>
       <para>
        Name of the column
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table> 
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_TAB_MODIFICATIONS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_TAB_MODIFICATIONS describes such information for all tables in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_TAB_MODIFICATIONS view is currently the same as the DBA_TAB_MODIFICATIONS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_TAB_MODIFICATIONS describes such information for tables owned by the current user. This view does not display the TABLE_OWNER column.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_TAB_MODIFICATIONS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        TABLE_OWNER 
       </para>
      </entry>
      <entry>
       <para>
        Owner of the modified table
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TABLE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the modified table
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        INSERTS 
       </para>
      </entry>
      <entry>
       <para>
        Approximate number of inserts since the last time statistics were gathered
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        UPDATES 
       </para>
      </entry>
      <entry>
       <para>
        Approximate number of updates since the last time statistics were gathered
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        DELETES  
       </para>
      </entry>
      <entry>
       <para>
        Approximate number of deletes since the last time statistics were gathered
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TIMESTAMP  
       </para>
      </entry>
      <entry>
       <para>
        Indicates the last time the table was modified
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table> 
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_INDEXES, IND</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_INDEXES describes all indexes in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_INDEXES view is currently the same as the DBA_INDEXES view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_INDEXES describes the indexes owned by the current user. This view does not display the OWNER column.
   </para>
   </listitem>
   <listitem>
   <para>
    IND is same with USER_INDEXES.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_INDEXES</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER 
       </para>
      </entry>
      <entry>
       <para>
        Owner of the index
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        INDEX_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the index
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        INDEX_TYPE 
       </para>
      </entry>
      <entry>
       <para>
        Type of the index, always NORMAL
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TABLE_OWNER 
       </para>
      </entry>
      <entry>
       <para>
        Owner of the indexed object
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TABLE_NAME  
       </para>
      </entry>
      <entry>
       <para>
        Name of the indexed object
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TABLE_TYPE  
       </para>
      </entry>
      <entry>
       <para>
        Type of the indexed object: TABLE, VIEW, INDEX, SEQUENCE
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        UNIQUENESS  
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether the index is unique (UNIQUE) or nonunique (NONUNIQUE)
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TABLESPACE_NAME  
       </para>
      </entry>
      <entry>
       <para>
        Name of the tablespace containing the index
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        LOGGING  
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether or not changes to the index are logged: 'YES', 'NO'
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        DISTINCT_KEYS  
       </para>
      </entry>
      <entry>
       <para>
        Number of distinct indexed values
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        STATUS  
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether a nonpartitioned index is VALID or UNUSABLE
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        NUM_ROWS  
       </para>
      </entry>
      <entry>
       <para>
        Number of rows in the index
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        LAST_ANALYZED  
       </para>
      </entry>
      <entry>
       <para>
        Date on which this index was most recently analyzed
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        PARTITIONED  
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether the index is partitioned (YES) or not (NO)
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TEMPORARY  
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether the index is on a temporary table (Y) or not (N)
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_INDEX_USAGE</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_INDEX_USAGE displays cumulative statistics for each index. 
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_INDEX_USAGE view is same with DBA_INDEX_USAGE(this view is not exist in oracle). 
   </para>
   </listitem>
   <listitem>
   <para>
    USER_INDEX_USAGE describes cumulative statistics for each index owned by the current user(this view is not exist in oracle). This view does not display the OWNER column.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>DBA_INDEX_USAGE</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OBJECT_ID 
       </para>
      </entry>
      <entry>
       <para>
        Object ID for the index
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        NAME
       </para>
      </entry>
      <entry>
       <para>
        Index name
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        OWNER 
       </para>
      </entry>
      <entry>
       <para>
        Index owner
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TOTAL_ACCESS_COUNT 
       </para>
      </entry>
      <entry>
       <para>
        Total number of times the index has been accessed
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TOTAL_ROWS_RETURNED  
       </para>
      </entry>
      <entry>
       <para>
        Total rows returned by the index
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_IND_COLUMNS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_IND_COLUMNS describes the columns of indexes on all tables in the database. 
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_IND_COLUMNS view is currently the same as the DBA_IND_COLUMNS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_IND_COLUMNS describes the columns of indexes owned by the current user and columns of indexes on tables owned by the current user. This view does not display the INDEX_OWNER or TABLE_OWNER columns.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_IND_COLUMNS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        INDEX_OWNER 
       </para>
      </entry>
      <entry>
       <para>
        Owner of the index
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        INDEX_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the index
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TABLE_OWNER 
       </para>
      </entry>
      <entry>
       <para>
        Owner of the table
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TABLE_NAME 
       </para>
      </entry>
      <entry>
       <para>
        Name of the table
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        COLUMN_NAME  
       </para>
      </entry>
      <entry>
       <para>
        Column name or attribute of the object type column
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        COLUMN_POSITION  
       </para>
      </entry>
      <entry>
       <para>
        Position of the column or attribute within the index
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        COLUMN_LENGTH  
       </para>
      </entry>
      <entry>
       <para>
        Indexed length of the column
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        CHAR_LENGTH  
       </para>
      </entry>
      <entry>
       <para>
        Maximum codepoint length of the column
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        DESCEND   
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether the column is sorted in descending order (DESC) or ascending order (ASC)
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_IND_EXPRESSIONS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_IND_EXPRESSIONS describes the expressions of all function-based indexes in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_IND_EXPRESSIONS view is currently the same as the DBA_IND_COLUMNS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_IND_EXPRESSIONS describes the expressions of function-based indexes on tables owned by the current user. This view does not display the INDEX_OWNER or TABLE_OWNER columns.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_IND_EXPRESSIONS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        INDEX_OWNER 
       </para>
      </entry>
      <entry>
       <para>
        Owner of the index
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        INDEX_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the index
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TABLE_OWNER 
       </para>
      </entry>
      <entry>
       <para>
        Owner of the table
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TABLE_NAME 
       </para>
      </entry>
      <entry>
       <para>
        Name of the table
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        COLUMN_EXPRESSION  
       </para>
      </entry>
      <entry>
       <para>
        Function-based index expression defining the column
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        COLUMN_POSITION  
       </para>
      </entry>
      <entry>
       <para>
        Position of the column or attribute within the index
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_IND_STATISTICS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_IND_STATISTICS displays optimizer statistics for all indexes in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_IND_STATISTICS view is currently the same as the DBA_IND_STATISTICS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_IND_STATISTICS displays optimizer statistics for the indexes on the tables owned by the current user. This view does not display the OWNER column.
   </para>
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_IND_STATISTICS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER 
       </para>
      </entry>
      <entry>
       <para>
        Owner of the index
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        INDEX_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the index
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TABLE_OWNER 
       </para>
      </entry>
      <entry>
       <para>
        Owner of the indexed object
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TABLE_NAME 
       </para>
      </entry>
      <entry>
       <para>
        Name of the indexed object
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        PARTITION_NAME  
       </para>
      </entry>
      <entry>
       <para>
        Function-based index expression defining the column
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        PARTITION_POSITION  
       </para>
      </entry>
      <entry>
       <para>
        Position of the column or attribute within the index
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        OBJECT_TYPE  
       </para>
      </entry>
      <entry>
       <para>
        Type of the object:INDEX, PARTITION
       </para>
       <para>
        Always 'INDEX' now, because this view will not to get partition info 
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        DISTINCT_KEYS  
       </para>
      </entry>
      <entry>
       <para>
        Number of distinct keys in the index
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        NUM_ROWS  
       </para>
      </entry>
      <entry>
       <para>
        Number of rows in the index
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        LAST_ANALYZED  
       </para>
      </entry>
      <entry>
       <para>
        Date of the most recent time the index was analyzed
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_USERS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_USERS describes all users of the database, and contains more columns than ALL_USERS.
   </para>
   </listitem>
   <listitem>
   <para>
    ALL_USERS lists all users of the database(USERNAME, USER_ID, CREATED), but no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_USERS describes the current user, and contains more columns than ALL_USERS.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>DBA_USERS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        USERNAME 
       </para>
      </entry>
      <entry>
       <para>
        Name of the user
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        USER_ID
       </para>
      </entry>
      <entry>
       <para>
        ID number of the user
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        PASSWORD 
       </para>
      </entry>
      <entry>
       <para>
        This column is deprecated in favor of the AUTHENTICATION_TYPE column
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        ACCOUNT_STATUS 
       </para>
      </entry>
      <entry>
       <para>
        Account status, always 'NORMAL'
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        EXPIRY_DATE  
       </para>
      </entry>
      <entry>
       <para>
        Date of expiration of the account
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table>
   <title>ALL_USERS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        USERNAME 
       </para>
      </entry>
      <entry>
       <para>
        Name of the user
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        USER_ID
       </para>
      </entry>
      <entry>
       <para>
        ID number of the user
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>DBA_ROLES</title>

   <itemizedlist>
   <listitem>
   <para>
    Describes all roles in the database
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>DBA_ROLES</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        ROLE 
       </para>
      </entry>
      <entry>
       <para>
        Name of the role
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        PASSWORD_REQUIRED
       </para>
      </entry>
      <entry>
       <para>
        This column is deprecated in favor of the AUTHENTICATION_TYPE column, always 'NO'
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        AUTHENTICATION_TYPE
       </para>
      </entry>
      <entry>
       <para>
        Indicates the authentication mechanism for the role, always 'NONE'
       </para>
       <para>
        NONE - CREATE ROLE role1;
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        COMMON
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether a given role is common. always 'YES', does not exist in oracle 11g
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/USER]_ROLE_PRIVS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_ROLE_PRIVS describes the roles granted to all users and roles in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_ROLE_PRIVS describes the roles granted to the current user.
   </para> 
   </listitem>
   </itemizedlist>


  <table>
   <title>DBA_ROLE_PRIVS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        GRANTEE 
       </para>
      </entry>
      <entry>
       <para>
        Name of the user or role receiving the grant
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        GRANTED_ROLE
       </para>
      </entry>
      <entry>
       <para>
        Granted role name
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        ADMIN_OPTION
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether the grant was with the ADMIN OPTION (YES) or not (NO)
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        DEFAULT_ROLE
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether the role is designated as a DEFAULT ROLE for the user (YES) or not (NO)
       </para>
       <para>
        Always 'NO'
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        COMMON
       </para>
      </entry>
      <entry>
       <para>
        Indicates how the grant was made
       </para>
       <para>
        always 'YES', does not exist in oracle 11g
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>PRODUCT_COMPONENT_VERSION</title>

   <itemizedlist>
   <listitem>
   <para>
    Contains version and status information for component products.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>PRODUCT_COMPONENT_VERSION</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        PRODUCT 
       </para>
      </entry>
      <entry>
       <para>
        Product name
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        VERSION
       </para>
      </entry>
      <entry>
       <para>
        Version number
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        STATUS
       </para>
      </entry>
      <entry>
       <para>
        Status of release
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>PLAN_TABLE</title>

   <itemizedlist>
   <listitem>
   <para>
    PLAN_TABLE is automatically created as a global temporary table to hold the output of an EXPLAIN PLAN statement for all users.
   </para>
   </listitem>
   <listitem>
   <para>
    it is not supported by LightDB, so this view is empty for compatibility.
   </para> 
   </listitem>
   </itemizedlist>

  </sect3>

  <sect3>
   <title>DBA_DATA_FILES</title>

   <itemizedlist>
   <listitem>
   <para>
    Describes database files
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>DBA_DATA_FILES</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        FILE_NAME 
       </para>
      </entry>
      <entry>
       <para>
        Name of the database file
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        FILE_ID
       </para>
      </entry>
      <entry>
       <para>
        File identifier number of the database file
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TABLESPACE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the tablespace to which the file belongs
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        BYTES
       </para>
      </entry>
      <entry>
       <para>
        Size of the file in bytes
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        BLOCKS
       </para>
      </entry>
      <entry>
       <para>
        Size of the file in Oracle blocks
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        STATUS
       </para>
      </entry>
      <entry>
       <para>
        File status: AVAILABLE or INVALID 
       </para>
       <para>
        Always 'AVAILABLE'
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        RELATIVE_FNO
       </para>
      </entry>
      <entry>
       <para>
        Relative file number
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        AUTOEXTENSIBLE
       </para>
      </entry>
      <entry>
       <para>
        Autoextensible indicator
       </para>
       <para>
        Always 'YES'
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        INCREMENT_BY
       </para>
      </entry>
      <entry>
       <para>
        Number of Oracle blocks used as autoextension increment
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        ONLINE_STATUS
       </para>
      </entry>
      <entry>
       <para>
        Online status of the file
       </para>
       <para>
        Always 'ONLINE'
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_JOBS</title>

   <itemizedlist>
   <listitem>
   <para>
    Get info from <link linkend="pgcron">lt_cron</link>
   </para>
   </listitem>
   <listitem>
   <para>
    DBA_JOBS describes all jobs in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_JOBS describes the jobs owned by the current user.
   </para>
   </listitem>
   <listitem>
   <para>
    ALL_JOBS is same with USER_JOBS.
   </para> 
   </listitem>
   </itemizedlist>


  <table>
   <title>DBA_JOBS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        JOB 
       </para>
      </entry>
      <entry>
       <para>
        Identifier of job
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        LOG_USER
       </para>
      </entry>
      <entry>
       <para>
        Login user when the job was submitted
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        PRIV_USER
       </para>
      </entry>
      <entry>
       <para>
        User whose default privileges apply to this job
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        SCHEMA_USER
       </para>
      </entry>
      <entry>
       <para>
        Default schema used to parse the job 
       </para>
       <para>
        Always 'CRON' 
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        LAST_DATE
       </para>
      </entry>
      <entry>
       <para>
        Date on which this job last successfully executed
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        LAST_SEC
       </para>
      </entry>
      <entry>
       <para>
        Same as LAST_DATE. This is when the last successful execution started
       </para>
       <para>
        'HH24:MI:SS' format
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        THIS_DATE
       </para>
      </entry>
      <entry>
       <para>
        Date that this job started executing (usually null if not executing)
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        THIS_SEC
       </para>
      </entry>
      <entry>
       <para>
        Same as THIS_DATE. This is when the last successful execution started
       </para>
       <para>
        'HH24:MI:SS' format
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TOTAL_TIME
       </para>
      </entry>
      <entry>
       <para>
        Total wall clock time spent by the system on this job in the last ececuted
       </para>
       <para>
        It is not same with oracle. In oracle, it means total wall clock time spent by the system on this job (in seconds) since the first time this job executed, and this value is cumulative
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        BROKEN
       </para>
      </entry>
      <entry>
       <para>
        Y: no attempt is made to run this job, N: an attempt is made to run this job
       </para>
       <para>
        Always 'N'
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        INTERVAL
       </para>
      </entry>
      <entry>
       <para>
         String uses the standard cron syntax, ref to <link linkend="pgcron">lt_cron</link>
       </para>
       <para>
        Different from oracle
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        WHAT
       </para>
      </entry>
      <entry>
       <para>
        LightDB commands
       </para>
       <para>
        Different from oracle
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>DBA_JOBS_RUNNING</title>

   <itemizedlist>
   <listitem>
   <para>
    Get info from <link linkend="pgcron">lt_cron</link>
   </para>
   </listitem>
   <listitem>

   <para>
    Lists all jobs that are currently running in the instance.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>DBA_JOBS_RUNNING</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        SID 
       </para>
      </entry>
      <entry>
       <para>
        Identifier of process that is executing the job
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        JOB
       </para>
      </entry>
      <entry>
       <para>
        Identifier of job. This job is currently executing
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        LAST_DATE
       </para>
      </entry>
      <entry>
       <para>
        Date on which this job last successfully executed
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        LAST_SEC
       </para>
      </entry>
      <entry>
       <para>
        Same as LAST_DATE. This is when the last successful execution started
       </para>
       <para>
        'HH24:MI:SS' format
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        THIS_DATE
       </para>
      </entry>
      <entry>
       <para>
        Date that this job started executing (usually null if not executing)
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        THIS_SEC
       </para>
      </entry>
      <entry>
       <para>
        Same as THIS_DATE. This is when the last successful execution started
       </para>
       <para>
        'HH24:MI:SS' format
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_MVIEWS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_MVIEWS describes all materialized views in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_MVIEWS view is currently the same as the DBA_MVIEWS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_MVIEWS describes all materialized views owned by the current user.
   </para> 
   </listitem>
   </itemizedlist>


  <table>
   <title>ALL_MVIEWS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER 
       </para>
      </entry>
      <entry>
       <para>
        Schema in which the materialized view was created
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        MVIEW_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the materialized view
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        CONTAINER_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the container in which the materialized view's data is held. Normally this is the same as MVIEW_NAME
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        QUERY
       </para>
      </entry>
      <entry>
       <para>
        Query that defines the materialized view
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        QUERY_LEN
       </para>
      </entry>
      <entry>
       <para>
        Length (in bytes) of the defining query
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        UPDATABLE
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether the materialized view is updatable (Y) or not (N)
       </para>
       <para>
        Always 'N'
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        REFRESH_MODE
       </para>
      </entry>
      <entry>
       <para>
        Refresh mode of the materialized view
       </para>
       <para>
        Always 'DEMAND', it means database refreshes this materialized view whenever an appropriate refresh procedure is called
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        REFRESH_METHOD
       </para>
      </entry>
      <entry>
       <para>
        Default method used to refresh the materialized view
       </para>
       <para>
        Always 'COMPLETE'
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        BUILD_MODE
       </para>
      </entry>
      <entry>
       <para>
        Indicates how the materialized view was populated during creation
       </para>
       <para>
        Always 'IMMEDIATE'
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_MVIEW_LOGS</title>

   <itemizedlist>
   <listitem>
   <para>
    It is not supported, so use as an empty view for compatibility.
   </para>
   </listitem>
   <listitem>
   <para>
    DBA_MVIEW_LOGS describes all materialized view logs in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    ALL_MVIEW_LOGS describes all materialized view logs accessible to the current user.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_MVIEW_LOGS describes all materialized view logs owned by the current user.
   </para> 
   </listitem>
   </itemizedlist>

  </sect3>

  <sect3>
   <title>[DBA/ALL/USER]_MVIEW_COMMENTS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_MVIEW_COMMENTS displays comments on the materialized views in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_MVIEW_COMMENTS view is currently the same as the DBA_MVIEW_COMMENTS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_MVIEW_COMMENTS displays comments on the materialized views owned by the current user. This view does not display the OWNER column.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_MVIEW_COMMENTS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER 
       </para>
      </entry>
      <entry>
       <para>
        Owner of the materialized view
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        MVIEW_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the materialized view
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        COMMENTS
       </para>
      </entry>
      <entry>
       <para>
        Comment on the materialized view
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/USER]_TABLESPACES</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_TABLESPACES describes all tablespaces in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_TABLESPACES describes the tablespaces accessible to the current user. This view does not display the PLUGGED_IN column.
   </para> 
   </listitem>
   </itemizedlist>


  <table>
   <title>DBA_TABLESPACES</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        TABLESPACE_NAME 
       </para>
      </entry>
      <entry>
       <para>
        Name of the tablespace
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        BLOCK_SIZE
       </para>
      </entry>
      <entry>
       <para>
        Tablespace block size (in bytes)
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        STATUS
       </para>
      </entry>
      <entry>
       <para>
        Tablespace status
       </para>
       <para>
        Always 'ONLINE'
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        CONTENTS
       </para>
      </entry>
      <entry>
       <para>
        Tablespace contents
       </para>
       <para>
        Always 'PERMANENT'
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>NLS_[DATABASE/INSTANCE/SESSION]_PARAMETERS</title>

   <itemizedlist>
   <listitem>
   <para>
    NLS_DATABASE_PARAMETERS lists permanent NLS parameters of the database.
   </para>
   </listitem>
   <listitem>
   <para>
    NLS_INSTANCE_PARAMETERS lists NLS parameters of the instance.
   </para>
   </listitem>
   <listitem>
   <para>
    NLS_SESSION_PARAMETERS lists NLS parameters of the user session.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>NLS_DATABASE_PARAMETERS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        PARAMETER 
       </para>
      </entry>
      <entry>
       <para>
        Parameter name
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        VALUE
       </para>
      </entry>
      <entry>
       <para>
        Parameter value
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/USER]_SEGMENTS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_SEGMENTS describes the storage allocated for all segments in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_SEGMENTS describes the storage allocated for the segments owned by the current user's objects. This view does not display the OWNER, HEADER_FILE, HEADER_BLOCK, or RELATIVE_FNO columns.
   </para> 
   </listitem>
   </itemizedlist>


  <table>
   <title>DBA_SEGMENTS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER 
       </para>
      </entry>
      <entry>
       <para>
        Username of the segment owner
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SEGMENT_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name, if any, of the segment
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        PARTITION_NAME
       </para>
      </entry>
      <entry>
       <para>
        Object Partition Name (Set to NULL for non-partitioned objects)
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        SEGMENT_TYPE
       </para>
      </entry>
      <entry>
       <para>
        Type of segment:'TABLE', 'TABLE PARTITION', 'TABLE SUBPARTITION', 'INDEX', 'INDEX PARTITION', 'INDEX SUBPARTITION'
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        TABLESPACE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the tablespace containing the segment
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        HEADER_FILE
       </para>
      </entry>
      <entry>
       <para>
        Name of the tablespace containing the segment
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        BYTES
       </para>
      </entry>
      <entry>
       <para>
        Size, in bytes, of the segments
       </para>
      </entry>
     </row>
     <row>
      <entry>
       <para>
        BLOCKS
       </para>
      </entry>
      <entry>
       <para>
        Size, in LightDB blocks, of the segment
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/USER/ALL]_PART_TABLES</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_PART_TABLES displays the object-level partitioning information for all partitioned tables in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_PART_TABLES view is currently the same as the DBA_PART_TABLES view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_PART_TABLES displays the object-level partitioning information for the partitioned tables owned by the current user. This view does not display the OWNER column.
   </para>

   <para>
    The supported fields are listed below. unsupported fields are filed with NULL.
   </para>

   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_PART_TABLES</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER 
       </para>
      </entry>
      <entry>
       <para>
        Owner of the partitioned table
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TABLE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the partitioned table
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        PARTITIONING_TYPE
       </para>
      </entry>
      <entry>
       <para>
        Type of the partitioning method: RANGE, HASH, LIST
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SUBPARTITIONING_TYPE
       </para>
      </entry>
      <entry>
       <para>
        Type of the composite partitioning method: RANGE, HASH, LIST
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        PARTITION_COUNT
       </para>
      </entry>
      <entry>
       <para>
        Number of partitions in the table
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        PARTITIONING_KEY_COUNT
       </para>
      </entry>
      <entry>
       <para>
        Number of columns in the partitioning key
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SUBPARTITIONING_KEY_COUNT
       </para>
      </entry>
      <entry>
       <para>
        For a composite-partitioned table, the number of columns in the subpartitioning key
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DEF_TABLESPACE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Default tablespace to be used when adding a partition
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DEF_LOGGING
       </para>
      </entry>
      <entry>
       <para>
        Default LOGGING attribute to be used when adding a partition
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/USER/ALL]_TAB_PARTITIONS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_TAB_PARTITIONS displays partition-level partitioning information, partition storage parameters, and partition statistics for all partitions in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_TAB_PARTITIONS view is currently the same as the DBA_TAB_PARTITIONS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_TAB_PARTITIONS displays such information for the partitions of all partitioned objects owned by the current user. This view does not display the TABLE_OWNER column.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_TAB_PARTITIONS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        TABLE_OWNER 
       </para>
      </entry>
      <entry>
       <para>
        Owner of the table
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TABLE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the table
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        COMPOSITE
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether the table is composite-partitioned (YES) or not (NO)
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        PARTITION_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the partition
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SUBPARTITION_COUNT
       </para>
      </entry>
      <entry>
       <para>
        If this is a composite partitioned table, the number of subpartitions in the partition
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        PARTITION_POSITION
       </para>
      </entry>
      <entry>
       <para>
        Position of the partition within the table
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TABLESPACE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the tablespace containing the partition
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        LOGGING
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether or not changes to the table are logged
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        NUM_ROWS
       </para>
      </entry>
      <entry>
       <para>
        Number of rows in the partition
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        BLOCKS
       </para>
      </entry>
      <entry>
       <para>
        Number of used data blocks in the partition
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        LAST_ANALYZED
       </para>
      </entry>
      <entry>
       <para>
        Date on which this partition was most recently analyzed
       </para>
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/USER/ALL]_TAB_SUBPARTITIONS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_TAB_SUBPARTITIONS displays the subpartition name, name of the table and partition to which it belongs, its storage attributes, and statistics for all subpartitions in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_TAB_SUBPARTITIONS view is currently the same as the DBA_TAB_SUBPARTITIONS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_TAB_SUBPARTITIONS displays such information for subpartitions of all partitioned objects owned by the current user. This view does not display the TABLE_OWNER column. 
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_TAB_SUBPARTITIONS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        TABLE_OWNER 
       </para>
      </entry>
      <entry>
       <para>
        Owner of the table
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TABLE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the table
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        PARTITION_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the partition
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SUBPARTITION_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the subpartition
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        PARTITION_POSITION
       </para>
      </entry>
      <entry>
       <para>
        Position of the partition within the table
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SUBPARTITION_POSITION
       </para>
      </entry>
      <entry>
       <para>
        Position of the subpartition within the partition
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TABLESPACE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the tablespace containing the partition
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        LOGGING
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether or not changes to the table are logged
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        NUM_ROWS
       </para>
      </entry>
      <entry>
       <para>
        Number of rows in the subpartition
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        BLOCKS
       </para>
      </entry>
      <entry>
       <para>
        Number of blocks in the subpartition
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        LAST_ANALYZED
       </para>
      </entry>
      <entry>
       <para>
        Date on which this table was most recently analyzed
       </para>
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/USER/ALL]_PART_KEY_COLUMNS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_PART_KEY_COLUMNS describes the partitioning key columns for all partitioned objects in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_PART_KEY_COLUMNS view is currently the same as the DBA_PART_KEY_COLUMNS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_PART_KEY_COLUMNS describes the partitioning key columns for the partitioned objects owned by the current user. This view does not display the OWNER column.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_PART_KEY_COLUMNS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER 
       </para>
      </entry>
      <entry>
       <para>
        Owner of the partitioned table or index
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the partitioned table or index
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        OBJECT_TYPE
       </para>
      </entry>
      <entry>
       <para>
        Object type: TABLE, INDEX
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        COLUMN_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the column
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        COLUMN_POSITION
       </para>
      </entry>
      <entry>
       <para>
        Position of the column within the partitioning key
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/USER/ALL]_SUBPART_KEY_COLUMNS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_SUBPART_KEY_COLUMNS displays subpartitioning key columns for composite-partitioned tables (and local indexes on composite-partitioned tables) for all subpartitions in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_SUBPART_KEY_COLUMNS view is currently the same as the DBA_SUBPART_KEY_COLUMNS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_SUBPART_KEY_COLUMNS displays this information for subpartitions of all partitioned objects owned by the current user. This view does not display the OWNER column.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_SUBPART_KEY_COLUMNS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER 
       </para>
      </entry>
      <entry>
       <para>
        Owner of the partitioned table or index
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the partitioned table or index
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        OBJECT_TYPE
       </para>
      </entry>
      <entry>
       <para>
        Object type: TABLE, INDEX
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        COLUMN_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the column
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        COLUMN_POSITION
       </para>
      </entry>
      <entry>
       <para>
        Position of the column within the subpartitioning key
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/USER/ALL]_IND_PARTITIONS</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_IND_PARTITIONS describes all index partitions in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_IND_PARTITIONS view is currently the same as the DBA_IND_PARTITIONS view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_IND_PARTITIONS describes the index partitions owned by the current user. This view does not display the INDEX_OWNER column.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_IND_PARTITIONS</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        INDEX_OWNER 
       </para>
      </entry>
      <entry>
       <para>
        Owner of the index
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        INDEX_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the index
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        COMPOSITE
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether the partition belongs to a local index on a composite-partitioned table (YES) or not (NO)
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        PARTITION_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the partition
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SUBPARTITION_COUNT
       </para>
      </entry>
      <entry>
       <para>
        If a local index on a composite-partitioned table, the number of subpartitions in the partition
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        PARTITION_POSITION
       </para>
      </entry>
      <entry>
       <para>
        Position of the partition within the index
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TABLESPACE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the tablespace containing the partition
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        LOGGING
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether or not changes to the index are logged
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        NUM_ROWS
       </para>
      </entry>
      <entry>
       <para>
        Number of rows returned
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        LAST_ANALYZED
       </para>
      </entry>
      <entry>
       <para>
        Date on which this partition was most recently analyzed
       </para>
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>
  </sect3>

  <sect3>
   <title>[DBA/USER/ALL]_PART_INDEXES</title>

   <itemizedlist>
   <listitem>
   <para>
    DBA_PART_INDEXES displays the object-level partitioning information for all partitioned indexes in the database.
   </para>
   </listitem>
   <listitem>
   <para>
    The ALL_PART_INDEXES view is currently the same as the DBA_PART_INDEXES view, and no permission verification is done like oracle.
   </para>
   </listitem>
   <listitem>
   <para>
    USER_PART_INDEXES displays the object-level partitioning information for the partitioned indexes owned by the current user. This view does not display the OWNER column.
   </para> 
   </listitem>
   </itemizedlist>

  <table>
   <title>ALL_PART_INDEXES</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>
       <para>
        Column
       </para>
      </entry>
      <entry>
       <para>
        Description
       </para>
      </entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <para>
        OWNER 
       </para>
      </entry>
      <entry>
       <para>
        Owner of the partitioned index
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        INDEX_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the partitioned index
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        TABLE_NAME
       </para>
      </entry>
      <entry>
       <para>
        Name of the partitioned table
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        PARTITIONING_TYPE
       </para>
      </entry>
      <entry>
       <para>
        Type of the partitioning method: RANGE, HASH, LIST
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SUBPARTITIONING_TYPE
       </para>
      </entry>
      <entry>
       <para>
        Type of the composite partitioning method: RANGE, HASH, LIST
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        PARTITION_COUNT
       </para>
      </entry>
      <entry>
       <para>
        Number of partitions in the index
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        PARTITIONING_KEY_COUNT
       </para>
      </entry>
      <entry>
       <para>
        Number of columns in the partitioning key
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        SUBPARTITIONING_KEY_COUNT
       </para>
      </entry>
      <entry>
       <para>
        For a composite-partitioned table, the number of columns in the subpartitioning key
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        LOCALITY
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether the partitioned index is local (LOCAL) or global (GLOBAL), always 'LOCAL'
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        ALIGNMENT
       </para>
      </entry>
      <entry>
       <para>
        Indicates whether the partitioned index is prefixed (PREFIXED) or non-prefixed (NON_PREFIXED)
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DEF_TABLESPACE_NAME
       </para>
      </entry>
      <entry>
       <para>
        For a local index, the default tablespace to be used when adding or splitting a table partition
       </para>
      </entry>
     </row>

     <row>
      <entry>
       <para>
        DEF_LOGGING
       </para>
      </entry>
      <entry>
       <para>
        For a local index, the default LOGGING attribute to be used when adding a table partition
       </para>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
  </sect3>

 </sect2>

</sect1>

