<sect1 id="lt_pathman">
  <title>lt_pathman</title>
  <para>
    The <literal>lt_pathman</literal> module provides optimized
    partitioning mechanism and functions to manage partitions.
  </para>
  <sect2 id="pg-pathman-overview">
    <title>Overview</title>
    <para>
      <emphasis role="strong">Partitioning</emphasis> means splitting
      one large table into smaller pieces. Each row in such table is
      moved to a single partition according to the partitioning key.
    </para>
    <para>
      LightDB provides native partitioning:
    </para>
    <programlisting>
CREATE TABLE test(id int4, value text) PARTITION BY RANGE(id);
CREATE TABLE test_1 PARTITION OF test FOR VALUES FROM (1) TO (10);
CREATE TABLE test_2 PARTITION OF test FOR VALUES FROM (10) TO (20);
</programlisting>
    <para>
      It’s not so different from the classic approach; there are
      implicit check constraints, and most of its limitations are still
      relevant.
    </para>
    <para>
      Despite the flexibility, this approach forces the planner to
      perform an exhaustive search and to check constraints on each
      partition to determine whether it should be present in the plan or
      not. Large amount of partitions may result in significant planning
      overhead.
    </para>
    <para>
      The <literal>lt_pathman</literal> module features partition
      managing functions and optimized planning mechanism which utilizes
      knowledge of the partitions’ structure. It stores partitioning
      configuration in the <literal>pathman_config</literal> table; each
      row contains a single entry for a partitioned table (relation
      name, partitioning column and its type). During the initialization
      stage the <literal>lt_pathman</literal> module caches some
      information about child partitions in the shared memory, which is
      used later for plan construction. Before a SELECT query is
      executed, <literal>lt_pathman</literal> traverses the condition
      tree in search of expressions like:
    </para>
    <programlisting>
VARIABLE OP CONST
</programlisting>
    <para>
      where <literal>VARIABLE</literal> is a partitioning key,
      <literal>OP</literal> is a comparison operator (supported
      operators are =, &lt;, &lt;=, &gt;, &gt;=),
      <literal>CONST</literal> is a scalar value. For example:
    </para>
    <programlisting>
WHERE id = 150
</programlisting>
    <para>
      Based on the partitioning type and condition’s operator,
      <literal>lt_pathman</literal> searches for the corresponding
      partitions and builds the plan. Currently
      <literal>lt_pathman</literal> supports two partitioning schemes:
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          <emphasis role="strong">RANGE</emphasis> - maps rows to
          partitions using partitioning key ranges assigned to each
          partition. Optimization is achieved by using the binary search
          algorithm;
        </para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="strong">HASH</emphasis> - maps rows to
          partitions using a generic hash function.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      More interesting features are yet to come. Stay tuned!
    </para>
  </sect2>
  <sect2 id="feature-highlights">
    <title>Feature highlights</title>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          HASH and RANGE partitioning schemes;
        </para>
      </listitem>
      <listitem>
        <para>
          Partitioning by expression and composite key;
        </para>
      </listitem>
      <listitem>
        <para>
          Both automatic and manual
          <link linkend="post-creation-partition-management">partition
          management</link>;
        </para>
      </listitem>
      <listitem>
        <para>
          Support for integer, floating point, date and other types,
          including domains;
        </para>
      </listitem>
      <listitem>
        <para>
          Effective query planning for partitioned tables (JOINs,
          subselects etc);
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>RuntimeAppend</literal> &amp;
          <literal>RuntimeMergeAppend</literal> custom plan nodes to
          pick partitions at runtime;
        </para>
      </listitem>
      <listitem>
        <para>
          <link linkend="custom-plan-nodes"><literal>PartitionFilter</literal></link>:
          an efficient drop-in replacement for INSERT triggers;
        </para>
      </listitem>
      <listitem>
        <para>
          <link linkend="custom-plan-nodes"><literal>PartitionRouter</literal></link>
          and
          <link linkend="custom-plan-nodes"><literal>PartitionOverseer</literal></link>
          for cross-partition UPDATE queries (instead of triggers);
        </para>
      </listitem>
      <listitem>
        <para>
          Automatic partition creation for new INSERTed data (only for
          RANGE partitioning);
        </para>
      </listitem>
      <listitem>
        <para>
          Improved <literal>COPY FROM</literal> statement that is able
          to insert rows directly into partitions;
        </para>
      </listitem>
      <listitem>
        <para>
          <link linkend="additional-parameters">User-defined
          callbacks</link> for partition creation event handling;
        </para>
      </listitem>
      <listitem>
        <para>
          Non-blocking <link linkend="data-migration">concurrent table
          partitioning</link>;
        </para>
      </listitem>
      <listitem>
        <para>
          FDW support (foreign partitions);
        </para>
      </listitem>
      <listitem>
        <para>
          Various <link linkend="disabling-lt_pathman">GUC</link>
          toggles and configurable settings.
        </para>
      </listitem>
      <listitem>
        <para>
          Partial support of
          <link linkend="declarative-partitioning"><literal>declarative partitioning</literal></link>
          .
        </para>
      </listitem>
    </itemizedlist>
  </sect2>
  <sect2 id="available-functions">
    <title>Available functions</title>
    <sect3 id="modules-version">
      <title>Module’s version</title>
      <programlisting>
pathman_version()
</programlisting>
      <para>
        This function returns a complete version number of the loaded
        lt_pathman module in <literal>MAJOR.MINOR.PATCH</literal>
        format.
      </para>
    </sect3>
    <sect3 id="partition-creation">
      <title>Partition creation</title>
      <programlisting>
create_hash_partitions(parent_relid     REGCLASS,
                       expression       TEXT,
                       partitions_count INTEGER,
                       partition_data   BOOLEAN DEFAULT TRUE,
                       partition_names  TEXT[] DEFAULT NULL,
                       tablespaces      TEXT[] DEFAULT NULL)
</programlisting>
      <para>
        Performs HASH partitioning for <literal>relation</literal> by
        partitioning expression <literal>expr</literal>. The
        <literal>partitions_count</literal> parameter specifies the
        number of partitions to create; it cannot be changed afterwards.
        If <literal>partition_data</literal> is <literal>true</literal>
        then all the data will be automatically copied from the parent
        table to partitions. Note that data migration may took a while
        to finish and the table will be locked until transaction
        commits. See <literal>partition_table_concurrently()</literal>
        for a lock-free way to migrate data. Partition creation callback
        is invoked for each partition if set beforehand (see
        <literal>set_init_callback()</literal>).
      </para>
      <programlisting>
create_range_partitions(parent_relid    REGCLASS,
                        expression      TEXT,
                        start_value     ANYELEMENT,
                        p_interval      ANYELEMENT,
                        p_count         INTEGER DEFAULT NULL
                        partition_data  BOOLEAN DEFAULT TRUE)

create_range_partitions(parent_relid    REGCLASS,
                        expression      TEXT,
                        start_value     ANYELEMENT,
                        p_interval      INTERVAL,
                        p_count         INTEGER DEFAULT NULL,
                        partition_data  BOOLEAN DEFAULT TRUE)

create_range_partitions(parent_relid    REGCLASS,
                        expression      TEXT,
                        bounds          ANYARRAY,
                        partition_names TEXT[] DEFAULT NULL,
                        tablespaces     TEXT[] DEFAULT NULL,
                        partition_data  BOOLEAN DEFAULT TRUE)
</programlisting>
      <para>
        Performs RANGE partitioning for <literal>relation</literal> by
        partitioning expression <literal>expr</literal>,
        <literal>start_value</literal> argument specifies initial value,
        <literal>p_interval</literal> sets the default range for auto
        created partitions or partitions created with
        <literal>append_range_partition()</literal> or
        <literal>prepend_range_partition()</literal> (if
        <literal>NULL</literal> then auto partition creation feature
        won’t work), <literal>p_count</literal> is the number of premade
        partitions (if not set then <literal>lt_pathman</literal> tries
        to determine it based on expression’s values). The
        <literal>bounds</literal> array can be built using
        <literal>generate_range_bounds()</literal>. Partition creation
        callback is invoked for each partition if set beforehand.
      </para>
      <programlisting>
generate_range_bounds(p_start     ANYELEMENT,
                      p_interval  INTERVAL,
                      p_count     INTEGER)

generate_range_bounds(p_start     ANYELEMENT,
                      p_interval  ANYELEMENT,
                      p_count     INTEGER)
</programlisting>
      <para>
        Builds <literal>bounds</literal> array for
        <literal>create_range_partitions()</literal>.
      </para>
    </sect3>
    <sect3 id="data-migration">
      <title>Data migration</title>
      <programlisting>
partition_table_concurrently(relation   REGCLASS,
                             batch_size INTEGER DEFAULT 1000,
                             sleep_time FLOAT8 DEFAULT 1.0)
</programlisting>
      <para>
        Starts a background worker to move data from parent table to
        partitions. The worker utilizes short transactions to copy small
        batches of data (up to 10K rows per transaction) and thus
        doesn’t significantly interfere with user’s activity. If the
        worker is unable to lock rows of a batch, it sleeps for
        <literal>sleep_time</literal> seconds before the next attempt
        and tries again up to 60 times, and quits if it’s still unable
        to lock the batch.
      </para>
      <programlisting>
stop_concurrent_part_task(relation REGCLASS)
</programlisting>
      <para>
        Stops a background worker performing a concurrent partitioning
        task. Note: worker will exit after it finishes relocating a
        current batch.
      </para>
    </sect3>
    <sect3 id="pg-pathman-triggers">
      <title>Triggers</title>
      <para>
        Triggers are no longer required nor for INSERTs, neither for
        cross-partition UPDATEs. However, user-supplied triggers
        <emphasis>are supported</emphasis>:
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            Each <emphasis role="strong">inserted row</emphasis> results
            in execution of <literal>BEFORE/AFTER INSERT</literal>
            trigger functions of a <emphasis>corresponding
            partition</emphasis>.
          </para>
        </listitem>
        <listitem>
          <para>
            Each <emphasis role="strong">updated row</emphasis> results
            in execution of <literal>BEFORE/AFTER UPDATE</literal>
            trigger functions of a <emphasis>corresponding
            partition</emphasis>.
          </para>
        </listitem>
        <listitem>
          <para>
            Each <emphasis role="strong">moved row</emphasis>
            (cross-partition update) results in execution of
            <literal>BEFORE UPDATE</literal> +
            <literal>BEFORE/AFTER DELETE</literal> +
            <literal>BEFORE/AFTER INSERT</literal> trigger functions of
            <emphasis>corresponding partitions</emphasis>.
          </para>
        </listitem>
      </itemizedlist>
    </sect3>
    <sect3 id="post-creation-partition-management">
      <title>Post-creation partition management</title>
      <programlisting>
replace_hash_partition(old_partition REGCLASS,
                       new_partition REGCLASS,
                       lock_parent   BOOLEAN DEFAULT TRUE)
</programlisting>
      <para>
        Replaces specified partition of HASH-partitioned table with
        another table. The <literal>lock_parent</literal> parameter will
        prevent any INSERT/UPDATE/ALTER TABLE queries to parent table.
      </para>
      <programlisting>
split_range_partition(partition_relid REGCLASS,
                      split_value     ANYELEMENT,
                      partition_name  TEXT DEFAULT NULL,
                      tablespace      TEXT DEFAULT NULL)
</programlisting>
      <para>
        Split RANGE <literal>partition</literal> in two by
        <literal>split_value</literal>. Partition creation callback is
        invoked for a new partition if available.
      </para>
      <programlisting>
merge_range_partitions(variadic partitions REGCLASS[])
</programlisting>
      <para>
        Merge several adjacent RANGE partitions. Partitions are
        automatically ordered by increasing bounds; all the data will be
        accumulated in the first partition.
      </para>
      <programlisting>
append_range_partition(parent_relid   REGCLASS,
                       partition_name TEXT DEFAULT NULL,
                       tablespace     TEXT DEFAULT NULL)
</programlisting>
      <para>
        Append new RANGE partition with
        <literal>pathman_config.range_interval</literal> as interval.
      </para>
      <programlisting>
prepend_range_partition(parent_relid   REGCLASS,
                        partition_name TEXT DEFAULT NULL,
                        tablespace     TEXT DEFAULT NULL)
</programlisting>
      <para>
        Prepend new RANGE partition with
        <literal>pathman_config.range_interval</literal> as interval.
      </para>
      <programlisting>
add_range_partition(parent_relid   REGCLASS,
                    start_value    ANYELEMENT,
                    end_value      ANYELEMENT,
                    partition_name TEXT DEFAULT NULL,
                    tablespace     TEXT DEFAULT NULL)
</programlisting>
      <para>
        Create new RANGE partition for <literal>relation</literal> with
        specified range bounds. If <literal>start_value</literal> or
        <literal>end_value</literal> are NULL then corresponding range
        bound will be infinite.
      </para>
      <programlisting>
drop_range_partition(partition TEXT, delete_data BOOLEAN DEFAULT TRUE)
</programlisting>
      <para>
        Drop RANGE partition and all of its data if
        <literal>delete_data</literal> is true.
      </para>
      <programlisting>
attach_range_partition(parent_relid    REGCLASS,
                       partition_relid REGCLASS,
                       start_value     ANYELEMENT,
                       end_value       ANYELEMENT)
</programlisting>
      <para>
        Attach partition to the existing RANGE-partitioned relation. The
        attached table must have exactly the same structure as the
        parent table, including the dropped columns. Partition creation
        callback is invoked if set (see
        <literal>pathman_config_params</literal>).
      </para>
      <programlisting>
detach_range_partition(partition_relid REGCLASS)
</programlisting>
      <para>
        Detach partition from the existing RANGE-partitioned relation.
      </para>
      <programlisting>
disable_pathman_for(parent_relid REGCLASS)
</programlisting>
      <para>
        Permanently disable <literal>lt_pathman</literal> partitioning
        mechanism for the specified parent table and remove the insert
        trigger if it exists. All partitions and data remain unchanged.
      </para>
      <programlisting>
drop_partitions(parent_relid REGCLASS,
                delete_data  BOOLEAN DEFAULT FALSE)
</programlisting>
      <para>
        Drop partitions of the <literal>parent</literal> table (both
        foreign and local relations). If <literal>delete_data</literal>
        is <literal>false</literal>, the data is copied to the parent
        table first. Default is <literal>false</literal>.
      </para>
      <para>
        To remove partitioned table along with all partitions fully, use
        conventional <literal>DROP TABLE relation CASCADE</literal>.
        However, care should be taken in somewhat rare case when you are
        running logical replication and <literal>DROP</literal> was
        executed by replication apply worker, e.g. via trigger on
        replicated table. <literal>lt_pathman</literal> uses
        <literal>pathman_ddl_trigger</literal> event trigger to remove
        the record about dropped table from
        <literal>pathman_config</literal>, and this trigger by default
        won’t fire on replica, leading to inconsistent state when
        <literal>lt_pathman</literal> thinks that the table still
        exists, but in fact it doesn’t. If this is the case, configure
        this trigger to fire on replica too:
      </para>
      <programlisting>
ALTER EVENT TRIGGER pathman_ddl_trigger ENABLE ALWAYS;
</programlisting>
      <para>
        Physical replication doesn’t have this problem since DDL as well
        as <literal>pathman_config</literal> table is replicated too;
        master and slave LightDB instances are basically identical, and
        it is only harmful to keep this trigger in
        <literal>ALWAYS</literal> mode.
      </para>
    </sect3>
    <sect3 id="additional-parameters">
      <title>Additional parameters</title>
      <programlisting>
set_interval(relation REGCLASS, value ANYELEMENT)
</programlisting>
      <para>
        Update RANGE partitioned table interval. Note that interval must
        not be negative and it must not be trivial, i.e. its value
        should be greater than zero for numeric types, at least 1
        microsecond for <literal>TIMESTAMP</literal> and at least 1 day
        for <literal>DATE</literal>.
      </para>
      <programlisting>
set_enable_parent(relation REGCLASS, value BOOLEAN)
</programlisting>
      <para>
        Include/exclude parent table into/from query plan. In original
        LightDB planner parent table is always included into query plan
        even if it’s empty which can lead to additional overhead. You
        can use <literal>disable_parent()</literal> if you are never
        going to use parent table as a storage. Default value depends on
        the <literal>partition_data</literal> parameter that was
        specified during initial partitioning in
        <literal>create_range_partitions()</literal> function. If the
        <literal>partition_data</literal> parameter was
        <literal>true</literal> then all data have already been migrated
        to partitions and parent table disabled. Otherwise it is
        enabled.
      </para>
      <programlisting>
set_auto(relation REGCLASS, value BOOLEAN)
</programlisting>
      <para>
        Enable/disable auto partition propagation (only for RANGE
        partitioning). It is enabled by default.
      </para>
      <programlisting>
set_init_callback(relation REGCLASS, callback REGPROC DEFAULT 0)
</programlisting>
      <para>
        Set partition creation callback to be invoked for each attached
        or created partition (both HASH and RANGE). If callback is
        marked with SECURITY INVOKER, it’s executed with the privileges
        of the user that produced a statement which has led to creation
        of a new partition
        (e.g. <literal>INSERT INTO partitioned_table VALUES (-5)</literal>).
        The callback must have the following signature:
        <literal>part_init_callback(args JSONB) RETURNS VOID</literal>.
        Parameter <literal>arg</literal> consists of several fields
        whose presence depends on partitioning type:
      </para>
      <programlisting language="json">
/* RANGE-partitioned table abc (child abc_4) */
{
    &quot;parent&quot;:           &quot;abc&quot;,
    &quot;parent_schema&quot;:    &quot;public&quot;,
    &quot;parttype&quot;:         &quot;2&quot;,
    &quot;partition&quot;:        &quot;abc_4&quot;,
    &quot;partition_schema&quot;: &quot;public&quot;,
    &quot;range_max&quot;:        &quot;401&quot;,
    &quot;range_min&quot;:        &quot;301&quot;
}

/* HASH-partitioned table abc (child abc_0) */
{
    &quot;parent&quot;:           &quot;abc&quot;,
    &quot;parent_schema&quot;:    &quot;public&quot;,
    &quot;parttype&quot;:         &quot;1&quot;,
    &quot;partition&quot;:        &quot;abc_0&quot;,
    &quot;partition_schema&quot;: &quot;public&quot;
}
</programlisting>
      <programlisting>
set_set_spawn_using_bgw(relation REGCLASS, value BOOLEAN)
</programlisting>
      <para>
        When INSERTing new data beyond the partitioning range, use
        SpawnPartitionsWorker to create new partitions in a separate
        transaction.
      </para>
    </sect3>
  </sect2>
  <sect2 id="views-and-tables">
    <title>Views and tables</title>
    <sect3 id="pathman_config-main-config-storage">
      <title><literal>pathman_config</literal> — main config
      storage</title>
      <programlisting>
CREATE TABLE IF NOT EXISTS pathman_config (
    partrel         REGCLASS NOT NULL PRIMARY KEY,
    expr            TEXT NOT NULL,
    parttype        INTEGER NOT NULL,
    range_interval  TEXT,
    cooked_expr     TEXT);
</programlisting>
      <para>
        This table stores a list of partitioned tables.
      </para>
    </sect3>
    <sect3 id="pathman_config_params-optional-parameters">
      <title><literal>pathman_config_params</literal> — optional
      parameters</title>
      <programlisting>
CREATE TABLE IF NOT EXISTS pathman_config_params (
    partrel         REGCLASS NOT NULL PRIMARY KEY,
    enable_parent   BOOLEAN NOT NULL DEFAULT TRUE,
    auto            BOOLEAN NOT NULL DEFAULT TRUE,
    init_callback   TEXT DEFAULT NULL,
    spawn_using_bgw BOOLEAN NOT NULL DEFAULT FALSE);
</programlisting>
      <para>
        This table stores optional parameters which override standard
        behavior.
      </para>
    </sect3>
    <sect3 id="pathman_concurrent_part_tasks-currently-running-partitioning-workers">
      <title><literal>pathman_concurrent_part_tasks</literal> —
      currently running partitioning workers</title>
      <programlisting>
-- helper SRF function
CREATE OR REPLACE FUNCTION show_concurrent_part_tasks()
RETURNS TABLE (
    userid     REGROLE,
    pid        INT,
    dbid       OID,
    relid      REGCLASS,
    processed  INT,
    status     TEXT)
AS 'lt_pathman', 'show_concurrent_part_tasks_internal'
LANGUAGE C STRICT;

CREATE OR REPLACE VIEW pathman_concurrent_part_tasks
AS SELECT * FROM show_concurrent_part_tasks();
</programlisting>
      <para>
        This view lists all currently running concurrent partitioning
        tasks.
      </para>
    </sect3>
    <sect3 id="pathman_partition_list-list-of-all-existing-partitions">
      <title><literal>pathman_partition_list</literal> — list of all
      existing partitions</title>
      <programlisting>
-- helper SRF function
CREATE OR REPLACE FUNCTION show_partition_list()
RETURNS TABLE (
    parent     REGCLASS,
    partition  REGCLASS,
    parttype   INT4,
    expr       TEXT,
    range_min  TEXT,
    range_max  TEXT)
AS 'lt_pathman', 'show_partition_list_internal'
LANGUAGE C STRICT;

CREATE OR REPLACE VIEW pathman_partition_list
AS SELECT * FROM show_partition_list();
</programlisting>
      <para>
        This view lists all existing partitions, as well as their
        parents and range boundaries (NULL for HASH partitions).
      </para>
    </sect3>
    <sect3 id="pathman_cache_stats-per-backend-memory-consumption">
      <title><literal>pathman_cache_stats</literal> — per-backend memory
      consumption</title>
      <programlisting>
-- helper SRF function
CREATE OR REPLACE FUNCTION @extschema@.show_cache_stats()
RETURNS TABLE (
    context     TEXT,
    size        INT8,
    used        INT8,
    entries     INT8)
AS 'lt_pathman', 'show_cache_stats_internal'
LANGUAGE C STRICT;

CREATE OR REPLACE VIEW @extschema@.pathman_cache_stats
AS SELECT * FROM @extschema@.show_cache_stats();
</programlisting>
      <para>
        Shows memory consumption of various caches.
      </para>
    </sect3>
  </sect2>
  <sect2 id="declarative-partitioning">
    <title>Declarative partitioning</title>
    <para>
      <literal>ATTACH PARTITION</literal>,
      <literal>DETACH PARTITION</literal> and
      <literal>CREATE TABLE .. PARTITION OF</literal> commands could be
      used with tables partitioned by <literal>lt_pathman</literal>:
    </para>
    <programlisting>
CREATE TABLE child1 (LIKE partitioned_table);

--- attach new partition
ALTER TABLE partitioned_table ATTACH PARTITION child1
    FOR VALUES FROM ('2015-05-01') TO ('2015-06-01');

--- detach the partition
ALTER TABLE partitioned_table DETACH PARTITION child1;

-- create a partition
CREATE TABLE child2 PARTITION OF partitioned_table
    FOR VALUES IN ('2015-05-01', '2015-06-01');
</programlisting>
  </sect2>
  <sect2 id="custom-plan-nodes">
    <title>Custom plan nodes</title>
    <para>
      <literal>lt_pathman</literal> provides a couple of
      <ulink url="https://wiki.postgresql.org/wiki/CustomScanAPI">custom
      plan nodes</ulink> which aim to reduce execution time, namely:
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          <literal>RuntimeAppend</literal> (overrides
          <literal>Append</literal> plan node)
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>RuntimeMergeAppend</literal> (overrides
          <literal>MergeAppend</literal> plan node)
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>PartitionFilter</literal> (drop-in replacement for
          INSERT triggers)
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>PartitionOverseer</literal> (implements
          cross-partition UPDATEs)
        </para>
      </listitem>
      <listitem>
        <para>
          <literal>PartitionRouter</literal> (implements cross-partition
          UPDATEs)
        </para>
      </listitem>
    </itemizedlist>
    <para>
      <literal>PartitionFilter</literal> acts as a <emphasis>proxy
      node</emphasis> for INSERT’s child scan, which means it can
      redirect output tuples to the corresponding partition:
    </para>
    <programlisting>
EXPLAIN (COSTS OFF)
INSERT INTO partitioned_table
SELECT generate_series(1, 10), random();
               QUERY PLAN
-----------------------------------------
 Insert on partitioned_table
   -&gt;  Custom Scan (PartitionFilter)
         -&gt;  Subquery Scan on &quot;*SELECT*&quot;
               -&gt;  Result
(4 rows)
</programlisting>
    <para>
      <literal>PartitionOverseer</literal> and
      <literal>PartitionRouter</literal> are another <emphasis>proxy
      nodes</emphasis> used in conjunction with
      <literal>PartitionFilter</literal> to enable cross-partition
      UPDATEs (i.e. when update of partitioning key requires that we
      move row to another partition). Since this node has a great deal
      of side effects (ordinary <literal>UPDATE</literal> becomes
      slower; cross-partition <literal>UPDATE</literal> is transformed
      into <literal>DELETE + INSERT</literal>), it is disabled by
      default. To enable it, refer to the list of
      <link linkend="disabling-lt_pathman">GUCs</link> below.
    </para>
    <programlisting>
EXPLAIN (COSTS OFF)
UPDATE partitioned_table
SET value = value + 1 WHERE value = 2;
                       QUERY PLAN
---------------------------------------------------------
 Custom Scan (PartitionOverseer)
   -&gt;  Update on partitioned_table_2
         -&gt;  Custom Scan (PartitionFilter)
               -&gt;  Custom Scan (PartitionRouter)
                     -&gt;  Seq Scan on partitioned_table_2
                           Filter: (value = 2)
(6 rows)
</programlisting>
    <para>
      <literal>RuntimeAppend</literal> and
      <literal>RuntimeMergeAppend</literal> have much in common: they
      come in handy in a case when WHERE condition takes form of:
    </para>
    <programlisting>
VARIABLE OP PARAM
</programlisting>
    <para>
      This kind of expressions can no longer be optimized at planning
      time since the parameter’s value is not known until the execution
      stage takes place. The problem can be solved by embedding the
      <emphasis>WHERE condition analysis routine</emphasis> into the
      original <literal>Append</literal>’s code, thus making it pick
      only required scans out of a whole bunch of planned partition
      scans. This effectively boils down to creation of a custom node
      capable of performing such a check.
    </para>
    <para>
      There are at least several cases that demonstrate usefulness of
      these nodes:
    </para>
    <programlisting>
/* create table we're going to partition */
CREATE TABLE partitioned_table(id INT NOT NULL, payload REAL);

/* insert some data */
INSERT INTO partitioned_table
SELECT generate_series(1, 1000), random();

/* perform partitioning */
SELECT create_hash_partitions('partitioned_table', 'id', 100);

/* create ordinary table */
CREATE TABLE some_table AS SELECT generate_series(1, 100) AS VAL;
</programlisting>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          <emphasis role="strong"><literal>id = (select ... limit 1)</literal></emphasis>
        </para>
      </listitem>
    </itemizedlist>
    <programlisting>
EXPLAIN (COSTS OFF, ANALYZE) SELECT * FROM partitioned_table
WHERE id = (SELECT * FROM some_table LIMIT 1);
                                             QUERY PLAN
----------------------------------------------------------------------------------------------------
 Custom Scan (RuntimeAppend) (actual time=0.030..0.033 rows=1 loops=1)
   InitPlan 1 (returns $0)
     -&gt;  Limit (actual time=0.011..0.011 rows=1 loops=1)
           -&gt;  Seq Scan on some_table (actual time=0.010..0.010 rows=1 loops=1)
   -&gt;  Seq Scan on partitioned_table_70 partitioned_table (actual time=0.004..0.006 rows=1 loops=1)
         Filter: (id = $0)
         Rows Removed by Filter: 9
 Planning time: 1.131 ms
 Execution time: 0.075 ms
(9 rows)

/* disable RuntimeAppend node */
SET lt_pathman.enable_runtimeappend = f;

EXPLAIN (COSTS OFF, ANALYZE) SELECT * FROM partitioned_table
WHERE id = (SELECT * FROM some_table LIMIT 1);
                                    QUERY PLAN
----------------------------------------------------------------------------------
 Append (actual time=0.196..0.274 rows=1 loops=1)
   InitPlan 1 (returns $0)
     -&gt;  Limit (actual time=0.005..0.005 rows=1 loops=1)
           -&gt;  Seq Scan on some_table (actual time=0.003..0.003 rows=1 loops=1)
   -&gt;  Seq Scan on partitioned_table_0 (actual time=0.014..0.014 rows=0 loops=1)
         Filter: (id = $0)
         Rows Removed by Filter: 6
   -&gt;  Seq Scan on partitioned_table_1 (actual time=0.003..0.003 rows=0 loops=1)
         Filter: (id = $0)
         Rows Removed by Filter: 5
         ... /* more plans follow */
 Planning time: 1.140 ms
 Execution time: 0.855 ms
(306 rows)
</programlisting>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          <emphasis role="strong"><literal>id = ANY (select ...)</literal></emphasis>
        </para>
      </listitem>
    </itemizedlist>
    <programlisting>
EXPLAIN (COSTS OFF, ANALYZE) SELECT * FROM partitioned_table
WHERE id = any (SELECT * FROM some_table limit 4);
                                                QUERY PLAN
-----------------------------------------------------------------------------------------------------------
 Nested Loop (actual time=0.025..0.060 rows=4 loops=1)
   -&gt;  Limit (actual time=0.009..0.011 rows=4 loops=1)
         -&gt;  Seq Scan on some_table (actual time=0.008..0.010 rows=4 loops=1)
   -&gt;  Custom Scan (RuntimeAppend) (actual time=0.002..0.004 rows=1 loops=4)
         -&gt;  Seq Scan on partitioned_table_70 partitioned_table (actual time=0.001..0.001 rows=10 loops=1)
         -&gt;  Seq Scan on partitioned_table_26 partitioned_table (actual time=0.002..0.003 rows=9 loops=1)
         -&gt;  Seq Scan on partitioned_table_27 partitioned_table (actual time=0.001..0.002 rows=20 loops=1)
         -&gt;  Seq Scan on partitioned_table_63 partitioned_table (actual time=0.001..0.002 rows=9 loops=1)
 Planning time: 0.771 ms
 Execution time: 0.101 ms
(10 rows)

/* disable RuntimeAppend node */
SET lt_pathman.enable_runtimeappend = f;

EXPLAIN (COSTS OFF, ANALYZE) SELECT * FROM partitioned_table
WHERE id = any (SELECT * FROM some_table limit 4);
                                       QUERY PLAN
-----------------------------------------------------------------------------------------
 Nested Loop Semi Join (actual time=0.531..1.526 rows=4 loops=1)
   Join Filter: (partitioned_table.id = some_table.val)
   Rows Removed by Join Filter: 3990
   -&gt;  Append (actual time=0.190..0.470 rows=1000 loops=1)
         -&gt;  Seq Scan on partitioned_table (actual time=0.187..0.187 rows=0 loops=1)
         -&gt;  Seq Scan on partitioned_table_0 (actual time=0.002..0.004 rows=6 loops=1)
         -&gt;  Seq Scan on partitioned_table_1 (actual time=0.001..0.001 rows=5 loops=1)
         -&gt;  Seq Scan on partitioned_table_2 (actual time=0.002..0.004 rows=14 loops=1)
... /* 96 scans follow */
   -&gt;  Materialize (actual time=0.000..0.000 rows=4 loops=1000)
         -&gt;  Limit (actual time=0.005..0.006 rows=4 loops=1)
               -&gt;  Seq Scan on some_table (actual time=0.003..0.004 rows=4 loops=1)
 Planning time: 2.169 ms
 Execution time: 2.059 ms
(110 rows)
</programlisting>
    <itemizedlist spacing="compact">
      <listitem>
        <para>
          <emphasis role="strong"><literal>NestLoop</literal> involving
          a partitioned table</emphasis>, which is omitted since it’s
          occasionally shown above.
        </para>
      </listitem>
    </itemizedlist>
  </sect2>
  <sect2 id="examples">
    <title>Examples</title>
    <sect3 id="common-tips">
      <title>Common tips</title>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            You can easily add
            <emphasis role="strong"><emphasis>partition</emphasis></emphasis>
            column containing the names of the underlying partitions
            using the system attribute called
            <emphasis role="strong"><emphasis>tableoid</emphasis></emphasis>:
          </para>
        </listitem>
      </itemizedlist>
      <programlisting>
SELECT tableoid::regclass AS partition, * FROM partitioned_table;
</programlisting>
      <itemizedlist>
        <listitem>
          <para>
            Though indices on a parent table aren’t particularly useful
            (since it’s supposed to be empty), they act as prototypes
            for indices on partitions. For each index on the parent
            table, <literal>lt_pathman</literal> will create a similar
            index on every partition.
          </para>
        </listitem>
        <listitem>
          <para>
            All running concurrent partitioning tasks can be listed
            using the <literal>pathman_concurrent_part_tasks</literal>
            view:
          </para>
        </listitem>
      </itemizedlist>
      <programlisting>
SELECT * FROM pathman_concurrent_part_tasks;
 userid | pid  | dbid  | relid | processed | status
--------+------+-------+-------+-----------+---------
 dmitry | 7367 | 16384 | test  |    472000 | working
(1 row)
</programlisting>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>pathman_partition_list</literal> in conjunction
            with <literal>drop_range_partition()</literal> can be used
            to drop RANGE partitions in a more flexible way compared to
            good old <literal>DROP TABLE</literal>:
          </para>
        </listitem>
      </itemizedlist>
      <programlisting>
SELECT drop_range_partition(partition, false) /* move data to parent */
FROM pathman_partition_list
WHERE parent = 'part_test'::regclass AND range_min::int &lt; 500;
NOTICE:  1 rows copied from part_test_11
NOTICE:  100 rows copied from part_test_1
NOTICE:  100 rows copied from part_test_2
 drop_range_partition
----------------------
 dummy_test_11
 dummy_test_1
 dummy_test_2
(3 rows)
</programlisting>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            You can turn foreign tables into partitions using the
            <literal>attach_range_partition()</literal> function. Rows
            that were meant to be inserted into parent will be
            redirected to foreign partitions (as usual, PartitionFilter
            will be involved), though by default it is prohibited to
            insert rows into partitions provided not by
            <literal>postgres_fdw</literal>. Only superuser is allowed
            to set <literal>lt_pathman.insert_into_fdw</literal>
            <link linkend="disabling-lt_pathman">GUC</link> variable.
          </para>
        </listitem>
      </itemizedlist>
    </sect3>
    <sect3 id="hash-partitioning">
      <title>HASH partitioning</title>
      <para>
        Consider an example of HASH partitioning. First create a table
        with some integer column:
      </para>
      <programlisting>
CREATE TABLE items (
    id       SERIAL PRIMARY KEY,
    name     TEXT,
    code     BIGINT);

INSERT INTO items (id, name, code)
SELECT g, md5(g::text), random() * 100000
FROM generate_series(1, 100000) as g;
</programlisting>
      <para>
        Now run the <literal>create_hash_partitions()</literal> function
        with appropriate arguments:
      </para>
      <programlisting>
SELECT create_hash_partitions('items', 'id', 100);
</programlisting>
      <para>
        This will create new partitions and move the data from parent to
        partitions.
      </para>
      <para>
        Here’s an example of the query performing filtering by
        partitioning key:
      </para>
      <programlisting>
SELECT * FROM items WHERE id = 1234;
  id  |               name               | code
------+----------------------------------+------
 1234 | 81dc9bdb52d04dc20036dbd8313ed055 | 1855
(1 row)

EXPLAIN SELECT * FROM items WHERE id = 1234;
                                     QUERY PLAN
------------------------------------------------------------------------------------
 Append  (cost=0.28..8.29 rows=0 width=0)
   -&gt;  Index Scan using items_34_pkey on items_34  (cost=0.28..8.29 rows=0 width=0)
         Index Cond: (id = 1234)
</programlisting>
      <para>
        Notice that the <literal>Append</literal> node contains only one
        child scan which corresponds to the WHERE clause.
      </para>
      <blockquote>
        <para>
          <emphasis role="strong">Important:</emphasis> pay attention to
          the fact that <literal>lt_pathman</literal> excludes the
          parent table from the query plan.
        </para>
      </blockquote>
      <para>
        To access parent table use ONLY modifier:
      </para>
      <programlisting>
EXPLAIN SELECT * FROM ONLY items;
                      QUERY PLAN
------------------------------------------------------
 Seq Scan on items  (cost=0.00..0.00 rows=1 width=45)
</programlisting>
    </sect3>
    <sect3 id="range-partitioning">
      <title>RANGE partitioning</title>
      <para>
        Consider an example of RANGE partitioning. Let’s create a table
        containing some dummy logs:
      </para>
      <programlisting>
CREATE TABLE journal (
    id      SERIAL,
    dt      TIMESTAMP NOT NULL,
    level   INTEGER,
    msg     TEXT);

-- similar index will also be created for each partition
CREATE INDEX ON journal(dt);

-- generate some data
INSERT INTO journal (dt, level, msg)
SELECT g, random() * 6, md5(g::text)
FROM generate_series('2015-01-01'::date, '2015-12-31'::date, '1 minute') as g;
</programlisting>
      <para>
        Run the <literal>create_range_partitions()</literal> function to
        create partitions so that each partition would contain the data
        for one day:
      </para>
      <programlisting>
SELECT create_range_partitions('journal', 'dt', '2015-01-01'::date, '1 day'::interval);
</programlisting>
      <para>
        It will create 365 partitions and move the data from parent to
        partitions.
      </para>
      <para>
        New partitions are appended automaticaly by insert trigger, but
        it can be done manually with the following functions:
      </para>
      <programlisting>
-- add new partition with specified range
SELECT add_range_partition('journal', '2016-01-01'::date, '2016-01-07'::date);

-- append new partition with default range
SELECT append_range_partition('journal');
</programlisting>
      <para>
        The first one creates a partition with specified range. The
        second one creates a partition with default interval and appends
        it to the partition list. It is also possible to attach an
        existing table as partition. For example, we may want to attach
        an archive table (or even foreign table from another server) for
        some outdated data:
      </para>
      <programlisting>
CREATE FOREIGN TABLE journal_archive (
    id      INTEGER NOT NULL,
    dt      TIMESTAMP NOT NULL,
    level   INTEGER,
    msg     TEXT)
SERVER archive_server;

SELECT attach_range_partition('journal', 'journal_archive', '2014-01-01'::date, '2015-01-01'::date);
</programlisting>
      <blockquote>
        <para>
          <emphasis role="strong">Important:</emphasis> the definition
          of the attached table must match the one of the existing
          partitioned table, including the dropped columns.
        </para>
      </blockquote>
      <para>
        To merge to adjacent partitions, use the
        <literal>merge_range_partitions()</literal> function:
      </para>
      <programlisting>
SELECT merge_range_partitions('journal_archive', 'journal_1');
</programlisting>
      <para>
        To split partition by value, use the
        <literal>split_range_partition()</literal> function:
      </para>
      <programlisting>
SELECT split_range_partition('journal_366', '2016-01-03'::date);
</programlisting>
      <para>
        To detach partition, use the
        <literal>detach_range_partition()</literal> function:
      </para>
      <programlisting>
SELECT detach_range_partition('journal_archive');
</programlisting>
      <para>
        Here’s an example of the query performing filtering by
        partitioning key:
      </para>
      <programlisting>
SELECT * FROM journal WHERE dt &gt;= '2015-06-01' AND dt &lt; '2015-06-03';
   id   |         dt          | level |               msg
--------+---------------------+-------+----------------------------------
 217441 | 2015-06-01 00:00:00 |     2 | 15053892d993ce19f580a128f87e3dbf
 217442 | 2015-06-01 00:01:00 |     1 | 3a7c46f18a952d62ce5418ac2056010c
 217443 | 2015-06-01 00:02:00 |     0 | 92c8de8f82faf0b139a3d99f2792311d
 ...
(2880 rows)

EXPLAIN SELECT * FROM journal WHERE dt &gt;= '2015-06-01' AND dt &lt; '2015-06-03';
                            QUERY PLAN
------------------------------------------------------------------
 Append  (cost=0.00..58.80 rows=0 width=0)
   -&gt;  Seq Scan on journal_152  (cost=0.00..29.40 rows=0 width=0)
   -&gt;  Seq Scan on journal_153  (cost=0.00..29.40 rows=0 width=0)
(3 rows)
</programlisting>
    </sect3>
    <sect3 id="disabling-lt_pathman">
      <title>Disabling <literal>lt_pathman</literal></title>
      <para>
        There are several user-accessible
        <link linkend="config-setting">GUC</link> variables designed
        to toggle the whole module or specific custom nodes on and off:
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>lt_pathman.enable</literal> — disable (or enable)
            <literal>lt_pathman</literal>
            <emphasis role="strong">completely</emphasis>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>lt_pathman.enable_runtimeappend</literal> — toggle
            <literal>RuntimeAppend</literal> custom node on
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>lt_pathman.enable_runtimemergeappend</literal> —
            toggle <literal>RuntimeMergeAppend</literal> custom node on
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>lt_pathman.enable_partitionfilter</literal> —
            toggle <literal>PartitionFilter</literal> custom node on(for
            INSERTs)
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>lt_pathman.enable_partitionrouter</literal> —
            toggle <literal>PartitionRouter</literal> custom node on(for
            cross-partition UPDATEs)
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>lt_pathman.enable_auto_partition</literal> — toggle
            automatic partition creation on(per session)
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>lt_pathman.enable_bounds_cache</literal> — toggle
            bounds cache on(faster updates of partitioning scheme)
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>lt_pathman.insert_into_fdw</literal> — allow
            INSERTs into various FDWs
            <literal>(disabled | postgres | any_fdw)</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>lt_pathman.override_copy</literal> — toggle COPY
            statement hooking on
          </para>
        </listitem>
      </itemizedlist>
      <para>
        To <emphasis role="strong">permanently</emphasis> disable
        <literal>lt_pathman</literal> for some previously partitioned
        table, use the <literal>disable_pathman_for()</literal>
        function:
      </para>
      <programlisting>
SELECT disable_pathman_for('range_rel');
</programlisting>
      <para>
        All sections and data will remain unchanged and will be handled
        by the standard LightDB inheritance mechanism.
      </para>
    </sect3>
  </sect2>
</sect1>
