<!-- doc/src/sgml/pgqualstats.sgml -->

<sect1 id="ltqualstats" xreflabel="lt_qualstats">
    <title>lt_qualstats</title>

    <indexterm zone="ltqualstats">
        <primary>lt_qualstats</primary>
    </indexterm>

    <para>
        The lt_qualstats is a LightDB extension keeping statistics
        on predicates found in <literal>WHERE</literal> statements and <literal>JOIN</literal> clauses.
    </para>

    <para>
        This is useful if you want to be able to analyze what are the most-often executed quals (predicates) on your database.
    </para>

    <para>
        It also allows you to identify correlated columns, by identifying
        which columns are most frequently queried together.
    </para>

    <para>
        The extension works by looking for known patterns in queries. Currently, this includes:
    </para>

    <itemizedlist>
        <listitem>
            <para>
                Binary OpExpr where at least one side is a column from a table. Whenever possible,
                the predicate will be swaped so that CONST OP VAR expressions are turned into VAR COMMUTED_OP CONST.
                AND and OR expression members are counted as separate entries.
                Ex: WHERE column1 = 2, WHERE column1 = column2, WHERE 3 = column3
            </para>
        </listitem>

        <listitem>
            <para>
                ScalarArrayOpExpr where the left side is a VAR, and the right side is an array constant.
                Those will be counted one time per element in the array.
                Ex: WHERE column1 IN (2, 3) will be counted as 2 occurences for the (column1, '=') operator pair
            </para>
        </listitem>

        <listitem>
            <para>
                BooleanTest where the expression is a simple boolean column reference
                Ex: WHERE column1 IS TRUE Please not that clauses like WHERE columns1,
                WHERE NOT column1 won't be processed by lt_qualstats (yet)
            </para>
        </listitem>
    </itemizedlist>

    <para>
        This extension also saves the first query text, as-is, for each distinct queryid executed,
        with a limit of <literal>lt_qualstats.max</literal> entries.
    </para>

    <para>
        Please not that the gathered data are not saved when the <productname>LightDB</productname> server is restarted.
    </para>

    <sect2>
        <title>Configuration</title>

        <para>
            The following GUCs can be configured, in lightdb.conf:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    <literal>lt_qualstats.enabled</literal> (boolean, default true): whether or not lt_qualstats should be enabled
                </para>
            </listitem>

            <listitem>
                <para>
                    <literal>lt_qualstats.track_constants</literal> (bolean, default true): whether or not lt_qualstats
                    should keep track of each constant value individually. Disabling this GUC
                    will considerably reduce the number of entries necessary to keep track of predicates.
                </para>
            </listitem>

            <listitem>
                <para>
                    <literal>lt_qualstats.max</literal>: the maximum number of predicated and query text tracked (defaults to 1000)
                </para>
            </listitem>

            <listitem>
                <para>
                    <literal>lt_qualstats.resolve_oids</literal> (boolean, default false): whether or not lt_qualstats
                    should resolve oids at query time, or juste store the oids. Enabling this parameter makes
                    the data analysis much more easy, since a connection to the database where the query was
                    executed won't be necessary, but it will eat much more space (624 bytes per entry instead of 176).
                    Additionnaly, this will require some catalog lookups, which aren't free.
                </para>
            </listitem>

            <listitem>
                <para>
                    <literal>lt_qualstats.track_pg_catalog</literal> (boolean, default false):
                    whether or not lt_qualstats should compute predicates on object in pg_catalog schema.
                </para>
            </listitem>

            <listitem>
                <para>
                    <literal>lt_qualstats.sample_rate</literal> (double, default -1): the fraction of queries
                    that should be sampled. For example, 0.1 means that only one out of ten
                    queries will be sampled. The default (-1) means automatic, and results in
                    a value of 1 / max_connections, so that statiscally, concurrency issues will be rare.
                </para>
            </listitem>
        </itemizedlist>
    </sect2>

    <sect2>
        <title>Updating the extension</title>

        <para>
            Note that as all extensions configured in shared_preload_libraries,
            most of the changes are only applied once LightDB is restarted with the new shared library.
            The extension object itself only provides SQL wrappers to access internal data structures.
        </para>

        <para>
            Also note that lt_qualstats doesn't provide extension upgrade scripts,
            as there's no data saved in any of the objects created. Therefore,
            you need to first drop the extension then create it again to get the new version.
        </para>
    </sect2>

    <sect2>
        <title>Usage</title>

        <itemizedlist>
            <listitem>
                <para>
                    Create the extension in any database:
                </para>

                <programlisting>
                       CREATE EXTENSION lt_qualstats;
                </programlisting>
            </listitem>
        </itemizedlist>

        <sect3>
            <title>Functions</title>

            <para>
                The extension defines the following functions:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <literal>pg_qualstats</literal>: returns the counts for every qualifier,
                        identified by the expression hash. This hash identifies each expression.
                    </para>

                    <itemizedlist>
                        <listitem>
                            <para>
                                <literal>userid</literal>: oid of the user who executed the query.
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                <literal>dbid</literal>: oid of the database in which the query has been executed.
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                <literal>lrelid, lattnum</literal>: oid of the relation and attribute number of the VAR on the left hand side, if any.
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                <literal>opno</literal>: oid of the operator used in the expression
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                <literal>rrelid, rattnum</literal>: oid of the relation and attribute number of the VAR on the right hand side, if any.
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                <literal>qualid</literal>: normalized identifier of the parent "AND" expression, if any.
                                This identifier is computed excluding the constants. This is useful for identifying predicates which are used together.
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                <literal>uniquequalid</literal>: unique identifier of the parent "AND" expression, if any.
                                This identifier is computed including the constants.
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                <literal>qualnodeid</literal>: normalized identifier of this simple predicate.
                                This identifier is computed excluding the constants.
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                <literal>uniquequalnodeid</literal>: unique identifier of this simple predicate.
                                This identifier is computed including the constats.
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                <literal>occurences</literal>: number of time this predicate has been invoked, ie. number of related query execution.
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                <literal>execution_count</literal>: number of time this predicate has been executed, ie. number of rows it processed.
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                <literal>nbfiltered</literal>: number of tuples this predicate discarded.
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                <literal>constant_position</literal>: location of the constant in the original query string, as reported by the parser.
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                <literal>queryid</literal>: if pg_stats_statements is installed, the queryid identifying this query, otherwise NULL.
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                <literal>constvalue</literal>: a string representation of the right-hand side constant, if any,
                                truncated to 80 bytes. Require to be superuser or member of <literal>pg_read_all_stats</literal>
                                , "" will be showed instead.
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                <literal>eval_type</literal>: evaluation type. 'f' for a predicate evaluated after a scan or 'i' for an index predicate.
                            </para>
                        </listitem>
                    </itemizedlist>

                    <para>
                        Example:
                    </para>

                    <programlisting>
                        ro=# select * from pg_qualstats;
                         userid │ dbid  │ lrelid │ lattnum │ opno │ rrelid │ rattnum │ qualid │ uniquequalid │ qualnodeid │ uniquequalnodeid │ occurences │ execution_count │ nbfiltered │ constant_position │ queryid │   constvalue   │ eval_type
                        --------+--------+---------+----------+-------+---------+----------+---------+---------------+-------------+-------------------+-------------+------------------+-------------+--------------------+----------+-----------------+------------
                             10 │ 16384 │  16385 │       2 │   98 │        │         │        │              │  115075651 │       1858640877 │          1 │          100000 │      99999 │                29 │         │ 'line 1'::text │ f
                             10 │ 16384 │  16391 │       2 │   98 │  16385 │       2 │        │              │  497379130 │        497379130 │          1 │               0 │          0 │                   │         │                │ f
                    </programlisting>
                </listitem>

                <listitem>
                    <para>
                        <literal>pg_qualstats_index_advisor(min_filter, min_selectivity, forbidden_am)</literal>:
                        Perform a global index suggestion. By default, only predicates filtering at
                        least 1000 rows and 30% of the rows in average will be considered,
                        but this can be passed as parameter. You can also provide an array of index
                        access method if you want to avoid some.
                    </para>

                    <para>
                        Example:
                    </para>

                    <programlisting>
                        SELECT v
                          FROM json_array_elements(
                            pg_qualstats_index_advisor(min_filter => 50)->'indexes') v
                          ORDER BY v::text COLLATE "C";
                                                       v
                        ---------------------------------------------------------------
                         "CREATE INDEX ON public.adv USING btree (id1)"
                         "CREATE INDEX ON public.adv USING btree (val, id1, id2, id3)"
                         "CREATE INDEX ON public.pgqs USING btree (id)"
                        (3 rows)

                        SELECT v
                          FROM json_array_elements(
                            pg_qualstats_index_advisor(min_filter => 50)->'unoptimised') v
                          ORDER BY v::text COLLATE "C";
                                v
                        -----------------
                         "adv.val ~~* ?"
                        (1 row)
                    </programlisting>
                </listitem>

                <listitem>
                    <para>
                        <literal>pg_qualstats_deparse_qual</literal>: format a stored predicate in the form tablename.
                        columname operatorname ?. This is mostly for the global index advisor.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <literal>pg_qualstats_get_idx_col</literal>: for the given predicate, retrieve the underlying
                        column name and all the possible operator class. This is mostly for the global index advisor.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <literal>pg_qualstats_get_qualnode_rel</literal>: for the given predicate, return the
                        underlying table, fully qualified. This is mostly for the global index advisor
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <literal>pg_qualstats_example_queries</literal>: return all the stored query texts.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <literal>pg_qualstats_example_query</literal>: return the stored query text for the given queryid if any, otherwise NULL.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <literal>pg_qualstats_names</literal>: return all the stored query texts.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <literal>pg_qualstats_reset</literal>: reset the internal counters and forget about every encountered qual.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>

        <sect3>
            <title>Views</title>

            <para>
                In addition to that, the extension defines some views on top of the pg_qualstats function:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        <literal>pg_qualstats</literal>: filters calls to pg_qualstats() by the current database.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        <literal>pg_qualstats_pretty</literal>: performs the appropriate joins to display a
                        readable aggregated form for every attribute from the pg_qualstats view
                    </para>

                    <para>
                        Example:
                    </para>

                    <programlisting>
                        ro=# select * from pg_qualstats_pretty;
                         left_schema |    left_table    | left_column |   operator   | right_schema | right_table | right_column | occurences | execution_count | nbfiltered
                        -------------+------------------+-------------+--------------+--------------+-------------+--------------+------------+-----------------+------------
                         public      | ltbench_accounts | aid         | pg_catalog.= |              |             |              |          5 |         5000000 |    4999995
                         public      | ltbench_tellers  | tid         | pg_catalog.= |              |             |              |         10 |        10000000 |    9999990
                         public      | ltbench_branches | bid         | pg_catalog.= |              |             |              |         10 |         2000000 |    1999990
                         public      | t1               | id          | pg_catalog.= | public       | t2          | id_t1        |          1 |           10000 |       9999
                    </programlisting>
                </listitem>

                <listitem>
                    <para>
                        <literal>pg_qualstats_all</literal>: sums the counts for each attribute / operator pair, regardless
                        of its position as an operand (LEFT or RIGHT), grouping together attributes used in AND clauses.
                    </para>

                    <para>
                        Example:
                    </para>

                    <programlisting>
                        ro=# select * from pg_qualstats_all;
                         dbid  | relid | userid | queryid | attnums | opno | qualid | occurences | execution_count | nbfiltered | qualnodeid
                        ------+-------+--------+---------+---------+------+--------+------------+-----------------+------------+------------
                         16384 | 16385 |     10 |         | {2}     |   98 |        |          1 |          100000 |      99999 |  115075651
                         16384 | 16391 |     10 |         | {2}     |   98 |        |          2 |               0 |          0 |  497379130
                    </programlisting>
                </listitem>

                <listitem>
                    <para>
                        <literal>pg_qualstats_by_query</literal>: returns only predicates of the form VAR OPERATOR CONSTANT, aggregated by queryid.
                    </para>
                </listitem>
            </itemizedlist>
        </sect3>
    </sect2>
</sect1>